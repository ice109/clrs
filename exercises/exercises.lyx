#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass amsart
\begin_preamble
\usepackage{tikz}
\usepackage{graphicx}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{decorations.pathreplacing}
\usepackage{xparse}% http://ctan.org/pkg/xparse
\usepackage{parskip}
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\branch Deleted
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\topmargin 2cm
\bottommargin 2cm
\secnumdepth 5
\tocdepth 5
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part*
Note
\end_layout

\begin_layout Standard

\series bold
I have variously stolen, plagiarized, copied, etc.
 from many places.
 Rarely I cite.
 This is out of pure laziness on my part.
 For the sake of intellectual honesty consider that absolutely none of this
 is my own work (it's simply a collection).
 
\series default
Maybe eventually I'll go back and cite but probably not.
\end_layout

\begin_layout Standard
Everything is 
\begin_inset Formula $1$
\end_inset

 indexed, despite using vaguely Pythonic syntax.
 This means 
\begin_inset Formula $A\left[\text{len}\left(A\right)\right]=A\left[-1\right]$
\end_inset

.
 Slicing is 
\begin_inset Formula $A\left[a:b\right]=\left[A_{a},A_{a+1},\dots,A_{b-1}\right]$
\end_inset

.
 
\end_layout

\begin_layout Standard
Where bounds checking is obviously necessary it is omitted.
 I assume a different memory model from Python: each entry of 
\begin_inset Formula $B=\left[\left[\right]\right]$
\end_inset

 is an independent list.
 
\end_layout

\begin_layout Standard
Ranges are represented using MATLAB notation 
\begin_inset Formula $1:n$
\end_inset

.
 
\end_layout

\begin_layout Standard
In certain places I play fast and loose with what a dictionary is keyed
 on and whether a label is just a label or a pointer (in particular in the
 Graph Algorithms section).
 Also I iterate over a dictionary, which is possible with python's 
\family typewriter
dict.items
\family default

\begin_inset Formula $\left(\right)$
\end_inset

.
\end_layout

\begin_layout Standard
The layout has large gaps intentionally.
 This is so pictures and diagrams follow their introductions/allusions/reference
s in the text.
 That means if a picture/diagram is introduced and isn't on the page then
 it leads on the following page.
\end_layout

\begin_layout Part
Foundations
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addtocounter{section}{3}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Divide-and-Conquer
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[4.1-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 4.1-5}
\end_layout

\end_inset

Given 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

, how to find the subarray with the maximum positive sum? Write a linear-time,
 nonrecursive algorithm for the maximum-subarray problem.
\end_layout

\begin_layout Standard
Kidane's algorithm: change the problem to look at maximum sum subarray ending
 at some 
\begin_inset Formula $j$
\end_inset

.
 Maximum sum subarray ending at 
\begin_inset Formula $j$
\end_inset

 is either empty, i.e.
 has negative sum, in which case its sum is 0, or includes 
\begin_inset Formula $A\left[j\right]$
\end_inset

.
 The maximum sum subarray in all of 
\begin_inset Formula $A$
\end_inset

 is the maximum of all subarrays ending at all 
\begin_inset Formula $j$
\end_inset

.
 Running time is 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.2\textwidth},xrightmargin={.2\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Kidane-Max-Subarray$
\backslash
left(A
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# $m$_  is max
\end_layout

\begin_layout Plain Layout

	$m_{here} = m_{all} = A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	for $i=2:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

		$m_{here} = 
\backslash
max
\backslash
left(0,m_{here}+A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$m_{all} = 
\backslash
max
\backslash
left(m_{all},m_{here}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	return $m_{all}$
\end_layout

\end_inset


\end_layout

\end_inset

Note that if at 
\begin_inset Formula $j-1$
\end_inset

 the subarray was empty, and hence 
\begin_inset Formula $m_{here}=0$
\end_inset

 then at 
\begin_inset Formula $j$
\end_inset

 it's the case that 
\begin_inset Formula $m_{here}=A\left[j\right]$
\end_inset

.
 In order to recover the actual subarray you need to keep track of whether
 counting is reset or subarray is extended.
 Easiest way to do this is using Python tricks.
 In general this is calling keeping 
\begin_inset Quotes eld
\end_inset

back-pointers
\begin_inset Quotes erd
\end_inset

 and works in all such cases for reconstructing the solution (forthwith
 omitted).
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.001\textwidth},xrightmargin={.001\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Kidane-Max-Subarray-Mod$
\backslash
left(A
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m_{here} = m_{all} = 
\backslash
left[[~],A
\backslash
left[1
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	for $i=2:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

		# take max wrt.
 first entry of arguments, i.e.
 $
\backslash
max
\backslash
left(0,m_{here}+A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$m_{here}=
\backslash
max
\backslash
left(
\backslash
left[0,[~]
\backslash
right],
\backslash
left[m_{here}+A
\backslash
left[i
\backslash
right],m_{here}
\backslash
text{.append}
\backslash
left(A
\backslash
left[i
\backslash
right]
\backslash
right)
\backslash
right] ,
\backslash
text{key=itemgetter}
\backslash
left(1
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$m_{all} = 
\backslash
max
\backslash
left(m_{all},m_{here},
\backslash
text{key=itemgetter}
\backslash
left(1
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	return $m_{all}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[4-4]
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 4-4}
\end_layout

\end_inset

Fibonacci numbers.
 Given the generating function for Fibonacci numbers 
\begin_inset Formula 
\[
\mathcal{F}\left(z\right)=\sum_{i=0}^{\infty}F_{i}z^{i}
\]

\end_inset

where 
\begin_inset Formula $F_{i}$
\end_inset

 is the 
\begin_inset Formula $i$
\end_inset

th Fibonacci number
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Show that 
\begin_inset Formula $\mathcal{F}\left(z\right)=z+z\mathcal{F}\left(z\right)+z^{2}\mathcal{F}\left(z\right)$
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Let 
\begin_inset Formula $\mathcal{F}\left(z\right)=\left(0,1,1,2,3,5,8,13,\dots\right)$
\end_inset

 the coefficients of the terms.
 Then multiplication by 
\begin_inset Formula $z$
\end_inset


\begin_inset Formula 
\[
z\mathcal{F}\left(z\right)=\left(0,0,1,1,2,3,5,8,\dots\right)
\]

\end_inset

and
\begin_inset Formula 
\[
z^{2}\mathcal{F}\left(z\right)=\left(0,0,0,1,1,2,3,5,\dots\right)
\]

\end_inset

Hence 
\begin_inset Formula 
\begin{alignat*}{2}
\quad z & = & \left(0,1,0,0,0,0,0,0,\dots\right)\;\\
\quad z\mathcal{F}\left(z\right) & = & \left(0,0,1,1,2,3,5,8,\dots\right)\;\\
\underline{+z^{2}\mathcal{F}\left(z\right)} & = & \left(0,0,0,1,1,2,3,5,\dots\right)\;\\
\quad\mathcal{F}\left(z\right) & = & \quad\left(0,1,1,2,3,5,8,13,\dots\right)
\end{alignat*}

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Show that 
\begin_inset Formula 
\[
\mathcal{F}\left(z\right)=\frac{1}{\sqrt{5}}\left(\frac{1}{1-\phi z}-\frac{1}{1-\hat{\phi}z}\right)
\]

\end_inset

where 
\begin_inset Formula $\phi=\frac{1+\sqrt{5}}{2}$
\end_inset

 and 
\begin_inset Formula $\hat{\phi}=\frac{1-\sqrt{5}}{2}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Since
\begin_inset Formula 
\[
F\left(z\right)=z+zF\left(z\right)+z^{2}F\left(z\right)
\]

\end_inset

we have that 
\begin_inset Formula 
\[
F\left(z\right)\left(1-z-z^{2}\right)=z
\]

\end_inset

or
\begin_inset Formula 
\[
F\left(z\right)=\frac{z}{1-z-z^{2}}
\]

\end_inset

Factoring the denominator
\begin_inset Formula 
\begin{eqnarray*}
F\left(z\right) & = & \frac{z}{-\left(z+\frac{\left(1-\sqrt{5}\right)}{2}\right)\left(z+\frac{1+\sqrt{5}}{2}\right)}\\
 & = & \frac{z}{\left(1-z\left(\frac{1+\sqrt{5}}{2}\right)\right)\left(1-z\left(\frac{1-\sqrt{5}}{2}\right)\right)}\\
 & = & \frac{z}{\left(1-\phi z\right)\left(1-\hat{\phi}z\right)}\\
 & = & \frac{1}{\sqrt{5}}\left(\frac{1}{\left(1-\phi z\right)}-\frac{1}{\left(1-\hat{\phi}z\right)}\right)
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Show that 
\begin_inset Formula 
\[
\mathcal{F}\left(z\right)=\sum_{i=0}^{\infty}\frac{1}{\sqrt{5}}\left(\phi^{i}-\left(\hat{\phi}\right)^{i}\right)z^{i}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Using the Taylor series 
\begin_inset Formula 
\[
\frac{1}{1-x}=\sum_{n=0}^{\infty}x^{n}
\]

\end_inset

we have by above
\begin_inset Formula 
\begin{eqnarray*}
F\left(z\right) & = & \frac{1}{\sqrt{5}}\left(\frac{1}{\left(1-\phi z\right)}-\frac{1}{\left(1-\hat{\phi}z\right)}\right)\\
 & = & \frac{1}{\sqrt{5}}\left(\sum_{n=0}^{\infty}\left(\phi z\right)^{n}-\sum_{n=0}^{\infty}\left(\hat{\phi}z\right)^{n}\right)\\
 & = & \sum_{n=0}^{\infty}\frac{1}{\sqrt{5}}\left(\phi^{n}-\hat{\phi}^{n}\right)z^{n}
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(d)]
\end_layout

\end_inset

Use part (c) to prove that 
\begin_inset Formula $\left\{ F_{i}\right\} =\phi^{i}/\sqrt{5}$
\end_inset

, where 
\begin_inset Formula $\left\{ \right\} $
\end_inset

 is rounding to the nearest integer.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 By comparing coefficients in the the original generating function and the
 re-expression
\begin_inset Formula 
\[
F\left(z\right)=\sum_{n=0}^{\infty}F_{n}z^{n}=\sum_{n=0}^{\infty}\frac{1}{\sqrt{5}}\left(\phi^{n}-\hat{\phi}^{n}\right)z^{n}
\]

\end_inset

we see that 
\begin_inset Formula 
\[
F_{n}=\frac{1}{\sqrt{5}}\left(\phi^{n}-\hat{\phi}^{n}\right)
\]

\end_inset

Since 
\begin_inset Formula $\left|\hat{\phi}\right|<1$
\end_inset

 it's the case that 
\begin_inset Formula $\left|\hat{\phi}^{n}\right|<1$
\end_inset

 and hence is fractional.
\end_layout

\end_deeper
\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[4-5]
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 4-5}
\end_layout

\end_inset

Chip testing.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Show that if more than 
\begin_inset Formula $n/2$
\end_inset

 chips are bad, the professor cannot necessarily determine which chips are
 good using any strategy based on this kind of pairwise test.
 Assume that the bad chips can conspire to fool the professor.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Let 
\begin_inset Formula $g$
\end_inset

 be the number of good chips and 
\begin_inset Formula $n-g\geq g$
\end_inset

 be the number of bad chips.
 Then there exists a set of good chips 
\begin_inset Formula $G$
\end_inset

 and a set of bad chips 
\begin_inset Formula $B$
\end_inset

 such that 
\begin_inset Formula $\left|G\right|=\left|B\right|$
\end_inset

.
 The bad chips can conspire to fool the professor in the following way:
 they call themselves good and the actually good chips bad.
 The good chips of course report exactly antisymmetrically that they're
 good and the bad chips are bad.
 Therefore these two sets of chips are indistinguishable.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Consider the problem of finding a single good chip from among 
\begin_inset Formula $n$
\end_inset

 chips, assuming that more than 
\begin_inset Formula $n/2$
\end_inset

 of the chips are good.
 Show that 
\begin_inset Formula $\left\lfloor n/2\right\rfloor $
\end_inset

 pairwise tests are sufficient to reduce the problem to one of nearly half
 the size.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Note that if a test is 
\begin_inset Formula $\left(\mbox{good},\mbox{good}\right)$
\end_inset

 then either both chips are bad or both good.
 Otherwise at least one is bad.
 Here's the Divide-and-Conquer algorithm:
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(1)]
\end_layout

\end_inset

If there's only one chip, then it must be good.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(2)]
\end_layout

\end_inset

Split the chips into two-chip pairs.
 If the number of chips is odd let 
\begin_inset Formula $c$
\end_inset

 denote the odd one out.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(3)]
\end_layout

\end_inset

Test each pair.
 If the result if 
\begin_inset Formula $\left(\mbox{good},\mbox{good}\right)$
\end_inset

, then throw one away, otherwise throw away both.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(4)]
\end_layout

\end_inset

Repeat.
\end_layout

\begin_layout Standard
The algorithm performs 
\begin_inset Formula $\left\lfloor n/2\right\rfloor $
\end_inset

 pairwise tests, and keeps at most 
\begin_inset Formula $\left\lceil n/2\right\rceil $
\end_inset

 chips.
 Now to show that at least half of the remaining chips are good each time:
 at a particular iteration, assume 
\begin_inset Formula $x$
\end_inset

 pairs consist of two good chips, 
\begin_inset Formula $y$
\end_inset

 pairs are mixed, 
\begin_inset Formula $z$
\end_inset

 pairs consist of bad chips.
 Then there are possibilities:
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $n$
\end_inset

 is even, then 
\begin_inset Formula $g=2x+y\geq y+2z=b$
\end_inset

 and 
\begin_inset Formula $x\geq y$
\end_inset

 implies more at least as many good chips as bad chips remain.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $n$
\end_inset

 is odd, and 
\begin_inset Formula $c$
\end_inset

 is bad then 
\begin_inset Formula $g=2x+y\geq y+2z+1=b$
\end_inset

 and 
\begin_inset Formula $x\geq z+1$
\end_inset

 (since 
\begin_inset Formula $x,z$
\end_inset

 are integers).
 Since in fact 
\begin_inset Formula $x$
\end_inset

 good chips and 
\begin_inset Formula $z+1$
\end_inset

 bad chips remain, it is the case that more good chips than bad chips remain.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $n$
\end_inset

 is odd, and 
\begin_inset Formula $c$
\end_inset

 is good then 
\begin_inset Formula $g=2x+y+1\geq y+2z=b$
\end_inset

 and 
\begin_inset Formula $x+1\geq z$
\end_inset

 (since 
\begin_inset Formula $x,z$
\end_inset

 are integers).
 Since in fact 
\begin_inset Formula $x+1$
\end_inset

 good chips and 
\begin_inset Formula $z$
\end_inset

 bad chips remain, it is the case that more good chips than bad chips remain.
\end_layout

\begin_layout Standard
Therefore more good chips than bad chips remain always.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Show that the good chips can be identified with 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 pairwise tests, assuming that more than 
\begin_inset Formula $n/2$
\end_inset

 of the chips are good.
 Give and solve the recurrence that describes the number of tests.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Use the result of (b) to find a good chip in 
\begin_inset Formula $\Theta\left(\lg n\right)$
\end_inset

 time and then use it to perform the other 
\begin_inset Formula $n-1$
\end_inset

 comparisons.
\end_layout

\end_deeper
\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[4-6]
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 4-6}
\end_layout

\end_inset

Monge arrays.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Prove that an array is Monge iff for all 
\begin_inset Formula $i=1,\dots m-1$
\end_inset

 and 
\begin_inset Formula $j=1,\dots,n-1$
\end_inset

 we have that 
\begin_inset Formula 
\[
A\left[i,j\right]+A\left[i+1,j+1\right]\leq A\left[i,j+1\right]+A\left[i+1,j\right]
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 If an array is Monge then it the property holds by defintion.
 Conversely suppose an 
\begin_inset Formula $m\times n$
\end_inset

 array has the property.
 We prove that 
\begin_inset Formula 
\[
A\left[i,j\right]+A\left[i+x,j+y\right]\leq A\left[i,j+y\right]+A\left[i+x,j\right]
\]

\end_inset

for all 
\begin_inset Formula $x,y$
\end_inset

 such that 
\begin_inset Formula $1\leq x\leq m-1$
\end_inset

 and 
\begin_inset Formula $1\leq y\leq n-j$
\end_inset

, i.e.
 the array is Monge.
 For 
\begin_inset Formula $x=y=1$
\end_inset

 the property holds by assumption.
 First suppose 
\begin_inset Formula $x'<m$
\end_inset

 and 
\begin_inset Formula $y'\leq n$
\end_inset

 and the property holds for all 
\begin_inset Formula $x,y$
\end_inset

 such that 
\begin_inset Formula $1\leq x\leq x'$
\end_inset

 and 
\begin_inset Formula $1\leq y\leq y'$
\end_inset

.
 Then it holds for 
\begin_inset Formula $x=x'+1$
\end_inset

 and 
\begin_inset Formula $y='y$
\end_inset

: consider 
\begin_inset Formula $i<m-x'$
\end_inset

 and 
\begin_inset Formula $j\leq n-y'$
\end_inset

.
 By assumption we have that
\begin_inset Formula 
\[
A\left[i,j\right]+A\left[i+x',j+y'\right]\leq A\left[i,j+y'\right]+A\left[i+x',j\right]
\]

\end_inset

and
\begin_inset Formula 
\[
A\left[i+x',j\right]+A\left[i+x'+1,j+y'\right]\leq A\left[i+x',j+y'\right]+A\left[i+x'+1,j\right]
\]

\end_inset

Summing these two implies
\begin_inset Formula 
\[
A\left[i,j\right]+A\left[i+x'+1,j+y'\right]\leq A\left[i,j+y'\right]+A\left[i+x'+1,j\right]
\]

\end_inset

Similarly we can argue the case for 
\begin_inset Formula $x'\leq m$
\end_inset

 and 
\begin_inset Formula $y'<n$
\end_inset

 and thus it holds for 
\begin_inset Formula $x=x'$
\end_inset

 and 
\begin_inset Formula $y=y'+1$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Let 
\begin_inset Formula $f\left(i\right)$
\end_inset

 be the index of the column containing the leftmost minimum element of row
 
\begin_inset Formula $i$
\end_inset

.
 Prove that 
\begin_inset Formula $f\left(1\right)\leq f\left(2\right)\leq\cdots\leq f\left(m\right)$
\end_inset

 for any 
\begin_inset Formula $m\times n$
\end_inset

 Monge array.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 By contradiction: assume the inequality is false.
 Then there is some 
\begin_inset Formula $i$
\end_inset

 such that 
\begin_inset Formula $f\left(i\right)>f\left(i+1\right)$
\end_inset

 such that 
\begin_inset Formula $A\left[i,f\left(i+1\right)\right]>A\left[i,f\left(i\right)\right]$
\end_inset

.
 Then
\begin_inset Formula 
\[
A\left[i,f\left(i+1\right)\right]+A\left[i+1,f\left(i\right)\right]>A\left[i,f\left(i\right)\right]+A\left[i+1,f\left(i+1\right)\right]
\]

\end_inset

a contradiction.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(d)]
\end_layout

\end_inset

Here is a description of a divide-and-conquer algorithm that computes the
 left- most minimum element in each row of an 
\begin_inset Formula $m\times n$
\end_inset

 Monge array 
\begin_inset Formula $A$
\end_inset

: Construct a submatrix 
\begin_inset Formula $A'$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 consisting of the even-numbered rows of 
\begin_inset Formula $A$
\end_inset

.
 Recursively determine the leftmost minimum for each row of 
\begin_inset Formula $A'$
\end_inset

.
 Then compute the leftmost minimum in the odd-numbered rows of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Explain how to compute the leftmost minimum in the odd-numbered rows of
 A (given that the leftmost minimum, and its index, of the even-numbered
 rows is known) in 
\begin_inset Formula $O\left(m+n\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Using part (c), if we know the minimum elements 
\begin_inset Formula $f\left(i\right)$
\end_inset

 for the even rows then for each odd 
\begin_inset Formula $2i+1$
\end_inset

 row we only need to check columns between 
\begin_inset Formula $f\left(2i\right)$
\end_inset

 and 
\begin_inset Formula $f\left(2i+2\right)$
\end_inset

.
 Hence we can compute the minima of the odd rows in time 
\begin_inset Formula 
\[
\sum_{i=1}^{m/2}f\left(2i+2\right)-f\left(2i\right)+1=O\left(m+n\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(e)]
\end_layout

\end_inset

Write the recurrence describing the running time of the algorithm described
 in part (d).
 Show that its solution is 
\begin_inset Formula $O\left(m+n\lg m\right)$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 The recurrence is 
\begin_inset Formula 
\begin{eqnarray*}
T\left(m\right) & = & T\left(m/2\right)+O\left(m+n\right)\\
 & = & O\left(\sum_{k=0}^{\lg m}\left(\frac{m}{2^{k}}+n\right)\right)\\
 & = & O\left(m+n\lg m\right)
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addtocounter{section}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Part
Sorting and Order Statistics
\end_layout

\begin_layout Section
Heapsort
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[6.5-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 6.5-7}
\end_layout

\end_inset

 Show how to implement a first-in, first-out queue with a priority queue.
 Show how to implement a stack with a priority queue.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Run a timer.
 To construct a FIFO make the priority key the insertion time.
 To construct a LIFO make the priority key 
\begin_inset Formula $1/\mbox{insertion time}$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[6.5-9]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 6.5-9}
\end_layout

\end_inset

 Give an 
\begin_inset Formula $O\left(n\lg k\right)$
\end_inset

 algorithm for constructing a sorted array from 
\begin_inset Formula $k$
\end_inset

 already sorted arrays (where the total number of elements is 
\begin_inset Formula $n$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Use a MinHeap with the extract min property: construct a MinHeap from first
 elements in each array.
 Pop the the minimum element and add to a surrogate array.
 Replace with the next element of the array that that one came from.
 This way the smallast element of each of the 
\begin_inset Formula $k$
\end_inset

 arrays is always in direct competition.
 Constructing the initial array is 
\begin_inset Formula $O\left(k\right)$
\end_inset

 and then each of the Extract-min operations costs 
\begin_inset Formula $\lg k$
\end_inset

, hence 
\begin_inset Formula $O\left(n\lg k\right)$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[6-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 6-3}
\end_layout

\end_inset

 Young tableuax.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Give an algorithm to implement 
\begin_inset Formula $\texttt{Extract-Min}$
\end_inset

 on a nonempty 
\begin_inset Formula $m\times n$
\end_inset

 Young tableau that runs in 
\begin_inset Formula $O\left(m+n\right)$
\end_inset

 time.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 
\begin_inset Formula $Y\left[1,1\right]$
\end_inset

 is clearly the minimum.
 Pop it and replace it with the bottom right element, then 
\begin_inset Quotes eld
\end_inset

percolate down
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(d)]
\end_layout

\end_inset

Show how to insert a new element into a nonfull 
\begin_inset Formula $m\times n$
\end_inset

 Young tableau in 
\begin_inset Formula $O\left(m+n\right)$
\end_inset

 time.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Insert at the bottom right, then 
\begin_inset Quotes eld
\end_inset

percoluate up
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(e)]
\end_layout

\end_inset

Using no other sorting method as a subroutine, show how to use an 
\begin_inset Formula $n\times n$
\end_inset

 Young tableau to sort 
\begin_inset Formula $n^{2}$
\end_inset

 numbers in 
\begin_inset Formula $O\left(n^{3}\right)$
\end_inset

 time.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Repeatedly 
\begin_inset Formula $\texttt{Extract-Min}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(f)]
\end_layout

\end_inset

Give an 
\begin_inset Formula $O\left(m+n\right)$
\end_inset

-time algorithm to determine whether a given number is stored in a given
 
\begin_inset Formula $m\times n$
\end_inset

 Young tableau.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Start at the top right, then you know everything below you is greater and
 everything to the left is smaller.
 If the number you're looking for is smaller than the current entry then
 go left, and if the number is greater than the current entry then go down.
\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Quicksort
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[7-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 7-6}
\end_layout

\end_inset

 Fuzzy sorting of intervals.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Design a randomized algorithm for fuzzy-sorting n intervals.
 Your algorithm should have the general structure of an algorithm that quicksort
s the left endpoints (the 
\begin_inset Formula $a_{i}$
\end_inset

 values), but it should take advantage of overlapping intervals to improve
 the running time.
 (As the intervals overlap more and more, the problem of fuzzy-sorting the
 intervals becomes progressively easier.
 Your algorithm should take advantage of such overlapping, to the extent
 that it exists.).
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 The key is that two intervals intersect (overlap) then they don't need
 to be sorted.
 That's where the speedup comes from.
 To that end here's code to compute the intersection (if any exists) of
 a set 
\begin_inset Formula $I=\left(\left(a_{1},b_{1}\right),\dots,\left(a_{n},b_{n}\right)\right)$
\end_inset

 of intervals
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.2\textwidth},xrightmargin={.2\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Intersection$
\backslash
left(I
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$ i = 
\backslash
text{random}
\backslash
left(
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$I
\backslash
left[-1
\backslash
right],I
\backslash
left[i
\backslash
right]=I
\backslash
left[i
\backslash
right],I
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$a,b = I
\backslash
left[-1
\backslash
right]
\backslash
left[1
\backslash
right], I
\backslash
left[-1
\backslash
right]
\backslash
left[2
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	for $i=1:
\backslash
text{len}
\backslash
left(I
\backslash
right)-1$: 
\end_layout

\begin_layout Plain Layout

		if $a
\backslash
leq I
\backslash
left[i
\backslash
right]
\backslash
left[1
\backslash
right]
\backslash
leq b$ or $a
\backslash
leq I
\backslash
left[i
\backslash
right]
\backslash
left[2
\backslash
right]
\backslash
leq b$:
\end_layout

\begin_layout Plain Layout

			if $ a< I
\backslash
left[i
\backslash
right]
\backslash
left[1
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

				$a = I
\backslash
left[i
\backslash
right]
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			if $ B
\backslash
left[i
\backslash
right] < b$:
\end_layout

\begin_layout Plain Layout

				$b = I
\backslash
left[i
\backslash
right]
\backslash
left[2
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	return $a,b$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This computes the intersection of all intervals if one exists; it does not
 find one! Note that 
\begin_inset Formula $a\leq I\left[i\right]\left[1\right]\leq b\text{ or }a\leq I\left[i\right]\left[2\right]\leq b$
\end_inset

 can be simplified down to 
\begin_inset Formula $I\left[i\right]\left[1\right]\leq b\,\wedge I\left[i\right]\left[1\right]\geq a$
\end_inset

, since 
\begin_inset Formula $a_{i}\leq b_{i}$
\end_inset

.
 Running time is clearly 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Now using the model of 
\begin_inset Formula $\texttt{Quicksort}$
\end_inset

 we can build a 
\begin_inset Formula $\texttt{Fuzzy-sort}$
\end_inset

: partition the input array into 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

middle
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

 subarrays, where the 
\begin_inset Quotes eld
\end_inset

middle
\begin_inset Quotes erd
\end_inset

 subarray contains intervals that overlap the intersection of all of them
 [the intervals] and don't need to be sorted any further.
 Running time is 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

 in general but if all of the intervals overlap then the recursion returns
 without executing anything and so only the 
\begin_inset Formula $\texttt{filter}$
\end_inset

s run (which are 
\begin_inset Formula $O\left(n\right)$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.01\textwidth},xrightmargin={.01\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Fuzzy-Sort$
\backslash
left(I
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	if len$
\backslash
left(I
\backslash
right)
\backslash
leq 1$:
\end_layout

\begin_layout Plain Layout

		return $I$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout
\noindent
\align left

		$a,b = 
\backslash
text{Intersection}
\backslash
left(A,B
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# first partition for similar reasons to Quicksort,
\end_layout

\begin_layout Plain Layout

		# in order to actually sort, i.e.
 everything in $I_{right}$
\end_layout

\begin_layout Plain Layout

		# follows everything in $I_{left}$ in the final ordering
\end_layout

\begin_layout Plain Layout

		# but use $a$ as the pivot in order for the second 
\end_layout

\begin_layout Plain Layout

		# partition to be effective
\end_layout

\begin_layout Plain Layout

		$I_{left} = 
\backslash
text{filter}
\backslash
left(I,
\backslash
lambda i: i
\backslash
left[1
\backslash
right]
\backslash
leq a
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$I_{right} =
\backslash
text{filter}
\backslash
left(I,
\backslash
lambda i: i
\backslash
left[1
\backslash
right] > a
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# find all the intervals in $I_{left}$ that overlap $
\backslash
left[a,b
\backslash
right]$, but 
\end_layout

\begin_layout Plain Layout

		# since $
\backslash
left[a,b
\backslash
right]$ is an intersection it should be 
\end_layout

\begin_layout Plain Layout

		# contained in these intervals
\end_layout

\begin_layout Plain Layout

		# therefore everything in $I_{middle}$ is such that $ 
\backslash
left[a,b
\backslash
right]
\backslash
subseteq 
\backslash
left[a_i,b_i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		$I_{middle} = 
\backslash
text{filter}
\backslash
left(I,
\backslash
lambda i:   b 
\backslash
leq i
\backslash
left[2
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# and $I_{left-left}$ is everything else.
\end_layout

\begin_layout Plain Layout

		$I_{left-left} = 
\backslash
text{filter}
\backslash
left(I,
\backslash
lambda i: i
\backslash
left[2
\backslash
right] < b
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		return $
\backslash
text{Fuzzy-Sort}
\backslash
left(I_{left-left}
\backslash
right) + I_{middle} + 
\backslash
text{Fuzzy-Sort}
\backslash
left(I_{right}
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Sorting in Linear Time
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[8.2-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 8.2-4}
\end_layout

\end_inset

 Describe an algorithm that, given 
\begin_inset Formula $n$
\end_inset

 integers in the range 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

, preprocesses its input and then answers any query about how many of the
 
\begin_inset Formula $n$
\end_inset

 integers fall into a range 
\begin_inset Formula $\left[a\dots b\right]$
\end_inset

 in 
\begin_inset Formula $O\left(1\right)$
\end_inset

 time.
 Your algorithm should use 
\begin_inset Formula $\Theta\left(n+k\right)$
\end_inset

 preprocessing time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Suppose the the cumulates array constructed by 
\begin_inset Formula $\texttt{Counting-Sort}$
\end_inset

 is 
\begin_inset Formula $C$
\end_inset

.
 Then 
\begin_inset Formula $C\left[b\right]-C\left[a\right]$
\end_inset

 is the answer to the query.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[8.3-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 8.3-4}
\end_layout

\end_inset

 Show how to sort 
\begin_inset Formula $n$
\end_inset

 integers in the range 0 to 
\begin_inset Formula $n^{3}$
\end_inset

-1 in 
\begin_inset Formula $O\left(n\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 
\begin_inset Formula $n$
\end_inset

 base 
\begin_inset Formula $n$
\end_inset

 the number 
\begin_inset Formula $n^{3}-1$
\end_inset

 are two digits numbers e.g.
 
\begin_inset Formula $1000_{n}=1\times n^{3}+0n^{2}+0n+0\times1$
\end_inset

.
 So we make 4 passes using radix sort
\begin_inset Formula 
\[
\Theta\left(4\left(n+n\right)\right)=O\left(n\right)
\]

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[8.4-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 8.4-4}
\end_layout

\end_inset

 We are given n points in the unit circle, 
\begin_inset Formula $p_{i}=\left(x_{i},y_{i}\right)$
\end_inset

, such that 
\begin_inset Formula $0<x_{i}^{2}+y_{i}^{2}\leq1$
\end_inset

 for 
\begin_inset Formula $i=1,\dots,n$
\end_inset

.
 Suppose that the points are uniformly distributed; that is, the probability
 of finding a point in any region of the circle is proportional to the area
 of that region.
 Design an algorithm with an average-case running time of 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 to sort the 
\begin_inset Formula $n$
\end_inset

 points by their distances 
\begin_inset Formula $d_{i}=\sqrt{x_{i}^{2}+y_{i}^{2}}$
\end_inset

 from the origin.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 A differential ring of area on the unit circle is 
\begin_inset Formula $dA=2\pi rdr$
\end_inset

 so using bucket sort we can divide up the buckets according this scaling.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[8.4-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 8.4-5}
\end_layout

\end_inset

 Suppose that we draw a list of 
\begin_inset Formula $n$
\end_inset

 random variables 
\begin_inset Formula $X_{1},\dots,X_{n}$
\end_inset

 from a continuous probability distribution function 
\begin_inset Formula $P$
\end_inset

 that is computable in 
\begin_inset Formula $O\left(1\right)$
\end_inset

 time.
 Give an algorithm that sorts these numbers in linear average-case time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 
\begin_inset Formula $Y=P\left(X_{i}\right)$
\end_inset

 is uniformly distributed.
\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[8-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 8-5}
\end_layout

\end_inset

 Jugs.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Describe a deterministic algorithm that uses 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

 comparisons to group the jugs into pairs.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Test every blue jug against every red jug.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Skip.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Show how to match the jugs in 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

 time.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 You could match up the jugs by sorting each set and lining them up.
 Too bad you can't compare red jugs against red jugs right? But you can
 just use the 
\begin_inset Formula $\texttt{Quicksort}$
\end_inset

 model and with blue jugs being pivots for red jugs and red jugs being pivots
 for blue jugs.
\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Medians and Order Statistics
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[9.1-1]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 9.1-1}
\end_layout

\end_inset

 Show that the second smallest of 
\begin_inset Formula $n$
\end_inset

 elements can be found with 
\begin_inset Formula $n+\left\lceil \lg n\right\rceil -2$
\end_inset

 comparisons in the worst case.
 
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Tournament style to determine minimum: comparing all pairs costs 
\begin_inset Formula $n/2$
\end_inset

, compare all winners of the first round costs 
\begin_inset Formula $n/4$
\end_inset

, etc.
 In total this is 
\begin_inset Formula $n-1$
\end_inset

 comparisons.
 The only way in which the second smallest element is not in the final round
 is it was eliminated in an earlier round.
 Therefore keep track of all of the elements that the smallest element 
\begin_inset Quotes eld
\end_inset

played
\begin_inset Quotes erd
\end_inset

 against, which is 
\begin_inset Formula $\left\lceil \lg n\right\rceil $
\end_inset

, and find the smallest of them.
 This costs 
\begin_inset Formula $\left\lceil \lg n\right\rceil -1$
\end_inset

 comparisons.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[9.3-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 9.3-5}
\end_layout

\end_inset

 Suppose that you have a “black-box” worst-case linear-time median subroutine.
 Give a simple, linear-time algorithm that solves the selection problem
 for an arbitrary order statistic.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Suppose the rank you're looking for is 
\begin_inset Formula $r$
\end_inset

 and the number of elements is 
\begin_inset Formula $n$
\end_inset

.
 Use binary search: find the median, then if the order statistic is higher
 than the median find the 
\begin_inset Formula $r-\left\lfloor n/2\right\rfloor $
\end_inset

 order statistic of the elements larger than the median, and if the order
 statistic is lower then find the rank 
\begin_inset Formula $r$
\end_inset

 statistic of the elements smaller than the median, and so on.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[9.3-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 9.3-6}
\end_layout

\end_inset

 The 
\begin_inset Formula $k$
\end_inset

th quantiles of an 
\begin_inset Formula $n$
\end_inset

-element set are the 
\begin_inset Formula $k-1$
\end_inset

 order statistics that divide the sorted set into 
\begin_inset Formula $k$
\end_inset

 equal-sized sets (to within 1).
 Give an 
\begin_inset Formula $O\left(n\lg k\right)$
\end_inset

-time algorithm to list the 
\begin_inset Formula $k$
\end_inset

th quantiles of a set.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 If 
\begin_inset Formula $k$
\end_inset

 is even then there are 
\begin_inset Formula $k-1$
\end_inset

 (an odd number) of 
\begin_inset Quotes eld
\end_inset

pivots
\begin_inset Quotes erd
\end_inset

 and one of them is the median.
 Find the median, partition, then solve the subproblems.
 If 
\begin_inset Formula $k$
\end_inset

 is odd do the same thing but be more careful.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[9.3-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 9.3-7}
\end_layout

\end_inset

Describe an 
\begin_inset Formula $O\left(n\right)$
\end_inset

-time algorithm that, given a set 
\begin_inset Formula $S$
\end_inset

 of 
\begin_inset Formula $n$
\end_inset

 distinct numbers and a positive integer 
\begin_inset Formula $k\leq n$
\end_inset

, determines the 
\begin_inset Formula $k$
\end_inset

 numbers in 
\begin_inset Formula $S$
\end_inset

 that are closest to the median of 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Find the median, then subtract the median from every element, then find
 the 
\begin_inset Formula $k$
\end_inset

th order statistic (and in doing so partition).
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[9.3-8]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 9.3-8}
\end_layout

\end_inset

Let 
\begin_inset Formula $X\left[1\dots n\right]$
\end_inset

 and 
\begin_inset Formula $Y\left[1\dots n\right]$
\end_inset

 be two arrays, each containing 
\begin_inset Formula $n$
\end_inset

 numbers already in sorted order.
 Give an 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

-time algorithm to find the median of all 
\begin_inset Formula $2n$
\end_inset

 elements in arrays 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 The median all of 
\begin_inset Formula $2n$
\end_inset

 elements is always in between the median of each array (by value).
 Compute the medians in 
\begin_inset Formula $O\left(1\right)$
\end_inset

 time.
 If they're equal return them.
 Otherwise recurse to either the leftside or rightside of each array depending
 on which median is larger than which.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[9.3-9]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 9.3-9}
\end_layout

\end_inset

Given the 
\begin_inset Formula $x$
\end_inset

- and 
\begin_inset Formula $y$
\end_inset

-coordinates of the wells, how should the professor pick the optimal location
 of the main pipeline, which would be the one that minimizes the total length
 of the spurs? Show how to determine the optimal location in linear time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 The median is the element that minimizes the 
\begin_inset Formula $L_{1}$
\end_inset

 norm, i.e.
 the sum of distances.
\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[9-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 9-2}
\end_layout

\end_inset

 Weighted median.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Argue that the median of 
\begin_inset Formula $x_{1},\dots,x_{n}$
\end_inset

 is the weighted median of the 
\begin_inset Formula $x_{i}$
\end_inset

 with weights 
\begin_inset Formula $w_{i}=1/n$
\end_inset

 for 
\begin_inset Formula $i=1,\dots,n$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 This is trivially true (algebraically).
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Show how to compute the weighted median of 
\begin_inset Formula $n$
\end_inset

 elements in 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

 worst-case time using sorting.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Sort then sum weights, in order of increasing elements, until you exceed
 
\begin_inset Formula $1/2$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Show how to compute the weighted median in 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 worst-case time using a linear-time median algorithm such as 
\begin_inset Formula $\texttt{SELECT}$
\end_inset

 from Section 9.3.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solutio n
\series default
.
 Call 
\begin_inset Formula $t=1/2$
\end_inset

 the target.
 Find the median (and in doing so partition around it) and compute the sum
 of the weights in the 
\begin_inset Quotes eld
\end_inset

lower
\begin_inset Quotes erd
\end_inset

 half.
 If they sum to 
\begin_inset Formula $t$
\end_inset

 then return the median.
 If the exceed then compute the median in the 
\begin_inset Quotes eld
\end_inset

lower
\begin_inset Quotes erd
\end_inset

 half.
 If the sum is less than 
\begin_inset Formula $t$
\end_inset

 then compute the median in the 
\begin_inset Quotes eld
\end_inset

top half
\begin_inset Quotes erd
\end_inset

 but with target being 
\begin_inset Formula $t$
\end_inset

 minus the sum you just computed.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(d)]
\end_layout

\end_inset

Argue that the weighted median is a best solution for the 1-dimensional
 post- office location problem, in which points are simply real numbers
 and the dis- tance between points 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 is 
\begin_inset Formula $d\left(a,b\right)=\left|a-b\right|$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 This is true for the same reason the median minimizes the 
\begin_inset Formula $L_{1}$
\end_inset

 norm.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(e)]
\end_layout

\end_inset

Find the best solution for the 2-dimensional post-office location problem,
 in which the points are 
\begin_inset Formula $\left(x,y\right)$
\end_inset

 coordinate pairs and the distance between points 
\begin_inset Formula $a=\left(x_{1},y_{,1}\right)$
\end_inset

 and 
\begin_inset Formula $b=\left(x_{2},y_{2}\right)$
\end_inset

 is the Manhattan distance given by 
\begin_inset Formula $d\left(a,b\right)=\left|x_{1}-x_{2}\right|+\left|y_{1}-y_{2}\right|$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Since the components of the distance 
\begin_inset Quotes eld
\end_inset

vector
\begin_inset Quotes erd
\end_inset

 are decoupled you can just do median in each coordinate, i.e.
 take the median of all of the 
\begin_inset Formula $x_{i}$
\end_inset

 and the median of all of the 
\begin_inset Formula $y_{i}$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Part
Data Structures
\end_layout

\begin_layout Section
Elementary Data Structures
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[10.1-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 10.1-2}
\end_layout

\end_inset

 Explain how to implement two stacks in one array 
\begin_inset Formula $A\left[1\dots n\right]$
\end_inset

 in such a way that neither stack overflows unless the total number of elements
 in both stacks together is 
\begin_inset Formula $n$
\end_inset

.
 The 
\begin_inset Formula $\texttt{PUSH}$
\end_inset

 and 
\begin_inset Formula $\texttt{POP}$
\end_inset

 operations should run in 
\begin_inset Formula $O\left(1\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Have one stack grow from the left side of the array and the other stack
 from the right side of the array (store their ends).
 When they collide then they're both 
\begin_inset Quotes eld
\end_inset

full
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[10.1-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 10.1-5}
\end_layout

\end_inset

 Whereas a stack allows insertion and deletion of elements at only one end,
 and a queue allows insertion at one end and deletion at the other end,
 a deque (double-ended queue) allows insertion and deletion at both ends.
 Write four 
\begin_inset Formula $O\left(1\right)$
\end_inset

-time procedures to insert elements into and delete elements from both ends
 of a deque implemented by an array.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Either use a circular list with the head and tail linked or an array using
 mod to update indices that keep track of the back and front and checking
 for collision of the indices.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[10.1-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 10.1-6}
\end_layout

\end_inset

 Show how to implement a queue using two stacks.
 Analyze the running time of the queue operations.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Call the two stacks 
\begin_inset Quotes eld
\end_inset

inbox
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

outbox
\begin_inset Quotes erd
\end_inset

.
 Push to one stack and pop from the other.
 If the "outbox" stack is empty then pop everything from the inbox stack
 and push to outbox stack.
 They'll be pushed in reverse order and pops will produce the correct behavior.
 Amortized time is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[10.1-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 10.1-7}
\end_layout

\end_inset

 Show how to implement a stack using two queues.
 Analyze the running time of the stack operations.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Exactly like 10.1-6.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[10.4-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 10.4-2}
\end_layout

\end_inset

 Write an 
\begin_inset Formula $O\left(n\right)$
\end_inset

-time recursive procedure that, given an 
\begin_inset Formula $n$
\end_inset

-node binary tree, prints out the key of each node in the tree.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 DFS (or BFS).
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[10.4-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 10.4-3}
\end_layout

\end_inset

 Write an 
\begin_inset Formula $O\left(n\right)$
\end_inset

-time nonrecursive procedure that, given an 
\begin_inset Formula $n$
\end_inset

-node binary tree, prints out the key of each node in the tree.
 Use a stack as an auxiliary data structure.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 This is of course DFS but written iteratively.
 Assume the tree is represented by a 
\begin_inset Formula $\texttt{dict}\left(\right)$
\end_inset

 with 
\begin_inset Formula $\texttt{'leftchild'}$
\end_inset

 and 
\begin_inset Formula $\texttt{'rightchild'}$
\end_inset

 keys (whose corresponding values are the nodes).
 Since we're traversing a tree we don't need to check for backpointers (i.e.
 don't need to mark visited).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.2\textwidth},xrightmargin={.2\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

DFS$
\backslash
left(T
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$stk = 
\backslash
left[T
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	while len$
\backslash
left(stk
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

		$ next = 
\backslash
text{stk.pop}
\backslash
left(
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		if $next$ is not None:
\end_layout

\begin_layout Plain Layout

			print $next$
\end_layout

\begin_layout Plain Layout

			stk.append$
\backslash
left(next
\backslash
left[
\backslash
text{'leftchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

			stk.append$
\backslash
left(next
\backslash
left[
\backslash
text{'rightchild'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\begin_layout Section
Hash Tables
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[11.1-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 11.1-2}
\end_layout

\end_inset

 A 
\series bold
\emph on
bit vector
\series default
\emph default
 is simply an array of bits (0s and 1s).
 A bit vector of length 
\begin_inset Formula $m$
\end_inset

 takes much less space than an array of 
\begin_inset Formula $m$
\end_inset

 pointers.
 Describe how to use a bit vector to represent a dynamic set of distinct
 elements with no satellite data.
 Dictionary operations should run in 
\begin_inset Formula $O\left(1\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Assign an index to each element.
 Use the bit vector to indicate membership by settings bits by initializing
 all bits to 0 and then setting to 1 when inserting (deletion is reseting
 to 0).
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[11.1-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 11.1-3}
\end_layout

\end_inset

 Suggest how to implement a direct-address table in which the keys of stored
 el- ements do not need to be distinct and the elements can have satellite
 data.
 All three dictionary operations (
\begin_inset Formula $\texttt{INSERT}$
\end_inset

, 
\begin_inset Formula $\texttt{DELETE}$
\end_inset

, and 
\begin_inset Formula $\texttt{SEARCH}$
\end_inset

 ) should run in 
\begin_inset Formula $O\left(1\right)$
\end_inset

 time.
 Don’t forget that 
\begin_inset Formula $\texttt{DELETE}$
\end_inset

 takes as an argument a pointer to an object to be deleted, not a key.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Use chaining.
 For 
\begin_inset Formula $\texttt{DELETE}$
\end_inset

 set the pointer to a 
\begin_inset Formula $\texttt{NULL}$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[11.1-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 11.1-4}
\end_layout

\end_inset

 We wish to implement a dictionary by using direct addressing on a huge
 array.
 At the start, the array entries may contain garbage, and initializing the
 entire array is impractical because of its size.
 Describe a scheme for implementing a direct-address dictionary on a huge
 array.
 Each stored object should use 
\begin_inset Formula $O\left(1\right)$
\end_inset

 space; the operations 
\begin_inset Formula $\texttt{INSERT}$
\end_inset

, 
\begin_inset Formula $\texttt{DELETE}$
\end_inset

, and 
\begin_inset Formula $\texttt{SEARCH}$
\end_inset

 should take 
\begin_inset Formula $O\left(1\right)$
\end_inset

 time each; and initializing the data structure should take 
\begin_inset Formula $O\left(1\right)$
\end_inset

 time.
 Hint: Use an additional array, treated somewhat like a stack whose size
 is the number of keys actually stored in the dictionary, to help determine
 whether a given entry in the huge array is valid or not.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Use the stack to store the actual values.
 Let 
\begin_inset Formula $huge$
\end_inset

 be the array and 
\begin_inset Formula $stack$
\end_inset

 be the stack.
 To insert an element with key 
\begin_inset Formula $x$
\end_inset

 append 
\begin_inset Formula $x$
\end_inset

 to the stack and store in 
\begin_inset Formula $huge\left[x\right]$
\end_inset

 the length of the stack (i.e.
 the index of 
\begin_inset Formula $x$
\end_inset

 in the stack).
 To search for an element 
\begin_inset Formula $y$
\end_inset

 (i.e.
 verify membership) check that 
\begin_inset Formula $huge\left[y\right]\leq\texttt{len}\left(stack\right)$
\end_inset

 and that 
\begin_inset Formula $stack\left[huge\left[y\right]\right]=y$
\end_inset

.
 To delete an element 
\begin_inset Formula $x$
\end_inset

 swap the top of the stack with the element to be deleted and update relevant
 entries in 
\begin_inset Formula $huge$
\end_inset

: 
\begin_inset Formula 
\begin{eqnarray*}
stack\left[huge\left[x\right]\right] & = & stack\left[-1\right]\\
huge\left[stack\left[-1\right]\right] & = & huge\left[x\right]\\
huge\left[x\right] & = & \texttt{None}
\end{eqnarray*}

\end_inset

and pop the stack.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[11.2-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 11.2-5}
\end_layout

\end_inset

 Suppose that we are storing a set of 
\begin_inset Formula $n$
\end_inset

 keys into a hash table of size 
\begin_inset Formula $m$
\end_inset

.
 Show that if the keys are drawn from a universe 
\begin_inset Formula $U$
\end_inset

 with 
\begin_inset Formula $\left|U\right|>nm$
\end_inset

, then 
\begin_inset Formula $U$
\end_inset

 has a subset of size 
\begin_inset Formula $n$
\end_inset

 consisting of keys that all hash to the same slot, so that the worst-case
 searching time for hashing with chaining 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Pigeonhole principle.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[11.2-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 11.2-6}
\end_layout

\end_inset

 Suppose we have stored 
\begin_inset Formula $n$
\end_inset

 keys in a hash table of size 
\begin_inset Formula $m$
\end_inset

, with collisions resolved by chaining, and that we know the length of each
 chain, including the length 
\begin_inset Formula $L$
\end_inset

 of the longest chain.
 Describe a procedure that selects a key uniformly at random from among
 the keys in the hash table and returns it in expected time 
\begin_inset Formula $O\left(L\cdot\left(1+1/\alpha\right)\right)$
\end_inset

, where 
\begin_inset Formula $\alpha=n/m$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 The keyword being randomly (not just any).
 Pick a random bucket, which will have 
\begin_inset Formula $k$
\end_inset

 elements, then pick an index 
\begin_inset Formula $i$
\end_inset

 from 
\begin_inset Formula $i,\dots,L$
\end_inset

.
 Reject if 
\begin_inset Formula $i>k$
\end_inset

 and draw 
\begin_inset Formula $i$
\end_inset

 again.
 This is essentially rejection sampling the array, i.e.
 how to uniformly random pick an element from 
\begin_inset Formula $1,\dots,k$
\end_inset

 if you can only generate random numbers from 1 to 
\begin_inset Formula $L$
\end_inset

.
 The expected number of elements 
\begin_inset Formula $k$
\end_inset

 is equal to the load and so 
\begin_inset Formula 
\[
P\left(i\leq k\right)=\frac{(n/m)}{L}
\]

\end_inset

and hence expected number of times before success is 
\begin_inset Formula 
\[
\frac{1}{\frac{(n/m)}{L}}=\frac{L\cdot m}{n}
\]

\end_inset

(since 
\begin_inset Quotes eld
\end_inset

success
\begin_inset Quotes erd
\end_inset

 is a geometric random variable with probability of success being 
\begin_inset Formula $P\left(i\leq k\right)$
\end_inset

).
 Picking the initial bucket doesn't "cost" anything, hence combined with
 time 
\begin_inset Formula $L$
\end_inset

 to traverse we get
\begin_inset Formula 
\[
O\left(L+L\frac{m}{n}\right)=O\left(L\cdot\left(1+\frac{1}{\alpha}\right)\right)
\]

\end_inset

expected running time.
\end_layout

\begin_layout Section
Binary Search Trees
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[12.1-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 12.1-2}
\end_layout

\end_inset

 What is the difference between the binary-search-tree property and the
 min-heap property? 
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 The min-heap property says parents should be larger than both of its children,
 while the binary-search property says greater than left-child but not right-chi
ld.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[12.1-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 12.1-3}
\end_layout

\end_inset

Give a nonrecursive algorithm that performs an inorder tree walk.
 (Hint: An easy solution uses a stack as an auxiliary data structure.
 A more complicated, but elegant, solution uses no stack but assumes that
 we can test two pointers for equality.)
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Both implementations are annoying as hell (and disagree that the stack-less
 form is the least bit elegent).
 
\end_layout

\begin_layout Standard
For the implementation with the stack the thing to remember is that only
 none-
\begin_inset Formula $\texttt{None}$
\end_inset

 nodes should get pushed to the stack and a pointer should be used to keep
 track of which node we're actually on.
 Also since we're using both the stack and the pointer to keep track of
 things, the loop invariant is that either one (not necessarily both) are
 not 
\begin_inset Formula $\texttt{None}$
\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.2\textwidth},xrightmargin={.2\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

In-Order-Stack$
\backslash
left(T
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$stk = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$crnt = T$
\end_layout

\begin_layout Plain Layout

	while $crnt$ or $
\backslash
text{len}
\backslash
left(stk
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

		if $crnt$:
\end_layout

\begin_layout Plain Layout

			# push the last node that's 
\end_layout

\begin_layout Plain Layout

			# legit
\end_layout

\begin_layout Plain Layout

			$stk
\backslash
text{.append}
\backslash
left(crnt
\backslash
right)$
\end_layout

\begin_layout Plain Layout

			$crnt = crnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		# crnt == None so the last node 
\end_layout

\begin_layout Plain Layout

		# on the stack has no left child
\end_layout

\begin_layout Plain Layout

		else: # len(stk) > 0
\end_layout

\begin_layout Plain Layout

			$p = stk
\backslash
text{.pop}
\backslash
left(
\backslash
right)$
\end_layout

\begin_layout Plain Layout

			print $p
\backslash
text{.val}$
\end_layout

\begin_layout Plain Layout

			$crnt = p
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fof the implementation without the stack you need parent pointers in order
 (get it...) to be able to discover which child you're in.
 Also don't forget the first thing you need to check is if you're coming
 back up from the right child.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.1\textwidth},xrightmargin={.1\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

In-Order-No-Stack$
\backslash
left(T
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$prev = crnt = T$
\end_layout

\begin_layout Plain Layout

	while True:
\end_layout

\begin_layout Plain Layout

		$prev = crnt$
\end_layout

\begin_layout Plain Layout

		if $prev == crnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			# come back up from the
\end_layout

\begin_layout Plain Layout

			# right child
\end_layout

\begin_layout Plain Layout

			if $crnt
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

				$crnt = crnt
\backslash
left[
\backslash
text{'prnt'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			else:
\end_layout

\begin_layout Plain Layout

				break
\end_layout

\begin_layout Plain Layout

		elif $crnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] == 
\backslash
text{None}$ or $prev == crnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			print $crnt
\backslash
text{.val}$
\end_layout

\begin_layout Plain Layout

			if $crnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

				$crnt = crnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			elif $crnt
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

				$crnt = crnt
\backslash
left[
\backslash
text{'prnt'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			else:
\end_layout

\begin_layout Plain Layout

				break
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			$crnt = crnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[12.1-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 12.1-4}
\end_layout

\end_inset

Give recursive algorithms that perform preorder and postorder tree walks
 in 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 time on a tree of 
\begin_inset Formula $n$
\end_inset

 nodes.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Recursive implementations are easy; iterative implementations are hard.
 I'll just comment on how these differ from 
\begin_inset Formula $\texttt{In-Order-Stack}$
\end_inset

 (for stack-less it's obvious): to perform an Pre-Order traversal move the
 print statement into the first branch of the conditional (before reassigning
 
\begin_inset Formula $crnt$
\end_inset

).
 Printing out a Post-Order traversal is actually easy: just use 
\begin_inset Formula $\texttt{DFS}$
\end_inset

 from 10.4-3 and reverse the order.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[12.2-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 12.2-2}
\end_layout

\end_inset

 Write recursive versions of 
\begin_inset Formula $\texttt{TREE-MINIMUM}$
\end_inset

 and 
\begin_inset Formula $\texttt{TREE-MAXIMUM}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 I have no idea why you would insist on a recursive implementation of both
 of these since they're easily implemented iteratively.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.2\textwidth},xrightmargin={.2\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Tree-Min$
\backslash
left(T
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$ptr =T$
\end_layout

\begin_layout Plain Layout

	while $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$ptr = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	return $ptr$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.2\textwidth},xrightmargin={.2\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Tree-Max$
\backslash
left(T
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$ptr =T$
\end_layout

\begin_layout Plain Layout

	while $ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$ptr = ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	return $ptr$
\end_layout

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[12.2-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 12.2-3}
\end_layout

\end_inset

 Write the 
\begin_inset Formula $\texttt{TREE-PREDECESSOR}$
\end_inset

 procedure.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 If a node's left-subtree exists then the node's predecessor is the maximum
 of that subtree.
 If the node's subtree doesn't exist then the node's predecessor is 
\begin_inset Quotes eld
\end_inset

on top
\begin_inset Quotes erd
\end_inset

 of it: it's the 
\begin_inset Quotes eld
\end_inset

lowest
\begin_inset Quotes erd
\end_inset

 ancestor of the node whose right child is also an ancestor of the node.
 Basically go up and cut the first left that you can.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.2\textwidth},xrightmargin={.2\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Predecessor$
\backslash
left(x
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# assume $x$ is a pointer to the node
\end_layout

\begin_layout Plain Layout

	# (which could be found by a search)
\end_layout

\begin_layout Plain Layout

	if $x
\backslash
left['lchild'
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		return Tree-Max$
\backslash
left(x
\backslash
left['lchild'
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ptr = x$
\end_layout

\begin_layout Plain Layout

		$prnt = x
\backslash
left['prnt'
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		# while you haven't cut a left
\end_layout

\begin_layout Plain Layout

		while $ptr$ and $ptr == prnt
\backslash
left['lchild'
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			$ptr = prnt$
\end_layout

\begin_layout Plain Layout

			$prnt = ptr
\backslash
left['prnt'
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		return $prnt$
\end_layout

\end_inset


\end_layout

\end_inset

Just for completeness note that successor is symmetric: either minimum of
 the right-subtree or go up and cut a right.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addtocounter{section}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Augmenting Data Structures
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[14.1-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 14.1-5}
\end_layout

\end_inset

Given an element 
\begin_inset Formula $x$
\end_inset

 in an 
\begin_inset Formula $n$
\end_inset

-node order-statistic tree and a natural number 
\begin_inset Formula $i$
\end_inset

, how can we determine the 
\begin_inset Formula $i$
\end_inset

th successor of 
\begin_inset Formula $x$
\end_inset

 in the linear order of the tree in 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 time?
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Find the rank 
\begin_inset Formula $r$
\end_inset

 of 
\begin_inset Formula $x$
\end_inset

, and then find the element whose rank is 
\begin_inset Formula $r+i$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[14.1-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 14.1-7}
\end_layout

\end_inset

Show how to use an order-statistic tree to count the number of inversions
 (see Problem 2-4) in an array of size 
\begin_inset Formula $n$
\end_inset

 in time 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Recall that how 
\begin_inset Quotes eld
\end_inset

far
\begin_inset Quotes erd
\end_inset

 an element is ahead of its rank (in the array) is how many inversions there
 are that include that element.
 If an element is 
\begin_inset Quotes eld
\end_inset

behind
\begin_inset Quotes erd
\end_inset

 its rank then it will appear as an inversion for other elements.
 So find an element's rank and how much its position differs from its rank.
 If it differes by a negative amount then don't count it.
 Otherwise it's 
\begin_inset Formula $i-r(i)$
\end_inset

, where 
\begin_inset Formula $i$
\end_inset

 is the index of the element and 
\begin_inset Formula $r(i)$
\end_inset

 is its rank.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[14.1-8]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 14.1-8}
\end_layout

\end_inset

Consider 
\begin_inset Formula $n$
\end_inset

 chords on a circle, each defined by its endpoints.
 Describe an 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

-time algorithm to determine the number of pairs of chords that intersect
 inside the circle.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Go around the circle counter-clockwise.
 every time you reach an endpoint "label" it and push it to an array.
 Also label it's polar opposite something else (in order to distinguish
 the line as already being encountered).
 When you run out of unlabeled points go around counter-clockwise, starting
 from the same point as where you started prior, but now push only the endpoints
 that have been labeled opposites to a different array.
 Now treat one array as the correct order and the other one as having inversions
 (count the number of inversions using the algorithm in 14.1-7).
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[14.3-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 14.3-3}
\end_layout

\end_inset

Describe an efficient algorithm that, given an interval 
\begin_inset Formula $i$
\end_inset

, returns an interval overlapping 
\begin_inset Formula $i$
\end_inset

 that has the minimum low endpoint, or 
\begin_inset Formula $\texttt{None}$
\end_inset

 if no such interval exists.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Given 
\begin_inset Formula $\texttt{Interval-Search}$
\end_inset

 we can find if there's any overlapping interval, then repeatedly 
\begin_inset Formula $\texttt{Interval-Search}$
\end_inset

 in the left-subtree.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[14.3-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 14.3-4}
\end_layout

\end_inset

Given an interval tree 
\begin_inset Formula $T$
\end_inset

 and an interval 
\begin_inset Formula $i$
\end_inset

, describe how to list all intervals in 
\begin_inset Formula $T$
\end_inset

 that overlap i in 
\begin_inset Formula $O\left(\min\left\{ n,k\lg n\right\} \right)$
\end_inset

-time, where 
\begin_inset Formula $k$
\end_inset

 is the number of intervals in the output list.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Use a depth-first search while check the same condition that 
\begin_inset Formula $\texttt{Interval-Search}$
\end_inset

 checks, i.e.
 that 
\begin_inset Formula $x.left.max\geq i.low$
\end_inset

 (and only exploring the left child is this is the case).
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[14.3-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 14.3-6}
\end_layout

\end_inset

Show how to maintain a dynamic set 
\begin_inset Formula $Q$
\end_inset

 of numbers that supports the operation 
\begin_inset Formula $\texttt{MIN-GAP}$
\end_inset

 , which gives the magnitude of the difference of the two closest numbers
 in 
\begin_inset Formula $Q$
\end_inset

.
 Make the operations 
\begin_inset Formula $\texttt{INSERT}$
\end_inset

, 
\begin_inset Formula $\texttt{DELETE}$
\end_inset

, 
\begin_inset Formula $\texttt{SEARCH}$
\end_inset

, and 
\begin_inset Formula $\texttt{MIN-GAP}$
\end_inset

 as efficient as possible, and analyze their running times.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 When you insert into a binary search tree you can keep track of predecessor
 and successor at no extra cost: the predecessor is the last right to left
 turn you made during insertion and the successor is the last left to right
 turn you made during insertion.
 The narrowest gap between an element and any other element is the minimum
 of the gap between elements and their predecessor or successor.
 So you can insert into a binary search tree and keep track of all the minimum
 gaps (between each element and either its predecessor or successor).
 Deletion simply recomputes the predecessor and successor of affected elements.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[14.3-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 14.3-7}
\end_layout

\end_inset

VLSI databases commonly represent an integrated circuit as a list of rectangles.
 Assume that each rectangle is rectilinearly oriented (sides parallel to
 the 
\begin_inset Formula $x$
\end_inset

- and 
\begin_inset Formula $y$
\end_inset

-axes), so that we represent a rectangle by its minimum and maximum 
\begin_inset Formula $x$
\end_inset

- and 
\begin_inset Formula $y$
\end_inset

-coordinates.
 Give an 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

-time algorithm to decide whether or not a set of 
\begin_inset Formula $n$
\end_inset

 rectangles so represented contains two rectangles that overlap.
 Your algorithm need not report all intersecting pairs, but it must report
 that an overlap exists if one rectangle entirely covers another, even if
 the boundary lines do not intersect.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Use an Interval Tree and sweep a line in both directions adding and removing
 intervals as they appear.
 On adding each interval check if there's a collision using 
\begin_inset Formula $\texttt{Interval-Search}$
\end_inset

.
\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[14-1]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 14-1}
\end_layout

\end_inset

 Point of maximum overlap.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Show that there will always be a point of maximum overlap that is an endpoint
 of one of the segments.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Skip.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Design a data structure that efficiently supports the operations 
\begin_inset Formula $\texttt{INTERVAL-INSERT}$
\end_inset

 , 
\begin_inset Formula $\texttt{INTERVAL-DELETE}$
\end_inset

 , and 
\begin_inset Formula $\texttt{FIND-POM}$
\end_inset

, which returns a point of maximum overlap.
 (Hint: Keep a red-black tree of all the endpoints.
 Associate a value of +1 with each left endpoint, and associate a value
 of -1 with each right endpoint.
 Augment each node of the tree with some extra information to maintain the
 point of maximum overlap.)
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Keep track of the sum of negatives and positives on the left side of a
 node and the right side of a node.
 A surplus of negatives means the endpoint corresponding to the node you're
 at is inside that many intervals (on the left).
 A surplus of positives on the right means the same thing.
 Keep a pointer to the current maximum overlap by simply checking against
 the current maximum stored somewhere every time a new interval is inserted
 (can't figure out how to compute it from the tree without traversing entire
 tree).
 It should be simple to update augmentations during insertion and deletion.
\end_layout

\end_deeper
\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[14-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 14-2}
\end_layout

\end_inset

 Josephus permutation.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Suppose that 
\begin_inset Formula $m$
\end_inset

 is a constant.
 Describe an 
\begin_inset Formula $O\left(n\right)$
\end_inset

-time algorithm that, given an integer 
\begin_inset Formula $n$
\end_inset

, outputs the 
\begin_inset Formula $\left(n,m\right)$
\end_inset

-Josephus permutation.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Use a circularly linked-list and just delete notes while skipping forward
 m times.
 Running time is 
\begin_inset Formula $O\left(mn\right)$
\end_inset

 but 
\begin_inset Formula $m$
\end_inset

 is a constant so 
\begin_inset Formula $O\left(m\right)$
\end_inset

.
 Alternatively use the recurrence relation 
\begin_inset Formula 
\[
Josephus\left(n,k\right)=\left[\left(Josephus\left(n-1,k\right)+k-1\right)\mod n\right]+1
\]

\end_inset

The reasoning here is that once the first element of 
\begin_inset Formula $n$
\end_inset

 elements is deleted there are 
\begin_inset Formula $n-1$
\end_inset

 elements remaining and we need the last survivor of those 
\begin_inset Formula $n-1$
\end_inset

 elements.
 The 
\begin_inset Formula $k-1$
\end_inset

 is because we need to count from where the first element is deleted, i.e.
 the 
\begin_inset Formula $\left(k-1\right)$
\end_inset

th position.
 The 
\begin_inset Formula $\mod n$
\end_inset

 is to wrap around and +1 is shifting to 1 counting because using mod makes
 it as if we're counting from 0.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Suppose that 
\begin_inset Formula $m$
\end_inset

 is not a constant.
 Describe an 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

-time algorithm that, given integers 
\begin_inset Formula $n$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

, outputs the 
\begin_inset Formula $\left(n,m\right)$
\end_inset

-Josephus permutation.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Use an order statistic tree and delete the 
\begin_inset Formula $k$
\end_inset

th ranked element, then delete the 
\begin_inset Formula $\left[\left(2k\right)\mod n\right]+1$
\end_inset

 ranked element, and so on.
\end_layout

\end_deeper
\end_deeper
\begin_layout Part
Advanced Design and Analysis Techniques
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addtocounter{section}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Greedy Algorithms
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.1-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.1-4}
\end_layout

\end_inset

Suppose that we have a set of activities to schedule among a large number
 of lecture halls, where any activity can take place in any lecture hall.
 We wish to schedule all the activities using as few lecture halls as possible.
 Give an efficient greedy algorithm to determine which activity should use
 which lecture hall.
 
\end_layout

\begin_layout Exercise*
(This problem is also known as the 
\series bold
interval-graph coloring problem
\series default
.
 We can create an interval graph whose vertices are the given activities
 and whose edges connect incompatible activities.
 The smallest number of colors required to color every vertex so that no
 two adjacent vertices have the same color corresponds to finding the fewest
 lecture halls needed to schedule all of the given activities.)
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Sort by start time and then allocate to the first available lecture hall.
 If no lecture hall is available then open a new one.
 What does this have to do with graph coloring?
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.1-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.1-5}
\end_layout

\end_inset

Consider a modification to the activity-selection problem in which each
 activity 
\begin_inset Formula $a_{i}$
\end_inset

 has, in addition to a start and finish time, a value 
\begin_inset Formula $v_{i}$
\end_inset

 .
 The objective is no longer to maximize the number of activities scheduled,
 but instead to maximize the total value of the activities scheduled.
 That is, we wish to choose a set 
\begin_inset Formula $A$
\end_inset

 of compatible activities such that 
\begin_inset Formula $\sum_{a_{k}\in A}v_{k}$
\end_inset

 is maximized.
 Give a polynomial-time algorithm for this problem.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Pick that acitivites that are max over value of compatible jobs.
 This problem has the same Bellman equation as for resource allocation.
 Either the next job contributes to an optimal solution or it doesn't.
 If it does then the sub problem is the maximum value job allocation strategy
 over jobs compatible with it.
 If it doesn't the just use prior value.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.2-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.2-2}
\end_layout

\end_inset

Give a dynamic-programming solution to the 0-1 knapsack problem that runs
 in 
\begin_inset Formula $O\left(nW\right)$
\end_inset

 time, where 
\begin_inset Formula $n$
\end_inset

 is the number of items and 
\begin_inset Formula $W$
\end_inset

 is the maximum weight of items that the thief can put in his knapsack.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 The Bellman equation is 
\begin_inset Formula 
\[
k\left(w,j\right)=\max\left\{ k\left(w-w_{j},j-1\right)+v_{j},k\left(w,j-1\right)\right\} 
\]

\end_inset

i.e.
 consider a subset 
\begin_inset Formula $1,\dots,j$
\end_inset

 of the 
\begin_inset Formula $n$
\end_inset

 items and either inclue the 
\begin_inset Formula $j$
\end_inset

th item or not.
 If you include then the value of the knapsack is the value of the optimal
 knapsack lighter by 
\begin_inset Formula $w_{j}$
\end_inset

 plus the value of the 
\begin_inset Formula $j$
\end_inset

th item 
\begin_inset Formula $v_{j}$
\end_inset

.
 If you don't include it then the value of the knapsack is just the value
 of the knapsack of weight 
\begin_inset Formula $w$
\end_inset

 but comprised of only a subset of the items 
\begin_inset Formula $1,\dots,j-1$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.2-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.2-3}
\end_layout

\end_inset

Suppose that in a 0-1 knapsack problem, the order of the items when sorted
 by increasing weight is the same as their order when sorted by decreasing
 value.
 Give an efficient algorithm to find an optimal solution to this variant
 of the knapsack problem, and argue that your algorithm is correct.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Take the lightest items of course.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.2-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.2-4}
\end_layout

\end_inset

Professor Gekko has always dreamed of inline skating across North Dakota.
 He plans to cross the state on highway U.S.
 2, which runs from Grand Forks, on the eastern border with Minnesota, to
 Williston, near the western border with Montana.
 The professor can carry two liters of water, and he can skate 
\begin_inset Formula $m$
\end_inset

 miles before running out of water.
 (Because North Dakota is relatively flat, the professor does not have to
 worry about drinking water at a greater rate on uphill sections than on
 flat or downhill sections.) The professor will start in Grand Forks with
 two full liters of water.
 His official North Dakota state map shows all the places along U.S.
 2 at which he can refill his water and the distances between these locations.
 The professor’s goal is to minimize the number of water stops along his
 route across the state.
 Give an efficient method by which he can determine which water stops he
 should make.
 Prove that your strategy yields an optimal solution, and give its running
 time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Go to the last stop before 
\begin_inset Formula $m$
\end_inset

 miles, refill, repeat.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.2-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.2-5}
\end_layout

\end_inset

Describe an efficient algorithm that, given a set 
\begin_inset Formula $\left\{ x_{1},\dots,x_{n}\right\} $
\end_inset

 of points on the real line, determines the smallest set of unit-length
 closed intervals that contains all of the given points.
 Argue that your algorithm is correct.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Sort the points.
 Use the first point as the left endpoint of the first unit-length interval.
 For the next point ask the question: is it covered? If not repeat.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.2-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.2-6}
\end_layout

\end_inset

Show how to solve the fractional knapsack problem in 
\begin_inset Formula $O\left(n\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Take items according to value density: value/weight.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.2-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.2-7}
\end_layout

\end_inset

Suppose you are given two sets 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, each containing 
\begin_inset Formula $n$
\end_inset

 positive integers.
 You can choose to reorder each set however you like.
 After reordering, let 
\begin_inset Formula $a_{i}$
\end_inset

 be the 
\begin_inset Formula $i$
\end_inset

th element of set 
\begin_inset Formula $A$
\end_inset

, and let 
\begin_inset Formula $b_{i}$
\end_inset

 be the 
\begin_inset Formula $i$
\end_inset

th element of set 
\begin_inset Formula $B$
\end_inset

.
 You then receive a payoff of 
\begin_inset Formula $\prod_{i=1}^{n}a_{i}^{b_{i}}$
\end_inset

 .
 Give an algorithm that will maximize your payoff.
 Prove that your algorithm maximizes the payoff, and state its running time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Pair the largest number in 
\begin_inset Formula $A$
\end_inset

 with the largest numbers in 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.3-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.3-3}
\end_layout

\end_inset

What is an optimal Huffman code for the following set of frequencies, based
 on the first 8 Fibonacci numbers?
\begin_inset Formula 
\[
\texttt{a:1},\texttt{b:1},\texttt{c:2},\texttt{d:3},\texttt{e:5},\texttt{f:8},\texttt{g:13},\texttt{h:21}
\]

\end_inset

Can you generalize your answer to find the optimal code when the frequencies
 are the first 
\begin_inset Formula $n$
\end_inset

 Fibonacci numbers?
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Because of the recurrence relation the the Huffman tree skews to the right.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.3-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.3-3}
\end_layout

\end_inset

Suppose we have an optimal prefix code on a set 
\begin_inset Formula $C=\left\{ 1,\dots,n-1\right\} $
\end_inset

 of characters and we wish to transmit this code using as few bits as possible.
 Show how to represent any optimal prefix code on 
\begin_inset Formula $C$
\end_inset

 using only 
\begin_inset Formula $2n-1+n\left\lceil \lg n\right\rceil $
\end_inset

 bits.
 (Hint: Use 
\begin_inset Formula $2n-11$
\end_inset

 bits to specify the structure of the tree, as discovered by a walk of the
 tree.)
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 A full binary tree is uniquely defined by its preorder traversal.
 Then represent each of the numbers using 
\begin_inset Formula $\lg n$
\end_inset

 bits in the order they're seen by the preorder traversal.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16.3-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.3-3}
\end_layout

\end_inset

Generalize Huffman’s algorithm to ternary codewords (i.e., codewords using
 the symbols 0, 1, and 2), and prove that it yields optimal ternary codes.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Just create tri-valent nodes and then pop 3 at a time from the priority-queue.
\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16-1]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 14-1}
\end_layout

\end_inset

 Coin changing.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Describe a greedy algorithm to make change consisting of quarters, dimes,
 nickels, and pennies.
 Prove that your algorithm yields an optimal solution.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Exchange for as many of the decreasingly smaller denomination as possible.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Suppose that the available coins are in the denominations that are powers
 of 
\begin_inset Formula $c$
\end_inset

, i.e., the denominations are 
\begin_inset Formula $c^{0},c^{1},\dots,c^{k}$
\end_inset

 for some integers 
\begin_inset Formula $c>1$
\end_inset

 and 
\begin_inset Formula $k\geq1$
\end_inset

.
 Show that the greedy algorithm always yields an optimal solution.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 This is just base 
\begin_inset Formula $c$
\end_inset

 representation of the amount of money (and hence obviously optimal).
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Give a set of coin denominations for which the greedy algorithm does not
 yield an optimal solution.
 Your set should include a penny so that there is a solution for every value
 of 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 
\begin_inset Formula $\left(4,3,1\right)$
\end_inset

 fails on 
\begin_inset Formula $6$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(d)]
\end_layout

\end_inset

Give an 
\begin_inset Formula $O\left(nk\right)$
\end_inset

-time algorithm that makes change for any set of 
\begin_inset Formula $k$
\end_inset

 different coin denominations, assuming that one of the coins is a penny.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Suppose the coins come sorted in decreasing order so 
\begin_inset Formula $c_{1}>c_{2}>\cdots>c_{k}=1$
\end_inset

.
 Let 
\begin_inset Formula $C\left(i,j\right)$
\end_inset

 be the optimal number of coins used to make change for 
\begin_inset Formula $i\cent$
\end_inset

 using only coins 
\begin_inset Formula $j,\dots,k$
\end_inset

.
 We either use coin 
\begin_inset Formula $c_{j}$
\end_inset

 or we don't.
 If we do not then we're solving the problem 
\begin_inset Formula $C\left(i,j+1\right)$
\end_inset

.
 For example we might not use coin 
\begin_inset Formula $c_{j}$
\end_inset

 if 
\begin_inset Formula $c_{j}>i$
\end_inset

.
 If we do use coin 
\begin_inset Formula $c_{j}$
\end_inset

 then the rest 
\begin_inset Formula $\left(i-c_{j}\right)\cent$
\end_inset

 needs to be changed, potentially using the coin 
\begin_inset Formula $j$
\end_inset

 again.
 
\begin_inset Formula 
\[
C\left(i,j\right)=\begin{cases}
C\left(i,j+1\right) & \text{if }c_{j}>i\\
\min\left\{ C\left(i,j+1\right),C\left(i-c_{j},j\right)+1\right\}  & \text{if }c_{j}\leq i
\end{cases}
\]

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[16-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 16-2}
\end_layout

\end_inset

 Suppose you are given a set 
\begin_inset Formula $S=\left\{ a_{1},\dots,a_{n}\right\} $
\end_inset

 of tasks, where task 
\begin_inset Formula $a_{i}$
\end_inset

 requires 
\begin_inset Formula $p_{i}$
\end_inset

 units of processing time to complete, once it has started.
 You have one computer on which to run these tasks, and the computer can
 run only one task at a time.
 Let 
\begin_inset Formula $c_{i}$
\end_inset

 be the completion time of task 
\begin_inset Formula $a_{i}$
\end_inset

 , that is, the time at which task 
\begin_inset Formula $a_{i}$
\end_inset

 completes processing.
 Your goal is to minimize the average completion time, that is, to minimize
 
\begin_inset Formula $\left(1/n\right)\sum_{i=1}^{n}c_{i}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Give an algorithm that schedules the tasks so as to minimize the average
 completion time.
 Each task must run non-preemptively, that is, once task 
\begin_inset Formula $a_{i}$
\end_inset

 starts, it must run continuously for 
\begin_inset Formula $p_{i}$
\end_inset

 units of time.
 Prove that your algorithm minimizes the average completion time, and state
 the running time of your algorithm.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Schedule them in order of shortest running time.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Suppose now that the tasks are not all available at once.
 That is, each task cannot start until its release time 
\begin_inset Formula $r_{i}$
\end_inset

 .
 Suppose also that we allow preemption, so that a task can be suspended
 and restarted at a later time.
 Give an algorithm that schedules the tasks so as to minimize the average
 completion time in this new scenario.
 Prove that your algorithm minimizes the average completion time, and state
 the running time of your algorithm.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 At every release it's like you've got some number of jobs competing (where
 the job running currently counts as a job that has some amount of time
 left, and similarly all the other paused jobs).
 Just run the one that ends soonest and reassess every release time.
 You can use a min-heap.
 Each job could be pushed and popped a total of 
\begin_inset Formula $k$
\end_inset

 times, where 
\begin_inset Formula $k$
\end_inset

 is the number of distinct release times so total running time is 
\begin_inset Formula $O\left(k^{2}\log n\right)$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Part
Advanced Data Structures
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addtocounter{section}{4}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Data Structures for Disjoint Sets
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[21.1-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 21.1-3}
\end_layout

\end_inset

During the execution of 
\begin_inset Formula $\texttt{CONNECTED-COMPONENTS}$
\end_inset

 on an undirected graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 with 
\begin_inset Formula $k$
\end_inset

 connected components, how many times is 
\begin_inset Formula $\texttt{FIND-SET}$
\end_inset

 called? How many times is 
\begin_inset Formula $\texttt{UNION}$
\end_inset

 called? Express your answers in terms of 
\begin_inset Formula $\left|V\right|,\left|E\right|,k$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Worst case both linear (the rub is that 
\begin_inset Formula $\texttt{FIND-SET}$
\end_inset

 is linear time too without path compression), and union is bad too.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[21.1-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 16.1-5}
\end_layout

\end_inset

Suppose that we wish to add the operation 
\begin_inset Formula $\texttt{PRINT-SET}\left(x\right)$
\end_inset

, which is given a node 
\begin_inset Formula $x$
\end_inset

 and prints all the members of 
\begin_inset Formula $x$
\end_inset

’s set, in any order.
 Show how we can add just a single attribute to each node in a disjoint-set
 forest so that 
\begin_inset Formula $\texttt{PRINT-SET}$
\end_inset


\begin_inset Formula $\left(x\right)$
\end_inset

 takes time linear in the number of members of 
\begin_inset Formula $x$
\end_inset

’s set and the asymptotic running times of the other operations are unchanged.
 Assume that we can print each member of the set in 
\begin_inset Formula $O\left(1\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Connect all the nodes up like a linked list.
 Representative node points to first child.
 Then when joining the other set is "spliced in": call the pointer 
\begin_inset Formula $next$
\end_inset

.
 When splicing in the next disjoint set take 
\begin_inset Formula $next$
\end_inset

 of the joined-to set and point it at the 
\begin_inset Formula $next$
\end_inset

 of the representative of the joined in set, then put the 
\begin_inset Formula $next$
\end_inset

 of the joined-in set to point to the original 
\begin_inset Formula $next$
\end_inset

 of the joined-to set.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[21-1]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 21-1}
\end_layout

\end_inset

 Off-line minimum.
\end_layout

\begin_layout Problem*
We want to determine the 
\begin_inset Formula $m$
\end_inset

th minimum that would be extract from a set of numbers with maximum 
\begin_inset Formula $n$
\end_inset

, given a particular set of insertion.
 Partition the sequence of actions into 
\begin_inset Formula $I_{j}$
\end_inset

 and 
\begin_inset Formula $E_{m}$
\end_inset

, where 
\begin_inset Formula $I_{j}$
\end_inset

 is all of the insertions between extractions 
\begin_inset Formula $E_{j-1}$
\end_inset

 and 
\begin_inset Formula $E_{j}$
\end_inset

.
 
\begin_inset Formula $I_{j}$
\end_inset

 might be empty (consecutive extractions).
 For each 
\begin_inset Formula $I_{j}$
\end_inset

 insert corresponding keys into a set 
\begin_inset Formula $K_{j}$
\end_inset

.
 Then the algorithm is
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.2\textwidth},xrightmargin={.2\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Offline-Min$
\backslash
left(m,n
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	for $i=1:n$:
\end_layout

\begin_layout Plain Layout

		determine $j$ s.t.
 $i
\backslash
in K_j$
\end_layout

\begin_layout Plain Layout

		if $j 
\backslash
neq m+1$:
\end_layout

\begin_layout Plain Layout

			$extracted
\backslash
left[j
\backslash
right] = i$
\end_layout

\begin_layout Plain Layout

			$
\backslash
ell = 
\backslash
min_{j' > j}
\backslash
left
\backslash
{ K_{j'} 
\backslash
text{ exists} 
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

		$K_
\backslash
ell = K_j 
\backslash
cup K_
\backslash
ell$
\end_layout

\begin_layout Plain Layout

		del $K_j$
\end_layout

\begin_layout Plain Layout

return $extracted$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Argue that the array extracted returned by 
\begin_inset Formula $\texttt{Offline-Min}$
\end_inset

 is correct.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 The algorithm works in a kind of inverted sense.
 Instead of finding the minimum of the set at particular extraction it finds
 the extraction at which a number is the minimum (that's why it counts up
 from 1 to 
\begin_inset Formula $n$
\end_inset

).
 Then in order to keep the sets of inserted numbers in contention (but prevent
 the same sequence 
\begin_inset Quotes eld
\end_inset

moment
\begin_inset Quotes erd
\end_inset

 from being counted twice) it unions the sets with the next possible 
\begin_inset Quotes eld
\end_inset

moment
\begin_inset Quotes erd
\end_inset

.
 Think about what would happen if lines 7,8 weren't executed: the same 
\begin_inset Formula $K_{j}$
\end_inset

 might get contain two consecutive minima (for example for 
\begin_inset Formula $\left\{ 3,4\right\} \subset K_{j}$
\end_inset

) and 
\begin_inset Formula $extracted\left[j\right]$
\end_inset

 would be overwritten.
 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Describe how to implement 
\begin_inset Formula $\texttt{Offline-Min}$
\end_inset

 efficiently with a disjoint- set data structure.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Python code appears in 
\begin_inset Formula $\texttt{disjoint\_forests.py}$
\end_inset

 in the 
\begin_inset Formula $\texttt{code/ch21}$
\end_inset

 directory.
\end_layout

\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[21-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 21-2}
\end_layout

\end_inset

 Depth determination.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Skip.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Skip.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Show how to modify 
\begin_inset Formula $\texttt{FIND-SET}$
\end_inset

 to implement 
\begin_inset Formula $\texttt{FIND-DEPTH}$
\end_inset

.
 Your implementation should perform path compression, and its running time
 should be linear in the length of the find path.
 Make sure that your implementation updates pseudodistances correctly.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Let the pseudo-distance be the distance from each node to its parent.
 Along with path compression update the pseudo-distance of a node to be
 the sum of the pseudo-distances of all of its ancestors'.
 This could be implemented by using the path-compression trick (unwinding
 the stack) but return a tuple that includes the pseudo-distance and using
 it to sum (something like a 
\begin_inset Formula $\texttt{fold}$
\end_inset

).
 For example suppose 
\begin_inset Formula $x.d\left[v_{i}\right]$
\end_inset

 to be the pseudo-distance of node 
\begin_inset Formula $v_{i}$
\end_inset

.
 Then the return value of 
\begin_inset Formula $\texttt{Find-Set}$
\end_inset

 could be modified to be 
\begin_inset Formula $\left(x.p,x.d\left[v_{i}\right]\right)$
\end_inset

 and path-compression line could be modified to be 
\begin_inset Formula 
\begin{eqnarray*}
x.p,d & = & \texttt{Find-Set}\left(x.p\right)\\
x.d\left[v_{i}\right] & = & x.d\left[v_{i}\right]+d
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(d)]
\end_layout

\end_inset

Show how to implement 
\begin_inset Formula $\texttt{Graft}$
\end_inset


\begin_inset Formula $\left(r,v\right)$
\end_inset

, which combines the sets containing 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

, by modifying the 
\begin_inset Formula $\texttt{UNION}$
\end_inset

 and 
\begin_inset Formula $\texttt{LINK}$
\end_inset

 procedures.
 Make sure that your implementation updates pseudodistances correctly.
 Note that the root of a set 
\begin_inset Formula $S_{i}$
\end_inset

 is not necessarily the root of the corresponding tree 
\begin_inset Formula $T_{i}$
\end_inset

 .
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 The only thing to be careful about is how to update the pseudo-distance.
 Let the path from 
\begin_inset Formula $v$
\end_inset

 to the root be 
\begin_inset Formula $\left(v=v_{0}\right),v_{1},v_{2},\dots,\left(v_{k}=w\right)$
\end_inset

, where 
\begin_inset Formula $w$
\end_inset

 is the root.
 If 
\begin_inset Formula $\texttt{rank}\left(r\right)<\texttt{rank}\left(w\right)$
\end_inset

 then 
\begin_inset Formula $\texttt{UNION}$
\end_inset

 
\begin_inset Formula $r$
\end_inset

's set to 
\begin_inset Formula $w$
\end_inset

's set (i.e.
 make 
\begin_inset Formula $r$
\end_inset

's parent pointer point to 
\begin_inset Formula $w$
\end_inset

) and update the pseudo-distance as described in part (c), not forgetting
 to include 
\begin_inset Formula $d\left[v\right]$
\end_inset

.
 If 
\begin_inset Formula $\texttt{rank}\left(r\right)\geq\texttt{rank}\left(w\right)$
\end_inset

 then make 
\begin_inset Formula $w$
\end_inset

's parent pointer point to 
\begin_inset Formula $r$
\end_inset

, and update 
\begin_inset Formula $r$
\end_inset

's pseudo-distance skipping 
\begin_inset Formula $d\left[v\right]$
\end_inset

.
 Furthermore update 
\begin_inset Formula $w$
\end_inset

's pseudo-distance to be 
\begin_inset Formula $d\left[w\right]-d\left[r\right]$
\end_inset

.
 What's happening here? For the purposes of maintaining time bounds we,
 of course, want to union the smaller set to the larger set (so that fewer
 parent pointers end up being updated).
 But then the pseudo-distance becomes wrong for the root (which becomes
 a set-child of 
\begin_inset Formula $r$
\end_inset

's set).
 We compensate by biasing 
\begin_inset Formula $w$
\end_inset

's pseudo-distance (note it becomes negative).
 
\begin_inset Formula $v$
\end_inset

's set doesn't need to be updated since it already has 
\begin_inset Formula $w$
\end_inset

 as its root.
\end_layout

\end_deeper
\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[21-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 21-3}
\end_layout

\end_inset

 Tarjan's Algorithm.
\end_layout

\begin_layout Problem*

\series bold
Solution.
 
\series default
Write up appears in 
\begin_inset Formula $\texttt{tarjanlca.pdf}$
\end_inset

 in the 
\begin_inset Formula $\texttt{code/ch21}$
\end_inset

 directory.
\end_layout

\begin_layout Part
Graph Algorithms
\end_layout

\begin_layout Section
Elementary Graph Algorithms
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.1-1]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.1-1}
\end_layout

\end_inset

Given an adjacency-list representation of a directed graph, how long does
 it take to compute the out-degree of every vertex? How long does it take
 to compute the in-degrees?
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Out-degree is easy.
 Constant time if you for example store the length of the adjacency list.
 In-degree is much harder 
\begin_inset Formula $\left|V\right|^{2}$
\end_inset

 for each vertex, so 
\begin_inset Formula $\left|V\right|^{3}$
\end_inset

.
 To solve the problem I would just construct the adjacency-matrix representation
 first pass (easy: just traverse the adjacency-list and mark entries in
 the matrix).
 Then for each following query it would be just a sum across the 
\series bold

\begin_inset Formula $v$
\end_inset


\series default
th column.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.1-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.1-3}
\end_layout

\end_inset

The transpose of a directed graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is the graph 
\begin_inset Formula $G^{T}=\left(V,E^{T}\right)$
\end_inset

, where 
\begin_inset Formula $E^{T}=\left\{ \left(v,u\right)\in V\times V\big|\left(u,v\right)\in E\right\} $
\end_inset

.
 Thus, 
\begin_inset Formula $G^{T}$
\end_inset

 is 
\begin_inset Formula $G$
\end_inset

 with all its edges reversed.
 Describe efficient algorithms for computing 
\begin_inset Formula $G^{T}$
\end_inset

 from 
\begin_inset Formula $G$
\end_inset

, for both the adjacency-list and adjacency-matrix representations of G.
 Analyze the running times of your algorithms.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 For the adjacency-matrix representation the construction is constant time
 essentially (just traverse the matrix in the 
\begin_inset Quotes eld
\end_inset

opposite
\begin_inset Quotes erd
\end_inset

 direction).
 For the adjacency-list representation you could create a hash-table of
 vertices then traverse all of the adjacency-lists and hash on entries (vertices
) then push to linked lists of those vertices the owener of that linked-list.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.1-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.1-3}
\end_layout

\end_inset

Given an adjacency-list representation of a multigraph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, describe an 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

-time algorithm to compute the adjacency-list representation of the “equivalent”
 undirected graph 
\begin_inset Formula $G'=\left(V,E'\right)$
\end_inset

, where 
\begin_inset Formula $E'$
\end_inset

 consists of the edges in 
\begin_inset Formula $E$
\end_inset

 with all multiple edges between two vertices replaced by a single edge
 and with all self-loops removed.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Hash on
\begin_inset Formula $\left(u,v\right)$
\end_inset

.
 If there's a collision then don't insert in the new adjacency list.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.1-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.1-5}
\end_layout

\end_inset

The square of a directed graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is the graph 
\begin_inset Formula $G^{2}=\left(V,E^{2}\right)$
\end_inset

 such that 
\begin_inset Formula $\left(u,v\right)\in E^{2}$
\end_inset

 if and only 
\begin_inset Formula $G$
\end_inset

 contains a path with at most two edges between 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
 Describe efficient algorithms for computing 
\begin_inset Formula $G^{2}$
\end_inset

 from 
\begin_inset Formula $G$
\end_inset

 for both the adjacency-list and adjacency-matrix representations of 
\begin_inset Formula $G$
\end_inset

.
 Analyze the running times of your algorithms.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 
\begin_inset Formula $G^{2}$
\end_inset

 for adjacency matrix is just the normed square of the matrix because taking
 the dot product "turns on" connections to the 2 hop nodes.
 For adjacency-list I guess you have to just traverse each list.
 If you treat each adjacency list as a set you can do set union but those
 are still linear (
\begin_inset Formula $n^{2}\equiv O\left(\left|V\right|\left|E\right|\right)$
\end_inset

).
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.1-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.1-6}
\end_layout

\end_inset

Most graph algorithms that take an adjacency-matrix representation as input
 require time 
\begin_inset Formula $\Omega\left(V^{2}\right)$
\end_inset

, but there are some exceptions.
 Show how to determine whether a directed graph 
\begin_inset Formula $G$
\end_inset

 contains a universal sink - a vertex with in-degree 
\begin_inset Formula $\left|V\right|-1$
\end_inset

 and out-degree 0 - in time 
\begin_inset Formula $O\left(V\right)$
\end_inset

, given an adjacency matrix for 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Start at top left of the adjacency-matrix.
 Go right until you hit a 1.
 If you never hit one then there's no universal sink since that vertex is
 disconnected from all other vertices.
 When you hit a one continue down until you hit a zero, then turn right
 and search for a 1 again.
 If you reach the bottom row then the column where you hit the bottom is
 the only universal sink candidate.
 Why only? Because if there were another vertex with all 1s in its columns
 it would have two ones in its row).
 All that remains is to check that entire column for 1s.
 If you hit the right wall then there's no universal sink.
 There are two edge cases: if you hit the right wall on the first row the
 first vertex might be a universal sink.
 Finally you also need to check that the row of the universal sink vertex
 has only one 1 (otherwise there might be two "universal sinks").
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.1-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.1-6}
\end_layout

\end_inset

The incidence matrix of a directed graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 with no self-loops is a 
\begin_inset Formula $\left|V\right|\times\left|E\right|$
\end_inset

 matrix 
\begin_inset Formula $B$
\end_inset

 such that 
\begin_inset Formula 
\[
b_{ij}=\begin{cases}
-1 & \text{if edge \ensuremath{j} leaves vertex \ensuremath{i}}\\
1 & \text{if edge \ensuremath{j} enters vertex \ensuremath{i}}\\
0 & \text{otherwise}
\end{cases}
\]

\end_inset

Describe what the entries of 
\begin_inset Formula $BB^{T}$
\end_inset

 represent.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 The only non-zero entries are on the diagonal and they're the total degree
 (in degree - out degree).
 Nope that's wrong wrong.
 Off diagonal entries exist, because nodes connected to each other have
 opposite sign entries in 
\begin_inset Formula $b_{ij}$
\end_inset

.
 So off diagonal entries is number of edges connecting vertex 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.2-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.2-3}
\end_layout

\end_inset

Show that using a single bit to store each vertex color suffices by arguing
 that the 
\begin_inset Formula $\texttt{BFS}$
\end_inset

 procedure would produce the same result if lines 5 and 14 were removed.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 This works if you simply only push vertices that haven't been visited to
 the queue.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.2-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.2-7}
\end_layout

\end_inset

There are two types of professional wrestlers: “babyfaces” (“good guys”)
 and “heels” (“bad guys”).
 Between any pair of professional wrestlers, there may or may not be a rivalry.
 Suppose we have 
\begin_inset Formula $n$
\end_inset

 professional wrestlers and we have a list of 
\begin_inset Formula $r$
\end_inset

 pairs of wrestlers for which there are rivalries.
 Give an 
\begin_inset Formula $O\left(n+r\right)$
\end_inset

-time algorithm that determines whether it is possible to designate some
 of the wrestlers as babyfaces and the remainder as heels such that each
 rivalry is between a babyface and a heel.
 If it is possible to perform such a designation, your algorithm should
 produce it.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 2 color the graph: set the vertices in each round of the BFS to be the
 opposite color of the parent.
 If node is already colored same color then no such coloring is possible.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.2-8]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.2-8}
\end_layout

\end_inset

The 
\series bold
diameter
\series default
 of a tree 
\begin_inset Formula $T=\left(V,E\right)$
\end_inset

 is defined as 
\begin_inset Formula $\max_{u,v\in V}\delta\left(u,v\right)$
\end_inset

, that is, the largest of all shortest-path distances in the tree.
 Give an efficient algorithm to compute the diameter of a tree, and analyze
 the running time of your algorithm.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Start at any node and do a BFS.
 Pick the node 
\begin_inset Formula $u$
\end_inset

 that's the farthest, then do another BFS from that node picking the node
 
\begin_inset Formula $v$
\end_inset

 that's the farthest from 
\begin_inset Formula $u$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.2-9]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.2-9}
\end_layout

\end_inset

Let 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 be a connected, undirected graph.
 Give an 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

-time algorithm to compute a path in G that traverses each edge in 
\begin_inset Formula $E$
\end_inset

 exactly once in each direction.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Use the same walk as in tarjan's algorithm:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,numbers=left,basicstyle={\ttfamily},showstringspaces=false,tabsize=3,mathescape=true,frame=single,xleftmargin={.2\textwidth},xrightmargin={.2\textwidth}"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Walk$
\backslash
left(u
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	print $u$
\end_layout

\begin_layout Plain Layout

	for $v 
\backslash
in u
\backslash
left[
\backslash
text{'children'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		Walk$
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		print $u$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.3-13]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.3-13}
\end_layout

\end_inset

A directed graph is 
\series bold
singly connected
\series default
 if 
\begin_inset Formula $u\rightsquigarrow v$
\end_inset

 implies that 
\begin_inset Formula $G$
\end_inset

 contains at most one simple path from 
\begin_inset Formula $u$
\end_inset

 to 
\begin_inset Formula $v$
\end_inset

 for all vertices 
\begin_inset Formula $u,v\in V$
\end_inset

 .
 Give an efficient algorithm to determine whether or not a directed graph
 is singly connected.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Run DFS from each vertex.
 If you discover any back edges then there's a cycle and therefore two paths.
 Running time is 
\begin_inset Formula $O\left(VE\right)$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.4-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.4-2}
\end_layout

\end_inset

Give a linear-time algorithm that takes as input a directed acyclic graph
 and two vertices 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $t$
\end_inset

, and returns the number of simple paths from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Dynamic programming.
 The number of paths from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $t$
\end_inset

 is the number of paths from 
\begin_inset Formula $s$
\end_inset

 to each of 
\begin_inset Formula $t$
\end_inset

's parents, summed across the parents, and on.
 Do a topological sort first in order to figure out which vertices are potential
ly 
\begin_inset Formula $t$
\end_inset

's parents.
 The number of paths from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s$
\end_inset

 is 0.
 The number of paths from 
\begin_inset Formula $s$
\end_inset

 to the next vertex in the topological sort is 1 if there's an edge from
 
\begin_inset Formula $s$
\end_inset

 to that vertex, etc.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.4-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.4-3}
\end_layout

\end_inset

Give a linear-time algorithm that takes as input a directed acyclic graph
 and two vertices 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $t$
\end_inset

, and returns the number of simple paths from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Do a DFS search but quit as soon as you hit a back edge.
 If there's a cycle then there will be greater than 
\begin_inset Formula $\left|V\right|$
\end_inset

 edges and so the DFS will # stop after 
\begin_inset Formula $\left|V\right|$
\end_inset

 edges.
 If there's no cycle then the DFS will stop naturally after 
\begin_inset Formula $\left|V\right|-1$
\end_inset

 edges.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.5-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.5-3}
\end_layout

\end_inset

Professor Bacon claims that the algorithm for strongly connected components
 would be simpler if it used the original (instead of the transpose) graph
 in the second depth-first search and scanned the vertices in order of increasin
g finishing times.
 Does this simpler algorithm always produce correct results?
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Because who says there's no edge out of the first closed vertex to another
 component? 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.5-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.5-5}
\end_layout

\end_inset

Give an 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

-time algorithm to compute the component graph of a directed graph.
 Make sure that there is at most one edge between two vertices in the component
 graph your algorithm produces.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Compute the strongly connected component graph, then add edges as such:
 add edge
\begin_inset Formula $\left(u',v'\right)$
\end_inset

 if 
\begin_inset Formula $u\in C_{u'},v\in C_{v'}$
\end_inset

 and there is an edge 
\begin_inset Formula $\left(u,v\right)\in E$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.5-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.5-6}
\end_layout

\end_inset

Given a directed graph 
\begin_inset Formula $G$
\end_inset

, explain how to create another graph 
\begin_inset Formula $G'=\left(V,E'\right)$
\end_inset

 such that (a) 
\begin_inset Formula $G'$
\end_inset

 has the same strongly connected components as 
\begin_inset Formula $G$
\end_inset

, (b) 
\begin_inset Formula $G'$
\end_inset

 has the same component graph as 
\begin_inset Formula $G$
\end_inset

, and (c) 
\begin_inset Formula $E'$
\end_inset

 is as small as possible.
 Describe a fast algorithm to compute 
\begin_inset Formula $G'$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Compute strongly connected components then use a DFS to explore the connected
 components, and return 
\begin_inset Formula $E'\subset E$
\end_inset

 leaving out edges that aren't in the DFS.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22.5-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.5-7}
\end_layout

\end_inset

A directed graph 
\begin_inset Formula $G$
\end_inset

 is 
\series bold
semiconnected 
\series default
if, for all pairs of vertices 
\begin_inset Formula $u,v\in V$
\end_inset

 , we have 
\begin_inset Formula $u\rightsquigarrow v$
\end_inset

 or 
\begin_inset Formula $v\rightsquigarrow u$
\end_inset

.
 Give an efficient algorithm to determine whether or not 
\begin_inset Formula $G$
\end_inset

 is semiconnected.
 Prove that your algorithm is correct, and analyze its running time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Something something transpose? Run DFS on 
\begin_inset Formula $G$
\end_inset

 then DFS on 
\begin_inset Formula $G'$
\end_inset

.
 If both DFSs return the same list of visited vertices then 
\begin_inset Formula $G$
\end_inset

 is semiconnected.
 I guess you could do that but a better way is apparently to compute the
 SCC graph (which is a dag) then topologically sort the SCC, then check
 if there's an edge between each consecutive pair of vertices 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 (pairs of SCC components) in the topological sort.
 If one is missing then (since topological sort and dag) there will be no
 connections 
\emph on
from
\emph default
 the 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 22-2}
\end_layout

\end_inset

 Articulation points, bridges, and biconnected components.
\end_layout

\begin_layout Problem*
Let 
\begin_inset Formula $G$
\end_inset

 be a connected, undirected graph.
 An 
\series bold
articulation point
\series default
 of 
\begin_inset Formula $G$
\end_inset

 is a vertex whose removal disconnects 
\begin_inset Formula $G$
\end_inset

.
 A 
\series bold
bridge
\series default
 of 
\begin_inset Formula $G$
\end_inset

 is an edge whose removal disconnects 
\begin_inset Formula $G$
\end_inset

.
 A 
\series bold
biconnected component
\series default
 of 
\begin_inset Formula $G$
\end_inset

 is a maximal set of edges such that any two edges in the set lie on a common
 simple cycle.
 We can determine articulation points, bridges, and biconnected components
 using depth-first search.
 Let 
\begin_inset Formula $G_{\pi}=\left(V,E_{\pi}\right)$
\end_inset

 be a depth-first tree of 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Prove that the root of 
\begin_inset Formula $G_{\pi}$
\end_inset

 is an articulation point of 
\begin_inset Formula $G$
\end_inset

 if and only if it has at least two children in 
\begin_inset Formula $G$
\end_inset

 .
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Well obviously if it's an articulation point it has to have at least two
 out edges.
 If it has two children in the DFS tree that means its second child wasn't
 reached by path from its first child (other wise that second child would
 have been someone else's child) and therefore the root is an articulation
 point (because removing it would cut off contact between the first child
 and the second).
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Let 
\begin_inset Formula $v$
\end_inset

 be a 
\emph on
nonroot
\emph default
 vertex of 
\begin_inset Formula $G$
\end_inset

.
 Prove that 
\begin_inset Formula $v$
\end_inset

 is an articulation point of 
\begin_inset Formula $G$
\end_inset

 if and only if 
\begin_inset Formula $v$
\end_inset

 has a child 
\begin_inset Formula $s$
\end_inset

 such that there is no back edge from 
\begin_inset Formula $s$
\end_inset

 or any descendant of 
\begin_inset Formula $s$
\end_inset

 to a proper ancestor of 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 If every child has such a back edge (or a descendent of 
\begin_inset Formula $s$
\end_inset

 has such a back edge) to an ancestor of 
\begin_inset Formula $v$
\end_inset

 then clearly we can reach any child and any descendant by going through
 the ancestor instead of 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Let 
\begin_inset Formula 
\begin{eqnarray*}
v.low & = & \min\begin{cases}
v.d\\
w.d & \left(u,w\right)\text{ is a back edge for some descendant }u\text{ of }v
\end{cases}\\
 & = & \min\begin{cases}
v.d\\
\min_{y:\left(v,y\right)\in E} & y.low\\
w.d & \left(v,w\right)\text{ is a back-edge}
\end{cases}
\end{eqnarray*}

\end_inset

Show how to compute 
\begin_inset Formula $v.low$
\end_inset

 for all vertices 
\begin_inset Formula $v\in V$
\end_inset

 in 
\begin_inset Formula $O\left(E\right)$
\end_inset

 time.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 
\begin_inset Formula $v.low$
\end_inset

 is something like the earliest time a vertex 
\begin_inset Formula $v$
\end_inset

 could've been discovered during some DFS (not necessarily the particular
 DFS we ran).
 For leaves of 
\begin_inset Formula $G_{\pi}$
\end_inset

 there are no descendants so 
\begin_inset Formula $v.low$
\end_inset

 is straightforward (either 
\begin_inset Formula $G_{\pi}$
\end_inset

 contains a backedge 
\begin_inset Formula $\left(v,w\right)$
\end_inset

 or not).
 Note that we include 
\begin_inset Formula $v$
\end_inset

 as a descendant of 
\begin_inset Formula $v$
\end_inset

 in order to consider backedges from 
\begin_inset Formula $v$
\end_inset

 itself.
 For vertices 
\begin_inset Formula $v$
\end_inset

 in the tree, if 
\begin_inset Formula $u$
\end_inset

 is a descendant of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $G_{\pi}$
\end_inset

, we know that 
\begin_inset Formula $u.d>v.d$
\end_inset

.
 Therefore if there's some backedge 
\begin_inset Formula $\left(u,w\right)$
\end_inset

 and 
\begin_inset Formula $w.d<v.d$
\end_inset

 we also have that 
\begin_inset Formula $w.d<u.d$
\end_inset

, and hence we will have set 
\begin_inset Formula $u.low=w.d$
\end_inset

.
 Therefore starting at the leaves of 
\begin_inset Formula $G_{\pi}$
\end_inset

 working up (towards the root) everything will have been computed in time
 to compute 
\begin_inset Formula $v.low$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(d)]
\end_layout

\end_inset

Show how to compute all articulation points in 
\begin_inset Formula $O\left(E\right)$
\end_inset

 time.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 For a vertex 
\begin_inset Formula $v$
\end_inset

 if there is a subtree rooted at a child of 
\begin_inset Formula $v$
\end_inset

 which 
\series bold
does not
\series default
 have a back edge connecting to vertex with a smaller discovery time than
 
\begin_inset Formula $v.d$
\end_inset

, then 
\begin_inset Formula $v$
\end_inset

 is an articulation point.
 I.e., is there a child 
\begin_inset Formula $y$
\end_inset

 of 
\begin_inset Formula $v$
\end_inset

 that cannot reach a vertex visited before 
\begin_inset Formula $v$
\end_inset

? If yes, then removing 
\begin_inset Formula $v$
\end_inset

 will disconnect 
\begin_inset Formula $y$
\end_inset

.
 
\end_layout

\begin_layout Standard
Run a DFS to compute 
\begin_inset Formula $G_{\pi}$
\end_inset

 and compute 
\begin_inset Formula $v.low$
\end_inset

 for all vertices using the algorithm in part (c).
 By part (a) we can test whether the root of the 
\begin_inset Formula $G_{\pi}$
\end_inset

 is an articulation point.
 By part (b), any non-root vertex 
\begin_inset Formula $v$
\end_inset

 is an articulation point iff it has at least one child 
\begin_inset Formula $s$
\end_inset

 such that neither 
\begin_inset Formula $s$
\end_inset

, nor any of its descendants, has a backedge to a proper ancestor of 
\begin_inset Formula $v$
\end_inset

.
 By part (c) this is true iff 
\begin_inset Formula $s.low\geq v.d$
\end_inset

.
 We can check this in time proportional to the number of children of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $G_{\pi}$
\end_inset

, so over all non-root vertices, this takes 
\begin_inset Formula $O\left(V\right)$
\end_inset

 time.
 Thus, the total time to find all the articulation points is 
\begin_inset Formula $O\left(E\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(e)]
\end_layout

\end_inset

Skip.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(f)]
\end_layout

\end_inset

Show how to compute all the bridges of 
\begin_inset Formula $G$
\end_inset

 in 
\begin_inset Formula $O\left(E\right)$
\end_inset

 time.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Use DFS to find simple cycles.
 Any edges on a simple cycle can be removed.
\end_layout

\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[22-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 22-4}
\end_layout

\end_inset

 Reachability.
 
\end_layout

\begin_layout Problem*
Let 
\begin_inset Formula $G$
\end_inset

 be a directed graph in which each vertex 
\begin_inset Formula $u\in V$
\end_inset

 is labeled with a unique integer 
\begin_inset Formula $L\left(u\right)$
\end_inset

 from the set 
\begin_inset Formula $\left\{ 1,\dots,\left|V\right|\right\} $
\end_inset

.
 For each vertex 
\begin_inset Formula $u\in V$
\end_inset

, let 
\begin_inset Formula $R\left(u\right)=\left\{ v\in V\,\big|\,u\rightsquigarrow v\right\} $
\end_inset

 be the set of vertices that are reachable from 
\begin_inset Formula $u$
\end_inset

.
 Define 
\begin_inset Formula $\min\left(u\right)$
\end_inset

 to be the vertex in 
\begin_inset Formula $R\left(u\right)$
\end_inset

 whose label is minimal.
 Give an 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

-time algorithm that computes 
\begin_inset Formula $\min\left(u\right)$
\end_inset

 for all vertices 
\begin_inset Formula $u\in V$
\end_inset

.
\end_layout

\begin_layout Problem*

\series bold
Solution.

\series default
 One solution is to compute the strongly connected components of the graph
 and erase all but the smallest label vertex in each component 
\begin_inset Formula $C$
\end_inset

; let this vertex be denoted 
\begin_inset Formula $w\left(C\right)$
\end_inset

.
 For every edge 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 with 
\begin_inset Formula $u$
\end_inset

 not in 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $C$
\end_inset

 add an edge 
\begin_inset Formula $\left(u,w\right)$
\end_inset

.
 For every edge 
\begin_inset Formula $\left(v,u\right)$
\end_inset

 with 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 not in 
\begin_inset Formula $C$
\end_inset

 add an edge 
\begin_inset Formula $\left(w,u\right)$
\end_inset

 (this process is called contracting 
\begin_inset Formula $C$
\end_inset

 to a single vertex 
\begin_inset Formula $w$
\end_inset

).
 The resulting graph is a DAG.
 This DAG can be computed in 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

 time (since strongly connnected components can be computed in 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

 time).
 So we reduced the problem to the same problem on a DAG.
 Now it is simple: traverse the graph in reverse topological order.
 Initially every vertex has 
\begin_inset Formula $\min\left(u\right)=u$
\end_inset

.
 For every vertex 
\begin_inset Formula $u$
\end_inset

 look at its outgoing edges 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 and update 
\begin_inset Formula 
\[
min\left(u\right)=\min\left\{ min\left(v\right)\big|\left(u,v\right)\right\} 
\]

\end_inset

Since we traverse vertices in reverse topological order all outgoing vertices
 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 of 
\begin_inset Formula $u$
\end_inset

 will have already found their final label 
\begin_inset Formula $min\left(v\right)$
\end_inset

.
\end_layout

\begin_layout Problem*
A simpler way (if you know which vertices have which number) simply set
 all of the vertices with incoming edges into a vertex to have the number
 equal to 
\begin_inset Formula $L$
\end_inset

 of the vertex coming into, in order of increasing 
\begin_inset Formula $L\left(u\right)$
\end_inset

, i.e.
 
\series bold
in order of increasing
\series default
 
\begin_inset Formula $L\left(u\right)$
\end_inset

 compute for each 
\begin_inset Formula $v$
\end_inset

 such that 
\begin_inset Formula $\left(v,u\right)\in E$
\end_inset


\begin_inset Formula 
\[
\min\left(v\right)=\min_{u:\left(v,u\right)\in E}L\left(u\right)
\]

\end_inset


\end_layout

\begin_layout Problem*
In order of increasing 
\begin_inset Formula $L\left(u\right)$
\end_inset

 puts a sort of topological ordering on the computation of minimum, enabling
 a DP algorithm.
 That is, first perform 
\begin_inset Formula $\texttt{BFS}\left(1\right)$
\end_inset

 in 
\begin_inset Formula $G^{T}$
\end_inset

, where 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 is the vertex 
\begin_inset Formula $u$
\end_inset

 with 
\begin_inset Formula $L\left(u\right)=1$
\end_inset

; this will visit all vertices reachable from 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Formula $G^{T}$
\end_inset

 (that is, which can reach 1 in 
\begin_inset Formula $G$
\end_inset

) and set their 
\begin_inset Formula $min\left(u\right)=1$
\end_inset

.
 Then find the next smallest vertex that has not been reached in the previous
 BFS and start BFS from it, and so on.
\end_layout

\begin_layout Section
Minimum Spanning trees
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[23.1-1]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 23.1-1}
\end_layout

\end_inset

Let 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 be a minimum-weight edge in a connected graph 
\begin_inset Formula $G$
\end_inset

.
 Show that 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 belongs to some minimum spanning tree of 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Assume that it doesn't.
 Then for no minimum spanning tree is 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 in 
\begin_inset Formula $E$
\end_inset

.
 So take an arbitrary such tree.
 Adding 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 creates a cycle from which we can remove any edge and preserve connectivity
 of the graph.
 therefore remove any edge other than 
\begin_inset Formula $\left(u,v\right)$
\end_inset

.
 This produces a potentially different minimum spannign tree.
 Contradiction.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[23.1-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 22.1-3}
\end_layout

\end_inset

Show that if an edge 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 is contained in some minimum spanning tree, then it is a light edge crossing
 some cut of the graph.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Remove the edge and you disconnect the graph.
 So it's clearly a safe edge.
 If it weren't light then we would have picked a lighter edge to be in the
 minimum spanning tree and the original one wouldn't have been a minimum
 spanning tree.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[23.1-11]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 23.1-11}
\end_layout

\end_inset

Given a graph 
\begin_inset Formula $G$
\end_inset

 and a minimum spanning tree 
\begin_inset Formula $T$
\end_inset

 , suppose that we decrease the weight of one of the edges not in 
\begin_inset Formula $T$
\end_inset

.
 Give an algorithm for finding the minimum spanning tree in the modified
 graph.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Add the edge to create a cycle then DFS to find the edge on that cycle
 of highest weight.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[23.2-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 23.2-2}
\end_layout

\end_inset

Suppose that we represent the graph 
\begin_inset Formula $G$
\end_inset

 as an adjacency matrix.
 Give a simple implementation of Prim’s algorithm for this case that runs
 in 
\begin_inset Formula $O\left(V^{2}\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Just keep finding the minimum weight edge.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[23.2-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 23.2-4}
\end_layout

\end_inset

Suppose that all edge weights in a graph are integers in the range from
 1 to 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 How fast can you make Kruskal’s algorithm run? What if the edge weights
 are integers in the range from 1 to 
\begin_inset Formula $W$
\end_inset

 for some constant 
\begin_inset Formula $W$
\end_inset

?
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Use radix sort to sort edges by weight.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[23.2-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 23.2-5}
\end_layout

\end_inset

Suppose that all edge weights in a graph are integers in the range from
 1 to 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 How fast can you make Prim’s algorithm run? What if the edge weights are
 integers in the range from 1 to 
\begin_inset Formula $W$
\end_inset

 for some constant 
\begin_inset Formula $W$
\end_inset

?
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Use radix sort to sort edges by weight.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[23.2-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 23.2-7}
\end_layout

\end_inset

Suppose that a graph 
\begin_inset Formula $G$
\end_inset

 has a minimum spanning tree already computed.
 How quickly can we update the minimum spanning tree if we add a new vertex
 and incident edges to 
\begin_inset Formula $G$
\end_inset

?
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Throw in all the edges adjacent on the new vertex and run either Kruskal's
 or Prim's on the old MST + new graph.
\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[23-1]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 23-1}
\end_layout

\end_inset

 Second-best minimum spanning tree.
 
\end_layout

\begin_layout Problem*
Let 
\begin_inset Formula $G$
\end_inset

 be an undirected, connected graph whose weight function is 
\begin_inset Formula $w:E\rightarrow\mathbb{R}$
\end_inset

, and suppose that 
\begin_inset Formula $\left|E\right|\geq\left|V\right|$
\end_inset

 and all edge weights are distinct.
 We define a second-best minimum spanning tree as follows.
 Let 
\begin_inset Formula $\mathcal{T}$
\end_inset

 be the set of all spanning trees of 
\begin_inset Formula $G$
\end_inset

, and let 
\begin_inset Formula $T'$
\end_inset

 be a minimum spanning tree of 
\begin_inset Formula $G$
\end_inset

.
 Then a 
\series bold
second-best minimum spanning tree
\series default
 is a spanning tree 
\begin_inset Formula $T$
\end_inset

 such that 
\begin_inset Formula $w\left(T\right)=\min_{T''\in\mathcal{T}-\left\{ T'\right\} }\left\{ w\left(T''\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Show that the minimum spanning tree is unique, but that the second-best
 minimum spanning tree need not be unique.
 .
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Something something unique weights.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be the minimum spanning tree of 
\begin_inset Formula $G$
\end_inset

.
 Prove that 
\begin_inset Formula $G$
\end_inset

 contains edges 
\begin_inset Formula $\left(u,v\right)\in T$
\end_inset

 and 
\begin_inset Formula $\left(x,y\right)\notin T$
\end_inset

 such that 
\begin_inset Formula $T-\left\{ \left(u,v\right)\right\} \cup\left\{ \left(x,y\right)\right\} $
\end_inset

 is a second-best minimum spanning tree of 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Isn't this like literally the definition of second-best minimum spannign
 tree?
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Let 
\begin_inset Formula $T$
\end_inset

 be a spanning tree of 
\begin_inset Formula $G$
\end_inset

 and, for any two vertices 
\begin_inset Formula $u,v\in V$
\end_inset

 , let 
\begin_inset Formula $\max\left[u,v\right]$
\end_inset

 denote an edge of maximum weight on the unique simple path between 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $T$
\end_inset

 .
 Describe an 
\begin_inset Formula $O\left(V^{2}\right)$
\end_inset

-time algorithm that, given 
\begin_inset Formula $T$
\end_inset

, computes 
\begin_inset Formula $\max\left[u,v\right]$
\end_inset

 for all 
\begin_inset Formula $u,v\in V$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Just do DFS on the spanning tree.
 Since there are no cycles and only 
\begin_inset Formula $\left|V\right|-1$
\end_inset

 edges each run takes 
\begin_inset Formula $O\left(\left|V\right|\right)$
\end_inset

 time.
 Run it for all vertices (and even with repeats) you get 
\begin_inset Formula $O\left(V^{2}\right)$
\end_inset

 running time.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(d)]
\end_layout

\end_inset

Give an efficient algorithm to compute the second-best minimum spanning
 tree of 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 By part (b) you only need to flip one edge to get from MST to second best
 MST.
 First compute MST in 
\begin_inset Formula $O\left(E\lg V\right)$
\end_inset

 time.
 Use part (c) to compute all maximum weight edges.
 Then for all the edges in 
\begin_inset Formula $E$
\end_inset

 but not in 
\begin_inset Formula $T$
\end_inset

 find the one such that that edge's weight minus 
\begin_inset Formula $\max\left[u,v\right]$
\end_inset

 is smallest.
 Then adding that edge and removing the 
\begin_inset Formula $\max\left[u,v\right]$
\end_inset

 edge adds the smallest difference to the minimum spanning tree.
\end_layout

\end_deeper
\begin_layout Section
Single-Source Shortest Paths
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.1-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.1-3}
\end_layout

\end_inset

Given a weighted, directed graph 
\begin_inset Formula $G$
\end_inset

 with no negative-weight cycles, let 
\begin_inset Formula $m$
\end_inset

 be the maximum over all vertices 
\begin_inset Formula $v\in V$
\end_inset

 of the minimum number of edges in a shortest path from the source 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $v$
\end_inset

.
 Here, the shortest path is by weight, not the number of edges.
 Suggest a simple change to the Bellman-Ford algorithm that allows it to
 terminate in 
\begin_inset Formula $m+1$
\end_inset

 passes, even if 
\begin_inset Formula $m$
\end_inset

 is not known in advance.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Keep tabs on whether any relaxations happened in the last 
\begin_inset Quotes eld
\end_inset

sweep
\begin_inset Quotes erd
\end_inset

.
 If none, then stop.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.1-5]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.1-5}
\end_layout

\end_inset

Let 
\begin_inset Formula $G$
\end_inset

 be a weighted, directed graph with weight function 
\begin_inset Formula $w:E\rightarrow\mathbb{R}$
\end_inset

.
 Give an 
\begin_inset Formula $O\left(VE\right)$
\end_inset

-time algorithm to find, for each vertex 
\begin_inset Formula $v\in V$
\end_inset

 , the value 
\begin_inset Formula $\delta^{*}\left(v\right)=\min_{u\in V}\left\{ \delta\left(u,v\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 There are two solutions:
\end_layout

\begin_layout Standard
1.
 Create a universal source (with zero weight edges to all vertices), and
 run Bellman-Ford from the universal source.
 Shortest negative weight paths will be those chosen by this Bellman-Ford
 run.
 If there are no vertices which are "negatively" close then just compute
 
\begin_inset Formula $G^{T}$
\end_inset

 and find outgoing edge with smallest weight.
\end_layout

\begin_layout Standard
2.
 We can initialize the distance of all vertices to be its shortest distance
 to some other vertex (or 
\begin_inset Formula $\infty$
\end_inset

 if it's disconnected).
 Then relaxing 
\begin_inset Formula $\left|V\right|-1$
\end_inset

 times (i.e.
 running Bellman-Ford) will set the 
\begin_inset Formula $v.d=\delta^{*}\left(v\right)$
\end_inset

 for each 
\begin_inset Formula $v\in V$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.1-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.1-6}
\end_layout

\end_inset

Suppose that a weighted, directed graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 has a negative-weight cycle.
 Give an efficient algorithm to list the vertices of one such cycle.
 Prove that your algorithm is correct.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Run Bellman-Ford.
 If the second for loop returns false record which edge 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 is relaxed.
 To find the shortest cycle run Bellman-Ford with new source 
\begin_inset Formula $v$
\end_inset

 to find path to 
\begin_inset Formula $u$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.2-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.2-4}
\end_layout

\end_inset

Give an efficient algorithm to count the total number of paths in a directed
 acyclic graph.
 Analyze your algorithm.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Basically the DP algorithm in 22.4-2.
 Set the "distance" function for each vertex to 1 and then do a topological
 sort and then in topologically sorted order compute "distance" to be the
 sum of "distances" of edge going into the vertex.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.3-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.3-4}
\end_layout

\end_inset

Professor Gaedel has written a program that he claims implements Dijkstra’s
 algorithm.
 The program produces 
\begin_inset Formula $v.d$
\end_inset

 and 
\begin_inset Formula $v.\pi$
\end_inset

 for each vertex 
\begin_inset Formula $v\in V$
\end_inset

.
 Give an 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

-time algorithm to check the output of the professor’s program.
 It should determine whether the 
\begin_inset Formula $d$
\end_inset

 and 
\begin_inset Formula $\pi$
\end_inset

 attributes match those of some shortest-paths tree.
 You may assume that all edge weights are nonnegative.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Key is to check whether any 
\begin_inset Formula $\delta$
\end_inset

s can be further relaxed.
 The rest is just a consistency check: check that the tree is actually a
 tree, check distance from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s$
\end_inset

 is 0, and check that distance to a vertex is equal to the distance to the
 parent plus edge weight from parent to vertex.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.3-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.3-6}
\end_layout

\end_inset

We are given a directed graph 
\begin_inset Formula $G$
\end_inset

 on which each edge 
\begin_inset Formula $\left(u,v\right)\in E$
\end_inset

 has an associated value 
\begin_inset Formula $r\left(u,v\right)$
\end_inset

, which is a real number in the range 
\begin_inset Formula $\left[0,1\right]$
\end_inset

 that represents the reliability of a communication channel from vertex
 u to vertex .
 We interpret 
\begin_inset Formula $r\left(u,v\right)$
\end_inset

 as the probability that the channel from 
\begin_inset Formula $u$
\end_inset

 to 
\begin_inset Formula $v$
\end_inset

 will not fail, and we assume that these probabilities are independent.
 Give an efficient algorithm to find the most reliable path between two
 given vertices.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 There are two ways to do this.
 
\end_layout

\begin_layout Standard
1.
 Define 
\begin_inset Formula $f\left(u,v\right)=1-r\left(u,v\right)$
\end_inset

 as the probability of failure.
 Then we want to minimize 
\begin_inset Formula $\prod f\left(u,v\right)$
\end_inset

 over paths 
\begin_inset Formula $p$
\end_inset

.
 Taking 
\begin_inset Formula $\log$
\end_inset

 we get 
\begin_inset Formula $\min_{p}\left(\sum_{\left(u,v\right)\in p}\log\left(f\left(u,v\right)\right)\right)$
\end_inset

 which is akin shortest path.
 There are some details about negativity to iron out but otherwise use Dijkstra'
s.
 
\end_layout

\begin_layout Standard
2.
 Alternatively you can modify dijkstra to look for max-ish paths by using
 max-heap and 
\begin_inset Formula $\texttt{Extract-Max}$
\end_inset

 and relaxing if 
\begin_inset Formula $v.d<u.d\cdot r\left(u,v\right)$
\end_inset

.
 Although I don't exactly understand why works since the network isn't necessari
ly a DAG.
 If the graph were a DAG then to find the longest path do topological sort/short
est paths on 
\begin_inset Formula $-G$
\end_inset

.
 This picks out the most negative edges, ie the longest path in 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
Note that to find shortest cycle including 
\begin_inset Formula $s$
\end_inset

 on a positive graph (all edges have positive weight) using Dijkstra: perform
 Dijkstra and then use distances computed to find shortest cycle (look through
 edges of all vertices to see if they connect back to 
\begin_inset Formula $s$
\end_inset

).
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.3-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.3-7}
\end_layout

\end_inset

Let 
\begin_inset Formula $G$
\end_inset

 be a weighted, directed graph with positive weight function 
\begin_inset Formula $w:E\rightarrow\left\{ 1,2,\dots W\right\} $
\end_inset

 for some positive integer 
\begin_inset Formula $W$
\end_inset

, and assume that no two vertices have the same shortest-path weights from
 source vertex 
\begin_inset Formula $s$
\end_inset

.
 Now suppose that we define an unweighted, directed graph 
\begin_inset Formula $G'=\left(V\cup V',E'\right)$
\end_inset

 by replacing each edge 
\begin_inset Formula $\left(u,v\right)\in E$
\end_inset

 with 
\begin_inset Formula $w\left(u,v\right)$
\end_inset

 unit-weight edges in series.
 How many vertices does 
\begin_inset Formula $G'$
\end_inset

 have? Now suppose that we run a breadth-first search on 
\begin_inset Formula $G'$
\end_inset

.
 Show that the order in which the breadth-first search of 
\begin_inset Formula $G'$
\end_inset

 colors vertices in 
\begin_inset Formula $V$
\end_inset

 black is the same as the order in which Dijkstra’s algorithm extracts the
 vertices of 
\begin_inset Formula $V$
\end_inset

 from the priority queue when it runs on G.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 This is exactly the idea you have when you meet bfs: if the edges were
 integers then just adding "virtual nodes" enable you to solve shortest
 paths using BFS.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.3-8]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.3-8}
\end_layout

\end_inset

Let 
\begin_inset Formula $G$
\end_inset

 be a weighted, directed graph with positive weight function 
\begin_inset Formula $w:E\rightarrow\left\{ 1,2,\dots W\right\} $
\end_inset

 for some nonnegative integer 
\begin_inset Formula $W$
\end_inset

.
 Modify Dijkstra's algorithm to compute the shortest paths from a given
 vertex 
\begin_inset Formula $s$
\end_inset

 in 
\begin_inset Formula $O\left(WV+E\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Use radix sort or something, i.e.
 "bucketize" vertices according to their distance from 
\begin_inset Formula $s$
\end_inset

.
 Since max weight wedge is 
\begin_inset Formula $W$
\end_inset

 there are a max of 
\begin_inset Formula $\left(V-1\right)W$
\end_inset

 buckets.
 Examine the buckets one by one in increasing order of distances in bucket
 (moving vertices from bucket to bucket to when updated 
\begin_inset Quotes eld
\end_inset

keys
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.4-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.4-3}
\end_layout

\end_inset

Can any shortest-path weight from the new vertex 
\begin_inset Formula $v_{0}$
\end_inset

 in a constraint graph be positive?
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 The objective is sum of weights over all paths.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.4-4]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.4-4}
\end_layout

\end_inset

Express the single-pair shortest-path problem as a linear program.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Nope, in fact the path weight can't be greater or equal to zero.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.4-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.4-6}
\end_layout

\end_inset

Suppose that in addition to a system of difference constraints, we want
 to handle equality constraints of the form 
\begin_inset Formula $x_{i}=x_{j}+b_{k}$
\end_inset

.
 Show how to adapt the Bellman-Ford algorithm to solve this variety of constrain
t system.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Rewrite the equality constraints as two inequality constraints.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24.4-7]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 24.4-7}
\end_layout

\end_inset

Show how to solve a system of difference constraints by a Bellman-Ford-like
 algorithm that runs on a constraint graph without the extra vertex 
\begin_inset Formula $v_{0}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Probably the same as how you run DFS on all nodes on an unconnected graph:
 by running the main loop in a 
\begin_inset Formula $\texttt{for}$
\end_inset

 loop over all of the vertices.
\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24-2]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 24-2}
\end_layout

\end_inset

 Nesting boxes.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Argue that the nesting relation is transitive.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 Well duh.
 If box 
\begin_inset Formula $A$
\end_inset

 can contain box 
\begin_inset Formula $B$
\end_inset

 and box 
\begin_inset Formula $B$
\end_inset

 can contain box 
\begin_inset Formula $C$
\end_inset

 then obviously 
\begin_inset Formula $A$
\end_inset

 can contain C.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Describe an efficient method to determine whether or not one d -dimensional
 box nests inside another.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution.

\series default
 Sort both sets of dimensions and if one set is entry-wise prior then it
 fits.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(c)]
\end_layout

\end_inset

Give an efficient algorithm to find the longest sequence 
\begin_inset Formula $\left\{ B_{1},B_{2},\dots,B_{n}\right\} $
\end_inset

 of boxes such that 
\begin_inset Formula $B_{i_{j}}$
\end_inset

 nests within 
\begin_inset Formula $B_{i_{j+1}}$
\end_inset

 for 
\begin_inset Formula $j=1,\dots,k-1$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution.
 
\series default
Do the 
\begin_inset Formula $n^{2}$
\end_inset

 comparisons to figure out all 
\begin_inset Formula $\left(B_{i},B_{j}\right)$
\end_inset

, where 
\begin_inset Formula $B_{i}$
\end_inset

 can contain 
\begin_inset Formula $B_{j}$
\end_inset

.
 Then do a topological sort on the graph because it's a DAG (because what
 would it mean for a cycle of box containments).
 Then find the longest path using DP:
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,mathescape=true,numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

Longest-Path$
\backslash
left(G
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	T = Top-Sort$
\backslash
left(G
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	for $v
\backslash
in T$
\end_layout

\begin_layout Plain Layout

		$v.d = 
\backslash
max_{
\backslash
left(u,v
\backslash
right)
\backslash
in E}
\backslash
left
\backslash
{ u.d+1
\backslash
right
\backslash
} $
\end_layout

\begin_layout Plain Layout

	return $
\backslash
max_{v
\backslash
in V}
\backslash
left
\backslash
{ v.d
\backslash
right
\backslash
} $
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Longest Path
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24-3]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 24-3}
\end_layout

\end_inset

 Arbitrage.
\end_layout

\begin_layout Problem*

\series bold
Solution
\series default
.
 Similar to Exercise 24.3-6.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[24-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 24-3}
\end_layout

\end_inset

 Bitonic shortest paths.
\end_layout

\begin_layout Problem*
A sequence is 
\series bold
bitonic
\series default
 if it monotonically increases and then monotonically decreases, or if by
 a circular shift it monotonically increases and then monotonically decreases.
 Suppose that we are given a directed graph 
\begin_inset Formula $G$
\end_inset

 with weight function 
\begin_inset Formula $w:E\rightarrow\mathbb{R}$
\end_inset

, where all edge weights are 
\series bold
unique
\series default
, and we wish to find single-source shortest paths from a source vertex
 
\begin_inset Formula $s$
\end_inset

.
 We are given one additional piece of information: for each vertex 
\begin_inset Formula $v\in V$
\end_inset

, the weights of the edges along any shortest path from 
\begin_inset Formula $s$
\end_inset

 to form a bitonic sequence.
 Give the most efficient algorithm you can to solve this problem, and analyze
 its running time.
\end_layout

\begin_layout Problem*

\series bold
Solution
\series default
.
 Sort the edges by weight.
 Then relax increasing order, decreasing order, then increasing again and
 you're done.
\end_layout

\begin_layout Section
All-Pairs Shortest Paths
\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[25.1-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 25.1-6}
\end_layout

\end_inset

Suppose we also wish to compute the vertices on shortest paths in the algorithms
 of this section.
 Show how to compute the predecessor matrix 
\begin_inset Formula $\Pi$
\end_inset

 from the completed matrix 
\begin_inset Formula $L$
\end_inset

 of shortest-path weights in 
\begin_inset Formula $O\left(n^{3}\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Loop over everything and check against edge weights to see where shortest
 path between two vertices is edge weight plus shortest path to first vertex.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[25.1-9]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 25.1-9}
\end_layout

\end_inset

Modify 
\begin_inset Formula $\texttt{FASTER-ALL-PAIRS-SHORTEST-PATHS}$
\end_inset

 so that it can determine whether the graph contains a negative-weight cycle.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Look for negatives on the diagonal.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[25.1-10]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 25.1-10}
\end_layout

\end_inset

Give an efficient algorithm to find the length (number of edges) of a minimum
 length negative-weight cycle in a graph.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Look for the first 
\begin_inset Formula $m$
\end_inset

 such that 
\begin_inset Formula $L^{m}$
\end_inset

 has negatives on the diagonal.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[25.2-6]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 25.2-6}
\end_layout

\end_inset

How can we use the output of the Floyd-Warshall algorithm to detect the
 presence of a negative-weight cycle?
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Again, it's whether there are negative values on the diagonal.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Exercise*
\begin_inset ERT
status open

\begin_layout Plain Layout

[25.2-8]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Exercise 25.2-8}
\end_layout

\end_inset

Give an 
\begin_inset Formula $O\left(VE\right)$
\end_inset

-time algorithm for computing the transitive closure of a directed graph
 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Solution
\series default
.
 Do a dfs and add all the visited vertices to a set.
 Do this for each vertex.
 Running time is 
\begin_inset Formula $O\left(V\left(V+E\right)\right)$
\end_inset

, however 
\begin_inset Formula $E\leq V^{2}$
\end_inset

 so 
\begin_inset Formula $O\left(V\left(V+E\right)\right)=O\left(VE\right)$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Problem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[25-1]
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{
\backslash
numberline{}Problem 24-2}
\end_layout

\end_inset

 Transitive closure of a dynamic graph.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(a)]
\end_layout

\end_inset

Show how to update the transitive closure 
\begin_inset Formula $G^{*}=\left(V,E^{*}\right)$
\end_inset

 of a graph 
\begin_inset Formula $G$
\end_inset

 in 
\begin_inset Formula $O\left(V^{2}\right)$
\end_inset

 time when a new edge is added to 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution
\series default
.
 The obvious solution: for new edge 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 any vertex already connected to 
\begin_inset Formula $u$
\end_inset

 now becomes connected to every vertex that 
\begin_inset Formula $v$
\end_inset

 connects to.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[(b)]
\end_layout

\end_inset

Describe an efficient algorithm for updating the transitive closure as edges
 are inserted into the graph.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Solution.

\series default
 Something something 
\begin_inset Formula $\left|E\right|\leq\left|V\right|$
\end_inset

?
\end_layout

\end_deeper
\end_deeper
\end_body
\end_document
