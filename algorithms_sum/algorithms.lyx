#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass amsart
\begin_preamble
\usepackage{tikz}
\usepackage{graphicx}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{decorations.pathreplacing}
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\branch Deleted
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part*
Note
\end_layout

\begin_layout Standard
Everything is 
\begin_inset Formula $1$
\end_inset

 indexed, despite using vaguely Pythonic syntax.
 This means 
\begin_inset Formula $A\left[\text{len}\left(A\right)\right]=A\left[-1\right]$
\end_inset

.
 Slicing is 
\begin_inset Formula $A\left[a:b\right]=\left[A_{a},A_{a+1},\dots,A_{b-1}\right]$
\end_inset

.
 Where bounds checking is obviously necessary it is omitted.
 I assume a different memory model from Python: each entry of 
\begin_inset Formula $B=\left[\left[\right]\right]$
\end_inset

 is an independent list.
 Ranges are represented using MATLAB notation 
\begin_inset Formula $1:n$
\end_inset

.
\end_layout

\begin_layout Part
Foundations
\end_layout

\begin_layout Section
Insertion Sort
\end_layout

\begin_layout Standard
Maintains the invariant that 
\begin_inset Formula $A\left[1:j-1\right]$
\end_inset

 is sorted by shifting elements right.
 Insertion sort is 
\emph on
stable
\emph default
, i.e.
 two keys already in sorted order remain in the same order at the end.
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Insertion-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

for $j=2: 
\backslash
text{len}
\backslash
left(A
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	$key=A
\backslash
left[j
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$i = j-1$
\end_layout

\begin_layout Plain Layout

	while $i>0$ and $A
\backslash
left[i
\backslash
right] > key$:
\end_layout

\begin_layout Plain Layout

		$A
\backslash
left[i+1
\backslash
right] = A
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		$i = i- 1$
\end_layout

\begin_layout Plain Layout

	# either we're one passed the left end
\end_layout

\begin_layout Plain Layout

	# or $A
\backslash
left[i
\backslash
right] 
\backslash
leq $ key and so 
\end_layout

\begin_layout Plain Layout

	# $A
\backslash
left[i+1
\backslash
right]$ is the proper place for key
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[i+1
\backslash
right] = $ key
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Selection Sort
\end_layout

\begin_layout Standard
Maintains the same invariant as Insertion Sort but does so by going forward
 and 
\emph on
selecting
\emph default
 the smallest element each time.
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Selection-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

for $j=1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[j
\backslash
right] = 
\backslash
min
\backslash
left(A
\backslash
left[j+1:
\backslash
right]
\backslash
right)$ 	
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Bubble Sort
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Bubble up
\begin_inset Quotes erd
\end_inset

 pair by pair.
 Stop when no more 
\begin_inset Quotes eld
\end_inset

bubblings
\begin_inset Quotes erd
\end_inset

 are possible.
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Bubble-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align center

$flips=$ True
\end_layout

\begin_layout Plain Layout

while flips:
\end_layout

\begin_layout Plain Layout

	$flips=$ False
\end_layout

\begin_layout Plain Layout

	for $i = 1:
\backslash
text{len}
\backslash
left(A
\backslash
right)-1$:
\end_layout

\begin_layout Plain Layout

		if $A
\backslash
left[i
\backslash
right] > A
\backslash
left[i+1
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			$A
\backslash
left[i
\backslash
right], A
\backslash
left[i+1
\backslash
right] = A
\backslash
left[i+1
\backslash
right], A
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			$flips=$ True		
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Merge Sort
\end_layout

\begin_layout Standard
Divide and conquer approach.
 Divide the array in half, recurse, combine results by merging, i.e.
 taking the smallest entry from each piece in turn.
 Base case is just an array with one element.
 Running time is 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Merge-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if len$
\backslash
left(A
\backslash
right)==1$:
\end_layout

\begin_layout Plain Layout

	return $A$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$h = 
\backslash
left
\backslash
lfloor
\backslash
frac{
\backslash
text{len}
\backslash
left(A
\backslash
right)}{2}
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$L=$ Merge-Sort$
\backslash
left(A
\backslash
left[h:
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$R=$ Merge-Sort$
\backslash
left(A
\backslash
left[1:h
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$M= 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	while len$
\backslash
left(L
\backslash
right) > 0 $ and len$
\backslash
left(R
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

		# take the minimum of the $
\backslash
left
\backslash
{L
\backslash
left[1
\backslash
right],R
\backslash
left[1
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

		# and remove it from further contention
\end_layout

\begin_layout Plain Layout

		if $L
\backslash
left[1
\backslash
right] < R
\backslash
left[1
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			$M$.append$
\backslash
left(L
\backslash
left[1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

			del $L
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			$M$.append$
\backslash
left(R
\backslash
left[1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

			del $R
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# one of $L,R$ is large by one element.
\end_layout

\begin_layout Plain Layout

	if len$
\backslash
left(L
\backslash
right) > 0 $
\end_layout

\begin_layout Plain Layout

		$M$.append$
\backslash
left(L
\backslash
left[1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else: 
\end_layout

\begin_layout Plain Layout

		$M$.append$
\backslash
left(R
\backslash
left[1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$M$.append$
\backslash
left(R
\backslash
left[-1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	return $M$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Binary search
\end_layout

\begin_layout Standard
If an array is already sorted then you can find an element in it faster
 than 
\begin_inset Formula $O\left(n\right)$
\end_inset

 time; you can find it in 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 time.
 Search in either the left side of the middle entry or the right side.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Search
\family default

\begin_inset Formula $\left(A,x\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $x == A
\backslash
left[h
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	return True
\end_layout

\begin_layout Plain Layout

elif $x < A
\backslash
left[h
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	return Binary-Search$
\backslash
left(A
\backslash
left[1:h
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	return Binary-Search$
\backslash
left(A
\backslash
left[h:
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Horner's Rule
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 the coefficients of a polynomial and a value 
\begin_inset Formula $x$
\end_inset

 a faster way to calculate 
\begin_inset Formula $p\left(x\right)$
\end_inset

 is 
\begin_inset Formula 
\[
p\left(x\right)=\sum_{k=1}^{n}a_{k}x^{k}=a_{1}+x\left(a_{2}+x\left(a_{3}+\cdots+x\left(a_{n-1}+xa_{n}\right)\right)\right)
\]

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Horners-Rule
\family default

\begin_inset Formula $\left(A,x\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$y=0$
\end_layout

\begin_layout Plain Layout

for $i = n:1$:
\end_layout

\begin_layout Plain Layout

	$y = A
\backslash
left[i
\backslash
right]+x 
\backslash
cdot y$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Reservoir Sampling
\end_layout

\begin_layout Subsection
Unweighted simple
\end_layout

\begin_layout Standard
Suppose you want to sample 
\begin_inset Formula $k$
\end_inset

 items from 
\begin_inset Formula $n$
\end_inset

 items 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 fairly, i.e.
 uniform random, 
\series bold
without replacement
\series default
, draws.
 If you have all 
\begin_inset Formula $n$
\end_inset

 items available immediately then this is simple, but if you're solving
 the problem 
\emph on
online
\emph default
 it's slightly more involved.
 For example you might not want to store all 
\begin_inset Formula $n$
\end_inset

 items.
 Put the first 
\begin_inset Formula $k$
\end_inset

 items into a 
\emph on
reservoir 
\begin_inset Formula $R$
\end_inset


\emph default
 then for item 
\begin_inset Formula $i>k$
\end_inset

 draw 
\begin_inset Formula $j\in\left\{ 1,\dots,i\right\} $
\end_inset

 inclusive.
 If 
\begin_inset Formula $i\leq k$
\end_inset

 the replace 
\begin_inset Formula $i$
\end_inset

th item.
 Running time is 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Unweighted-Reservoir-One
\family default

\begin_inset Formula $\left(A,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$R = 
\backslash
left[a_{0},a_{1},
\backslash
dots,a_{k}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=k+1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	$j = $ Random$
\backslash
left(1,i
\backslash
right)$ # both ends inclusive
\end_layout

\begin_layout Plain Layout

	if $j 
\backslash
leq k$:
\end_layout

\begin_layout Plain Layout

		$R
\backslash
left[j
\backslash
right] = A
\backslash
left[i
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Unweighted slightly more involved
\end_layout

\begin_layout Standard
Another way to do solve the same problem is to use a priority queue.
 Why complicate things? This solution generalizes to weighted sampling.
 Running time takes 
\begin_inset Formula $O\left(n\lg k\right)$
\end_inset

 because of potentially 
\begin_inset Formula $n$
\end_inset

 
\family typewriter
Extract-Min 
\family default
operations on a 
\begin_inset Formula $k$
\end_inset

 length priority queue
\family typewriter
.
\family default

\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Unweighted-Reservoir-Two
\family default

\begin_inset Formula $\left(A,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$R = $ Min-Priority-Queue
\end_layout

\begin_layout Plain Layout

for $i = 1:k$:
\end_layout

\begin_layout Plain Layout

	$u 
\backslash
sim 
\backslash
text{Uniform}
\backslash
left(0,1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# priority key is first entry in argument
\end_layout

\begin_layout Plain Layout

	$H
\backslash
text{.insert}
\backslash
left(u,A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $i=k+1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	$u 
\backslash
sim 
\backslash
text{Uniform}
\backslash
left(0,1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# $H$.min returns value of minimum without extracting
\end_layout

\begin_layout Plain Layout

	if $u < H$.min:
\end_layout

\begin_layout Plain Layout

		$H$.Extract-Min$
\backslash
left(
\backslash
right)$		
\end_layout

\begin_layout Plain Layout

		$H
\backslash
text{.insert}
\backslash
left(u,A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Weighted
\end_layout

\begin_layout Standard
Suppose the same sampling problem but each element has a weight associated
 with it.
 
\family typewriter
Unweighted-Reservoir-Two 
\family default
extends naturally (sort of).
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Weighted-Reservoir
\family default

\begin_inset Formula $\left(A,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$R = $ Min-Priority-Queue
\end_layout

\begin_layout Plain Layout

for $i = 1:k$:
\end_layout

\begin_layout Plain Layout

	$u 
\backslash
sim 
\backslash
text{Uniform}
\backslash
left(0,1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$u = u^{1/A
\backslash
left[i
\backslash
right]
\backslash
text{.weight}}$
\end_layout

\begin_layout Plain Layout

	$H
\backslash
text{.insert}
\backslash
left(u,A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $i=k+1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	$u 
\backslash
sim 
\backslash
text{Uniform}
\backslash
left(0,1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$u = u^{1/A
\backslash
left[i
\backslash
right]
\backslash
text{.weight}}$
\end_layout

\begin_layout Plain Layout

	if $u < H$.min:
\end_layout

\begin_layout Plain Layout

		$H$.Extract-Min$
\backslash
left(
\backslash
right)$		
\end_layout

\begin_layout Plain Layout

		$H
\backslash
text{.insert}
\backslash
left(u,A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Online Maximum
\end_layout

\begin_layout Standard
Suppose you wanted to compute a maximum of 
\begin_inset Formula $n$
\end_inset

 items but we can only make the selection once.
 This is similar to online sampling: fill a reservoir 
\begin_inset Formula $R$
\end_inset

 full of candidates and pick the maximum from the reservoir.
 Then after finding that maximum pick the next maximum (if one exists) that's
 higher; this will be the single selection.
 But what size should the reservoir be? Turns out if 
\begin_inset Formula $k=n/e$
\end_inset

 where 
\begin_inset Formula $e$
\end_inset

 is 
\begin_inset Formula $\exp\left(1\right)$
\end_inset

 then we'll pick the true maximum with probability at least 
\begin_inset Formula $e^{-1}.$
\end_inset

 This can be further simplified by realizing you don't need to keep the
 entire reservoir and you can return after the first forthcoming maximum
 (if one exists).
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Online-Max
\family default

\begin_inset Formula $\left(A,n\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$m = A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# these selections to count against the quota
\end_layout

\begin_layout Plain Layout

for $i = 2:
\backslash
left
\backslash
lceil n/e 
\backslash
right
\backslash
rceil$:
\end_layout

\begin_layout Plain Layout

	if $A
\backslash
left[i
\backslash
right] > m$:
\end_layout

\begin_layout Plain Layout

		$m = A
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# this one is for keeps
\end_layout

\begin_layout Plain Layout

for $i=k+1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	if $A
\backslash
left[i
\backslash
right] > m$:
\end_layout

\begin_layout Plain Layout

		return $A
\backslash
left[i
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Stable Matching
\end_layout

\begin_layout Standard
The task is given 
\begin_inset Formula $n$
\end_inset

 men and 
\begin_inset Formula $n$
\end_inset

 women, where each person has ranked all members of the opposite sex in
 order of preference, marry the men and women together such that there are
 no two people of opposite sex who would both rather have each other than
 their current partners (a stable matching).
 One question is does such a stable matching even exist? In fact it does
 and the algorithm that produces one, the Gale-Shapley algorithm, proves
 it.
 It runs in 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
 The next question is the solution optimal.
 In fact it is not.
 The algorith is simple: first each man proposes to the woman he prefers
 best and each woman accepts provisionally, i.e.
 accepts a proposal but trades up if a more desirable man proposes.
 Do this for 
\begin_inset Formula $n$
\end_inset

 rounds (or until there are no more unengaged men).
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
Matching
\begin_inset Formula $\left(P_{m},P_{w},men\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $men$ is an array of men to be matched
\end_layout

\begin_layout Plain Layout

# $P_m$ is an $n 
\backslash
times n$ preferences matrix for the men, sorted by increasing priority
\end_layout

\begin_layout Plain Layout

# $P_w$ is an $n 
\backslash
times n$ a preferences matrix for the women, sorted
\end_layout

\begin_layout Plain Layout

$matched_M = 
\backslash
{
\backslash
}$
\end_layout

\begin_layout Plain Layout

$matched_W = 
\backslash
{
\backslash
}$
\end_layout

\begin_layout Plain Layout

while len$
\backslash
left(men
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$m = men
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$w = P_m
\backslash
left(m
\backslash
right)
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	if w not in $matched_W$:
\end_layout

\begin_layout Plain Layout

		$matched_M
\backslash
left[m
\backslash
right] = w$
\end_layout

\begin_layout Plain Layout

		$matched_W
\backslash
left[w
\backslash
right] = m$
\end_layout

\begin_layout Plain Layout

		del $P_m
\backslash
left(m
\backslash
right)
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		del $men
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	else: # if $w$ is already matched
\end_layout

\begin_layout Plain Layout

		$m' = matched_W
\backslash
left[w
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		# and prefers $m$ to $m'$
\end_layout

\begin_layout Plain Layout

		if $P_w
\backslash
left[w
\backslash
right]
\backslash
left[m
\backslash
right] > P_w
\backslash
left[w
\backslash
right]
\backslash
left[m' 
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			# match $m$ with $w$
\end_layout

\begin_layout Plain Layout

			$matched_M
\backslash
left[m
\backslash
right] = w$
\end_layout

\begin_layout Plain Layout

			$matched_W
\backslash
left[w
\backslash
right] = m$
\end_layout

\begin_layout Plain Layout

			del $P_m
\backslash
left(m
\backslash
right)
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			del $men
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			# unmatch $m'$
\end_layout

\begin_layout Plain Layout

			del $matched_M
\backslash
left[m' 
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			$matched_M
\backslash
text{.append}
\backslash
left(m' 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Sorting and Order Statistics
\end_layout

\begin_layout Section
Heaps
\end_layout

\begin_layout Standard
Array Heaps
\begin_inset Foot
status open

\begin_layout Plain Layout
Heaps can be built on top of trees.
\end_layout

\end_inset

 are a data structure built on top of an array 
\begin_inset Formula $A$
\end_inset

, i.e.
 a structural invariant and a collection of functions that maintain that
 invariant.
 Heaps come in two flavors: Min heaps and Max heaps.
 The invariant for a Max heap is 
\begin_inset Formula $A\left[i\right]\leq A\left[\left\lfloor i/2\right\rfloor \right]$
\end_inset

.
 Furthermore each entry has 
\begin_inset Quotes eld
\end_inset

children
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Formula $A\left[2i\right]$
\end_inset

 is the left child and 
\begin_inset Formula $A\left[2i+1\right]$
\end_inset

 is the right child of element 
\begin_inset Formula $A\left[i\right]$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Max Heapify
\end_layout

\begin_layout Standard
To re-establish the heap property we use a procedure that fixes violations
 by switching the violator with its largest child and then recursing.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Max-Heapify
\family default

\begin_inset Formula $\left(A,i\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$largest = i$
\end_layout

\begin_layout Plain Layout

# if the left child exists and is greater then potentially switch
\end_layout

\begin_layout Plain Layout

if $ 2i 
\backslash
leq 
\backslash
text{len}
\backslash
left(A
\backslash
right)$ and $A
\backslash
left[2i
\backslash
right] > A
\backslash
left[i
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	$largest = 2i$
\end_layout

\begin_layout Plain Layout

# if the right child exists and is greater then switch
\end_layout

\begin_layout Plain Layout

if $ 2i+1 
\backslash
leq 
\backslash
text{len}
\backslash
left(A
\backslash
right)$ and $A
\backslash
left[2i+1
\backslash
right] > A
\backslash
left[largest
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	$largest = 2i+1$
\end_layout

\begin_layout Plain Layout

$A
\backslash
left[i
\backslash
right],A
\backslash
left[largest
\backslash
right] = A
\backslash
left[largest
\backslash
right],A
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# potentially fix violation between child and one of its children
\end_layout

\begin_layout Plain Layout

Max-Heapify$
\backslash
left(A,largest
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Build Max Heap
\end_layout

\begin_layout Standard
To build a heap from an array notice that the deepest children/leaves are
 already legal heaps so there's no need to 
\family typewriter
Max-Heapify 
\family default
them, and the children start at 
\begin_inset Formula $\left\lfloor \text{len}\left(A\right)/2\right\rfloor $
\end_inset

.
 Running time is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Max-Heapify
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

for $i = 
\backslash
left
\backslash
lfloor 
\backslash
text{len}
\backslash
left(A
\backslash
right)/2
\backslash
right
\backslash
rfloor:1 $:
\end_layout

\begin_layout Plain Layout

	Max-Heapify$
\backslash
left(A,i
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Extract Min
\end_layout

\begin_layout Standard
\begin_inset Formula $A\left[1\right]$
\end_inset

 is the maximum element in the heap (by the Max heap invariant), but removing
 it isn't as simple as just popping it off the top since the invariant might
 be violated.
 It's also not as simple as simple as replacing 
\begin_inset Formula $A\left[1\right]$
\end_inset

 with it's largest child because.
 The solution is to replace with the last element in the heap and then re-establ
ish the invariant.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Extract-Min
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$m = A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$A
\backslash
left[1
\backslash
right] = A
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$A
\backslash
text{.pop}
\backslash
left(
\backslash
right)$
\end_layout

\begin_layout Plain Layout

Max-Heapify$
\backslash
left(A,1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $m$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Heap sort
\end_layout

\begin_layout Standard
You can use 
\family typewriter
Extract-Min
\family default
 in the obvious way to sort an array.
 Running time is 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

.
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
HeapSort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$s = [~]$
\end_layout

\begin_layout Plain Layout

while len$
\backslash
left(A
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$s
\backslash
text{.append}
\backslash
left(
\backslash
text{Extract-Min}
\backslash
left(A
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return reversed$
\backslash
left(s
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Heap increase key
\end_layout

\begin_layout Standard
In various instances you might want to increase the position of a key in
 the heap, such as when each key corresponds to the priority of some task.
 This just involves re-establish the Max heap invariant by 
\begin_inset Quotes eld
\end_inset

percolating
\begin_inset Quotes erd
\end_inset

 the entry up the array.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Heap-Increase-Key
\family default

\begin_inset Formula $\left(A,i,key\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $key < A
\backslash
left[i
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	throw Exception$
\backslash
left(key
\backslash
text{ is smaller than current } i 
\backslash
text{ key}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$A
\backslash
left[i
\backslash
right] = key$
\end_layout

\begin_layout Plain Layout

# if child is bigger then parent then swap
\end_layout

\begin_layout Plain Layout

while $i > 1$ and $A
\backslash
left[
\backslash
left
\backslash
lfloor i/2
\backslash
right
\backslash
rfloor 
\backslash
right] < A
\backslash
left[i
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[
\backslash
left
\backslash
lfloor i/2
\backslash
right
\backslash
rfloor 
\backslash
right], A
\backslash
left[i
\backslash
right] = A
\backslash
left[i
\backslash
right], A
\backslash
left[
\backslash
left
\backslash
lfloor i/2
\backslash
right
\backslash
rfloor 
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$i = 
\backslash
left
\backslash
lfloor i/2
\backslash
right
\backslash
rfloor$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Heap insert
\end_layout

\begin_layout Standard
Using 
\family typewriter
Heap-Increase-Key
\family default
 we can insert into the heap by insert and 
\begin_inset Formula $-\infty$
\end_inset

 element at the end of the heap and then increasing the key to what we want.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Max-Heap-Insert
\family default

\begin_inset Formula $\left(A,key\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$A
\backslash
text{.append}
\backslash
left(-
\backslash
infty
\backslash
right)$
\end_layout

\begin_layout Plain Layout
\noindent
\align left

Heap-Increase-Key$
\backslash
left(A,
\backslash
text{len}
\backslash
left(A
\backslash
right),key
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Quicksort
\end_layout

\begin_layout Standard
Quicksort is experimentally the most efficient sorting algorithm.
 The randomized version runs in 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

 but is typically faster.
 It works by dividing and conquering.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Quicksort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if len$
\backslash
left(A
\backslash
right) 
\backslash
leq 1$:
\end_layout

\begin_layout Plain Layout

	return $A$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	# randomly pick a pivot
\end_layout

\begin_layout Plain Layout

	$p = 
\backslash
text{Random}
\backslash
left(1,
\backslash
text{len}
\backslash
left(A
\backslash
right)
\backslash
right)$ # inclusive
\end_layout

\begin_layout Plain Layout

	# swap so that you can exclude from contention the pivot
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[p
\backslash
right], A
\backslash
left[-1
\backslash
right] = A
\backslash
left[-1
\backslash
right], A
\backslash
left[p
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# partition
\end_layout

\begin_layout Plain Layout

	$A_{left} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e 
\backslash
leq A
\backslash
left[-1
\backslash
right] 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$A_{right} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e > A
\backslash
left[-1
\backslash
right] 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# recursively sort
\end_layout

\begin_layout Plain Layout

	$ A_{left} = 
\backslash
text{Quicksort}
\backslash
left(A_{left}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$ A_{right} = 
\backslash
text{Quicksort}
\backslash
left(A_{right}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# combine
\end_layout

\begin_layout Plain Layout

	return $A_{left} + A
\backslash
left[-1
\backslash
right]+ A_{right}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Counting Sort
\end_layout

\begin_layout Standard
The lower bound on sorting in the comparison model (i.e.
 using comparisons as an ordering relation) is 
\begin_inset Formula $\Theta\left(n\lg n\right)$
\end_inset

.
 But if one doesn't use comparisons then 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 is possible.
 Counting sort is one such 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 algorithm.
 If keys range from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

 in 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 then counting sort counts the number of keys less than or equal to each
 key 
\begin_inset Formula $a_{i}$
\end_inset

 and then places 
\begin_inset Formula $a_{i}$
\end_inset

 in that position.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Counting-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ k = 
\backslash
max
\backslash
left(A
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ C = 
\backslash
left(k+1
\backslash
right)*
\backslash
left[0
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# count how many of values from $1$ to $k$ there is
\end_layout

\begin_layout Plain Layout

for $i = 1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	$C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right] =C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right] + 1$
\end_layout

\begin_layout Plain Layout

# count how entries in $A$ less or equal to $i$
\end_layout

\begin_layout Plain Layout

for $i = 1: k$:
\end_layout

\begin_layout Plain Layout

	$C
\backslash
left[i
\backslash
right] = C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right] + 1$
\end_layout

\begin_layout Plain Layout

# now place the items in the correct places
\end_layout

\begin_layout Plain Layout

$ B = 
\backslash
left(k+1
\backslash
right)*
\backslash
left[None
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# go in reverse direction in order for sort to be stable
\end_layout

\begin_layout Plain Layout

for $i = 
\backslash
text{len}
\backslash
left(A
\backslash
right):1$:
\end_layout

\begin_layout Plain Layout

	# $a_i$ has $C
\backslash
left[a_i
\backslash
right]$ elements to its left in $B$
\end_layout

\begin_layout Plain Layout

	$B
\backslash
left[C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right]
\backslash
right] = A
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# if there are multiples of $a_i$ then the next 
\end_layout

\begin_layout Plain Layout

	# should be left of in order for stable
\end_layout

\begin_layout Plain Layout

	$C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right] = C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right] -1 $
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Radix Sort
\end_layout

\begin_layout Standard
Radix sort use the same technique that casinos use to sort cards (apparently?):
 sort stably least significant to most significant digit.
 For 
\begin_inset Formula $n$
\end_inset

 numbers in base 
\begin_inset Formula $d$
\end_inset

 where each digit ranges from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

 the running time is 
\begin_inset Formula $\Theta\left(d\left(n+k\right)\right)$
\end_inset

 if the stable sort runs in 
\begin_inset Formula $\Theta\left(n+k\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Radix-Sort
\family default

\begin_inset Formula $\left(A,d\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

for $i=1:d$:
\end_layout

\begin_layout Plain Layout

	# let's pretend i can pass Insertion-Sort a key
\end_layout

\begin_layout Plain Layout

	Insertion-Sort$
\backslash
left(A,
\backslash
text{key=}
\backslash
text{lambda }a: a
\backslash
left[-i
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Bucket Sort
\end_layout

\begin_layout Standard
Bucket sort depends on values being uniformly distributed 
\begin_inset Formula $\left[0,1\right]$
\end_inset

.
 It buckets all the entries and then subsorts.
 Expected run time is 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Bucket-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$n=
\backslash
text{len}
\backslash
left(A
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$B = n 
\backslash
cdot 
\backslash
left[
\backslash
left[~
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	# bucket (imagine $n=10$).
 
\end_layout

\begin_layout Plain Layout

	# the $+1$ is because $
\backslash
left
\backslash
lfloor 10 
\backslash
left(0.01
\backslash
right) 
\backslash
right
\backslash
rfloor = 0$
\end_layout

\begin_layout Plain Layout

	$B
\backslash
left[ 
\backslash
left
\backslash
lfloor n A
\backslash
left[i
\backslash
right] 
\backslash
right
\backslash
rfloor +1 
\backslash
right] 
\backslash
text{.append}
\backslash
left(A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	Insertion-Sort$
\backslash
left(B
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $B$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Order statistics
\end_layout

\begin_layout Subsection
Quickselect
\end_layout

\begin_layout Standard
Any sorting algorithm can be used to compute 
\begin_inset Formula $k$
\end_inset

th order statistics: simply sort and return the 
\begin_inset Formula $k$
\end_inset

th element.
 But using the ideas of 
\family typewriter
Quicksort
\family default
 you can get down to expected time 
\begin_inset Formula $O\left(n\right)$
\end_inset

: only recurse to one side.
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Quicks
\family default
elect
\begin_inset Formula $\left(A,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if len$
\backslash
left(A
\backslash
right) 
\backslash
leq 1$:
\end_layout

\begin_layout Plain Layout

	return $A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$p = 
\backslash
text{Random}
\backslash
left(1,
\backslash
text{len}
\backslash
left(A
\backslash
right)
\backslash
right)$ # inclusive
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[p
\backslash
right], A
\backslash
left[-1
\backslash
right] = A
\backslash
left[-1
\backslash
right], A
\backslash
left[p
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$A_{left} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e 
\backslash
leq A
\backslash
left[-1
\backslash
right] 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	if $k == 
\backslash
text{len}
\backslash
left(A_{left}+1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# in sorted order $A
\backslash
left[1:
\backslash
text{len}
\backslash
left(A_{left}+1
\backslash
right)
\backslash
right] = A_{left}+
\backslash
left[A
\backslash
left[-1
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		# and so the pivot is 1 "in front" of $A_{left}$
\end_layout

\begin_layout Plain Layout

		return $A
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	elif $k < 
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# the $k$th order statistic in $A$ is still the $k$th order statistic
 in $A_{left}$
\end_layout

\begin_layout Plain Layout

		return Quickselect$
\backslash
left(A_{left},k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$A_{right} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e > x
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# the $k$th order statistic is $
\backslash
left(k-
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)-1
\backslash
right)$th statistic in $A_{right}$
\end_layout

\begin_layout Plain Layout

		# think about it likes this: $A=
\backslash
left[1,2,3,4,5
\backslash
right]$ and we partition on 
\end_layout

\begin_layout Plain Layout

		# 3 and we look for the 4th order statistic.
 well obviously it's 
\end_layout

\begin_layout Plain Layout

		# $4=A_{right}
\backslash
left[k-
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)-1 
\backslash
right] = A_{right}
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		return Quickselect$
\backslash
left(A_{right},k-
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)-1
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Quickerselect
\end_layout

\begin_layout Standard
Using 
\emph on
median-of-medians
\emph default
 in order to guarantee good splits we can get down to 
\begin_inset Formula $O\left(n\right)$
\end_inset

 worst case (not just expected).
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Quickers
\family default
elect
\begin_inset Formula $\left(A,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if len$
\backslash
left(A
\backslash
right) == 0$:
\end_layout

\begin_layout Plain Layout

	return $A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	# divide into $n$ groups of 5 (except for the last one)
\end_layout

\begin_layout Plain Layout

	# and use a sort in order to get medians.
\end_layout

\begin_layout Plain Layout

	$n = 
\backslash
left
\backslash
lfloor 
\backslash
text{len}
\backslash
left(A
\backslash
right) / 5 
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$m_1 = 
\backslash
text{Insertion-Sort}
\backslash
left(A
\backslash
left[1:5+1
\backslash
right]
\backslash
right)
\backslash
left[3
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$m_2 = 
\backslash
text{Insertion-Sort}
\backslash
left(A
\backslash
left[5:10+1
\backslash
right]
\backslash
right)
\backslash
left[3
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$
\backslash
vdots$
\end_layout

\begin_layout Plain Layout

	$m_n = 
\backslash
text{Insertion-Sort}
\backslash
left(A
\backslash
left[5n:
\backslash
right]
\backslash
right)
\backslash
left[ 
\backslash
left
\backslash
lfloor 
\backslash
frac{
\backslash
text{len}
\backslash
left(A
\backslash
left[5n:
\backslash
right]
\backslash
right)}{2}  
\backslash
right
\backslash
rfloor 
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# recursively compute median of medians and use it as the pivot
\end_layout

\begin_layout Plain Layout

	# after this recursive call the pivot is in position $
\backslash
left
\backslash
lfloor n/2 
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$
\backslash
text{Quickerselect}
\backslash
left(
\backslash
left[m_1,m_2,
\backslash
dots,m_n
\backslash
right], 
\backslash
left
\backslash
lfloor n/2 
\backslash
right
\backslash
rfloor
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[
\backslash
left
\backslash
lfloor n/2 
\backslash
right
\backslash
rfloor
\backslash
right], A
\backslash
left[-1
\backslash
right] = A
\backslash
left[-1
\backslash
right], A
\backslash
left[
\backslash
left
\backslash
lfloor n/2 
\backslash
right
\backslash
rfloor
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$x = A
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$A_{left} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e 
\backslash
leq x
\backslash
right) + 
\backslash
left[x
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	if $k == 
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		return $x$
\end_layout

\begin_layout Plain Layout

	elif $k < 
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		return Quickselect$
\backslash
left(A_{left},k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$A_{right} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e > x
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		return Quickselect$
\backslash
left(A_{right},k-
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Data Structures
\end_layout

\begin_layout Section
Hash Tables
\end_layout

\begin_layout Standard
Hash tables are 
\begin_inset Formula $m$
\end_inset

 length arrays keyed on strings instead of numbers.
\end_layout

\begin_layout Subsection
Hash function
\end_layout

\begin_layout Standard
A Hash function is something that 
\begin_inset Quotes eld
\end_inset

hashes
\begin_inset Quotes erd
\end_inset

 up strings into numbers.
 It should uniformly distribute the keys over the hash space, meaning each
 key 
\begin_inset Formula $k$
\end_inset

 is equally likely to hash to any of the 
\begin_inset Formula $m$
\end_inset

 slots of the hash table.
 A good hash function according to Knuth is 
\begin_inset Formula 
\[
h\left(k\right)=\left\lfloor m\left(kA\mod1\right)\right\rfloor 
\]

\end_inset

where 
\begin_inset Formula $A\approx\left(\sqrt{5}-1\right)/2$
\end_inset

 and 
\begin_inset Formula $kA\mod1$
\end_inset

 means the fractional part of 
\begin_inset Formula $kA$
\end_inset

, i.e.
 
\begin_inset Formula $kA-\left\lfloor kA\right\rfloor $
\end_inset

.
\end_layout

\begin_layout Subsection
Hashing with chaining 
\end_layout

\begin_layout Standard
Hashing with chaining is basically Bucket Sort, except with the 
\begin_inset Formula $\left\lfloor \right\rfloor $
\end_inset

 replaced by a Hash function and retrieval.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
Hashing with Chaining
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

HashInsert$
\backslash
left(H,k,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# H is hash table, $k$ is key, $v$ is value
\end_layout

\begin_layout Plain Layout

	$m = 
\backslash
text{len}
\backslash
left(H
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$hsh =
\backslash
left
\backslash
lfloor m
\backslash
left(k
\backslash
left(
\backslash
sqrt{5}-1
\backslash
right)/2
\backslash
mod1
\backslash
right)
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$H
\backslash
left[hsh
\backslash
right]
\backslash
text{.append}
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HashRetrieve$
\backslash
left(H,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m = 
\backslash
text{len}
\backslash
left(H
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$hsh =
\backslash
left
\backslash
lfloor m
\backslash
left(k
\backslash
left(
\backslash
sqrt{5}-1
\backslash
right)/2
\backslash
mod1
\backslash
right)
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	if len$
\backslash
left( H
\backslash
left[hsh
\backslash
right]
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

		return $H
\backslash
left[hsh
\backslash
right]
\backslash
left[1
\backslash
right]$ 
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		return None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HashDelete$
\backslash
left(H,k,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m = 
\backslash
text{len}
\backslash
left(H
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$hsh =
\backslash
left
\backslash
lfloor m
\backslash
left(k
\backslash
left(
\backslash
sqrt{5}-1
\backslash
right)/2
\backslash
mod1
\backslash
right)
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$i = 1$
\end_layout

\begin_layout Plain Layout

	while $i 
\backslash
leq 
\backslash
text{len}
\backslash
left(H
\backslash
left[hsh
\backslash
right]
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

		if $H
\backslash
left[hsh
\backslash
right]
\backslash
left[i
\backslash
right] == v$:
\end_layout

\begin_layout Plain Layout

			del $H
\backslash
left[hsh
\backslash
right]
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			return
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			$i = i +1$
\end_layout

\begin_layout Plain Layout

	return "Error: $v$ not in table"	
\end_layout

\end_inset


\end_layout

\end_inset

If 
\begin_inset Formula $n$
\end_inset

 is the total number of items in the hash table and 
\begin_inset Formula $m$
\end_inset

 is the length of the hash table then on average (give uniform hashing)
 each list has 
\begin_inset Formula $\alpha=n/m$
\end_inset

 items.
 Therefore insertion is 
\begin_inset Formula $\Theta\left(1\right)$
\end_inset

, and retrieval/deletion is 
\begin_inset Formula $\Theta\left(1+\alpha\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Hashing with open addressing
\end_layout

\begin_layout Standard
In hashing with open addressing the buckets are 
\begin_inset Quotes eld
\end_inset

linearized
\begin_inset Quotes erd
\end_inset

, i.e.
 just laid out in the table itself: inserts and searches hash and then traverse
 forward in the table until they find a spot.
 Deletion is harder so if deletion is necessary then hashing with chaining
 should be used.
 Insertion costs at most 
\begin_inset Formula $1/\left(1-\alpha\right)$
\end_inset

 and for 
\begin_inset Formula $\alpha<1$
\end_inset

 retrieval costs 
\begin_inset Formula 
\[
\frac{1}{\alpha}\ln\left(\frac{1}{1-\alpha}\right)
\]

\end_inset

Integral to these bounds is that 
\begin_inset Formula $\alpha$
\end_inset

 the load factor stay small.
 In order for the amortized analysis to workout the hash table should be
 doubled in size (and entries copied) when the table becomes full but halve
 it only when the load goes down to below 
\begin_inset Formula $1/4$
\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
Hashing with open addressing
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

HashInsert$
\backslash
left(H,k,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# H is hash table, $k$ is key, $v$ is value
\end_layout

\begin_layout Plain Layout

	$m = 
\backslash
text{len}
\backslash
left(H
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$hsh =
\backslash
left
\backslash
lfloor m
\backslash
left(k
\backslash
left(
\backslash
sqrt{5}-1
\backslash
right)/2
\backslash
mod1
\backslash
right)
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$hsh_{orig} = hsh$
\end_layout

\begin_layout Plain Layout

	if $H
\backslash
left[hsh
\backslash
right] == NIL$:
\end_layout

\begin_layout Plain Layout

		$H
\backslash
left[hsh
\backslash
right] = 
\backslash
left(k,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ hsh = hsh +1 $
\end_layout

\begin_layout Plain Layout

		while $H
\backslash
left[hsh
\backslash
right] 
\backslash
neq NIL$ and $hsh 
\backslash
neq hsh_{orig}$:
\end_layout

\begin_layout Plain Layout

			# mod so it swings back around and $+1$ 
\end_layout

\begin_layout Plain Layout

			# because indexing starts at 1, not 0
\end_layout

\begin_layout Plain Layout

			$hsh = 
\backslash
left(hsh + 1 
\backslash
mod m
\backslash
right) + 1$
\end_layout

\begin_layout Plain Layout

		if $H
\backslash
left[hsh
\backslash
right] == NIL$:
\end_layout

\begin_layout Plain Layout

			$H
\backslash
left[hsh
\backslash
right] = 
\backslash
left(k,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			retun "Error: Hash table full"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HashRetrieve$
\backslash
left(H,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m = 
\backslash
text{len}
\backslash
left(H
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$hsh =
\backslash
left
\backslash
lfloor m
\backslash
left(k
\backslash
left(
\backslash
sqrt{5}-1
\backslash
right)/2
\backslash
mod1
\backslash
right)
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$hsh_{orig} = hsh$
\end_layout

\begin_layout Plain Layout

	if $H
\backslash
left[hsh
\backslash
right]
\backslash
left[1
\backslash
right] == k$:
\end_layout

\begin_layout Plain Layout

		return $H
\backslash
left[hsh
\backslash
right]
\backslash
left[2
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ hsh = hsh +1 $
\end_layout

\begin_layout Plain Layout

		while $H
\backslash
left[hsh
\backslash
right]
\backslash
left[1
\backslash
right] == k$ and $H
\backslash
left[hsh
\backslash
right] 
\backslash
neq NIL$ and $hsh 
\backslash
neq hsh_{orig}$:
\end_layout

\begin_layout Plain Layout

			# mod so it swings back around and $+1$ 
\end_layout

\begin_layout Plain Layout

			# because indexing starts at 1, not 0
\end_layout

\begin_layout Plain Layout

			$hsh = 
\backslash
left(hsh + 1 
\backslash
mod m
\backslash
right) + 1$
\end_layout

\begin_layout Plain Layout

		if $H
\backslash
left[hsh
\backslash
right] == NIL$ or $hsh == hsh_{orig}$:
\end_layout

\begin_layout Plain Layout

			return "Error: key missing"
\end_layout

\begin_layout Plain Layout

		else: 
\end_layout

\begin_layout Plain Layout

			return $H
\backslash
left[hsh
\backslash
right]
\backslash
left[2
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Binary Search Tree
\end_layout

\begin_layout Standard
A binary tree is a graph where each vertex has at most two children.
 A binary search tree is a tree with the further constraint that the key
 of a parent is greater or equal to any of the keys in its left subtree
 and less than or equal to any of the keys in its right subtree.
\end_layout

\begin_layout Standard
The working low-level data structure for trees is dict
\begin_inset Formula $\left(\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
Binary Tree
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

btree = lambda $parent$, $name$, $val$, $lchild$, $rchild$: 
\end_layout

\begin_layout Plain Layout

			  {'parent':$parent$, 'name':$name$, 'val':$val$, 
\end_layout

\begin_layout Plain Layout

			   'lchild':$lchild$, 'rchild':$rchild$}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# counter generator is for labeling
\end_layout

\begin_layout Plain Layout

def counter(x):     
\end_layout

\begin_layout Plain Layout

	start = x
\end_layout

\begin_layout Plain Layout

	while True:
\end_layout

\begin_layout Plain Layout

        yield start
\end_layout

\begin_layout Plain Layout

        start += 1
\end_layout

\begin_layout Plain Layout

$c = 
\backslash
text{counter}
\backslash
left(1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$root$ = btree(None,next$
\backslash
left(c
\backslash
right)$,$5$,None,None)
\end_layout

\begin_layout Plain Layout

$left$ = btree($root$,next$
\backslash
left(c
\backslash
right)$,$4$,None,None)
\end_layout

\begin_layout Plain Layout

$right$ = btree($root$,next$
\backslash
left(c
\backslash
right)$,$6$,None,None)
\end_layout

\begin_layout Plain Layout

$root
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = left$
\end_layout

\begin_layout Plain Layout

$root
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = right$
\end_layout

\end_inset


\end_layout

\end_inset

Note that the 
\family typewriter
name is purely 
\family default
a label and has no relation to 
\family typewriter
val
\family default
.
 The tree then looks like 
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

[level distance=1.5cm,
\end_layout

\begin_layout Plain Layout

level 1/.style={sibling distance=3.5cm},
\end_layout

\begin_layout Plain Layout

level 2/.style={sibling distance=1cm}]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{every node}=[circle,draw]
\end_layout

\begin_layout Plain Layout


\backslash
node (Root)  {5}
\end_layout

\begin_layout Plain Layout

    child {
\end_layout

\begin_layout Plain Layout

    node {4} } 
\end_layout

\begin_layout Plain Layout

	child {
\end_layout

\begin_layout Plain Layout

    node {6}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Inserting into a binary search tree
\end_layout

\begin_layout Standard
Inserting into a binary search tree is easy: the insert vertex just has
 to obey the binary search constraint: start at the root, if the root value
 is equal to the key you're inserting then go left, otherwise go right.
 Once you hit a 
\family typewriter
None 
\family default
create a new vertex.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Insert
\family default

\begin_inset Formula $\left(B,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $B$ is a btree dict as described above, corresponding to the
\end_layout

\begin_layout Plain Layout

# root of the tree
\end_layout

\begin_layout Plain Layout

$prnt = ptr = B$
\end_layout

\begin_layout Plain Layout

while $ptr 
\backslash
neq 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	# because of python's memory model we need to keep track
\end_layout

\begin_layout Plain Layout

	# of parent since names are references not pointers, i.e.
\end_layout

\begin_layout Plain Layout

	# you can't reassign pointers like in C
\end_layout

\begin_layout Plain Layout

	$ prnt = ptr$
\end_layout

\begin_layout Plain Layout

	if $ptr
\backslash
left[
\backslash
text{'val'}
\backslash
right] 
\backslash
leq k$:
\end_layout

\begin_layout Plain Layout

		$ptr = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ptr = ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

if $prnt
\backslash
left[
\backslash
text{'val'}
\backslash
right] 
\backslash
leq k$
\end_layout

\begin_layout Plain Layout

	$prnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = 
\backslash
text{btree}
\backslash
left(prnt,
\backslash
text{next}
\backslash
left(c
\backslash
right),k,
\backslash
text{None},
\backslash
text{None}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	return $prnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$prnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = 
\backslash
text{btree}
\backslash
left(prnt,
\backslash
text{next}
\backslash
left(c
\backslash
right),k,
\backslash
text{None},
\backslash
text{None}
\backslash
right)$	
\end_layout

\begin_layout Plain Layout

	return $prnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Searching a binary search tree
\end_layout

\begin_layout Standard
Searching is easy because a binary search tree obey the binary search constraint
: start at the root, if the root value is equal to the key you're searching
 for then you're done, otherwise if the key is less than the value go left,
 otherwise go right.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Search
\family default

\begin_inset Formula $\left(B,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = B$
\end_layout

\begin_layout Plain Layout

while $ptr 
\backslash
neq 
\backslash
text{None}$ and $ptr
\backslash
left[
\backslash
text{'val'}
\backslash
right] 
\backslash
neq k$:
\end_layout

\begin_layout Plain Layout

	if $ptr
\backslash
left[
\backslash
text{'val'}
\backslash
right] < k$:
\end_layout

\begin_layout Plain Layout

		$ptr = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ptr = ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

if $ptr == 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	return "Error: key missing"
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	return $ptr$	
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Binary search tree min/max
\end_layout

\begin_layout Standard
The minimum of a binary tree is the left-est most vertex.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Min
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = B$
\end_layout

\begin_layout Plain Layout

while $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] 
\backslash
neq $None:
\end_layout

\begin_layout Plain Layout

	$ptr = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

return $ptr$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The maximum of a binary tree is the right-est most vertex.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Max
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = B$
\end_layout

\begin_layout Plain Layout

while $ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] 
\backslash
neq $None:
\end_layout

\begin_layout Plain Layout

	$ptr = ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

return $ptr$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Binary search tree predecessor/successor
\end_layout

\begin_layout Standard
The predecessor of a vertex the maximum of a vertex's left subtree.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Predecessor
\family default

\begin_inset Formula $\left(B,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = 
\backslash
text{Binary-Tree-Search}
\backslash
left(B,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return Binary-Tree-Max$
\backslash
left(ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The successor of a vertex the minimum of a vertex's right subtree.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Predecessor
\family default

\begin_inset Formula $\left(B,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = 
\backslash
text{Binary-Tree-Search}
\backslash
left(B,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return Binary-Tree-Min$
\backslash
left(ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Deleting from a binary search tree
\end_layout

\begin_layout Standard
We need an auxiliary function to wrap up some code that's re-used.
 Running time is constant.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Transplant
\family default

\begin_inset Formula $\left(u,v\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# does not handle case where $u$ is root of tree
\end_layout

\begin_layout Plain Layout

$prnt = u
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

if $prnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] == u$
\end_layout

\begin_layout Plain Layout

	$prnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = v$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$prnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = v$
\end_layout

\begin_layout Plain Layout

if $v 
\backslash
neq $None:
\end_layout

\begin_layout Plain Layout

	$v
\backslash
left[
\backslash
text{'parent'}
\backslash
right] = prnt$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Deleting from a binary search tree is a little more complicated.
 Since the binary search tree property needs to be always preserved it's
 unclear what to replace a deleted vertex with.
 A child? A parent? In fact it should be the successor (or predecessor).
 The successor is the vertex whose value would follow the vertex you're
 trying to delete if you listed all the vertices in order.
 How do you find the successor? It's the minimum of the right subtree or
 the vertex (and the minimum of a tree is the farthest left of the tree).
 Then that minimum can be replaced by it's right child (it has no left child).
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Delete
\family default

\begin_inset Formula $\left(B,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = 
\backslash
text{Binary-Tree-Search}
\backslash
left(B,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# trivial case, successor is parent
\end_layout

\begin_layout Plain Layout

if $ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] == 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	Transplant$
\backslash
left(ptr,ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

elif $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] == 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	Transplant$
\backslash
left(ptr,ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$succ = 
\backslash
text{Binary-Tree-Successor}
\backslash
left(ptr
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# if the successor is the right child of $ptr$ then
\end_layout

\begin_layout Plain Layout

	# then right child has no left child and task simple
\end_layout

\begin_layout Plain Layout

	if $succ == ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		Transplant$
\backslash
left(ptr,succ
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'parent'}
\backslash
right] = succ$
\end_layout

\begin_layout Plain Layout

	else: # otherwise we have to fix successor subtrees and do the same thing
 
\end_layout

\begin_layout Plain Layout

		   # including fixing the right child
\end_layout

\begin_layout Plain Layout

		# fix successor
\end_layout

\begin_layout Plain Layout

		Transplant$
\backslash
left(succ,succ
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# don't lose right child of $ptr$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
left[
\backslash
text{'parent'}
\backslash
right] = succ$
\end_layout

\begin_layout Plain Layout

		# move successor into $ptr$'s position
\end_layout

\begin_layout Plain Layout

		Transplant$
\backslash
left(ptr,succ
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'parent'}
\backslash
right] = succ$		
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pre-order/In-order/Post-order traversal
\end_layout

\begin_layout Standard
A Pre-order/In-order/Post-order traversal of a binary tree is a traversal
 the manipulates the vertex either before left and right children, after
 the left child but before the right child, and after both the left and
 right children.
 The easiest way to implement any of these is recursion but iterative versions
 do exist.
 Running time is 
\begin_inset Formula $O\left(n\right)$
\end_inset

 since the traversal visits every vertex.
 For illustrative purposes we simply print the 
\family typewriter
val 
\family default
attribute, but any operation on the vertex could be performed.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Pre-order-traversal
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

print$
\backslash
left(B
\backslash
left[
\backslash
text{'val'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
In-order-traversal
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

print$
\backslash
left(B
\backslash
left[
\backslash
text{'val'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Post-order-traversal
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

print$
\backslash
left(B
\backslash
left[
\backslash
text{'val'}
\backslash
right]
\backslash
right)$ 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Treap
\end_layout

\begin_layout Standard
Binary trees have 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 queries and inserts and deletions if they're balanced.
 Turns out keep them balanced is tough - a ton of schemes exist.
 The simpliest is a random binary tree using a treap.
 A treap combines the invariants of a binary tree 
\emph on
and
\emph default
 and a heap.
 There are two sets of attributes: priorities and keys.
 The priorities obey the heap property (children have smaller priority than
 their parents) and the keys obey the binary search property.
 In order to get a balanced binary tree, which is the value of treaps, we
 randomly generate a priority key.
 This then simulates the generation of a random binary tree which on average
 has depth 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

.
 We use a min heap.
\end_layout

\begin_layout Subsection
Treap search
\end_layout

\begin_layout Standard
Just like for binary search tree and hence omitted.
\end_layout

\begin_layout Subsection
Treap insert
\end_layout

\begin_layout Standard
This is easier of the two operations.
 First we need two auxiliary functions 
\family typewriter
Left-Rotate
\family default
 and 
\family typewriter
Right-Rotate
\family default
.
 The easiest way to remember these is pictures
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Tree_rotation.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Left-rotate
\family default

\begin_inset Formula $\left(p\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

$p_{prnt} = p
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$a = p
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$q = p
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# put $q$ in $p$'s position
\end_layout

\begin_layout Plain Layout

if $p = p_{prnt}
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout
\noindent
\align left

	$p_{prnt}
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = q$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$p_{prnt}
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = q$
\end_layout

\begin_layout Plain Layout

$p
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = q
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$q
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = p$
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Right-rotate
\family default

\begin_inset Formula $\left(p\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

$q_{prnt} = q
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$p = q
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$c = q
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# put $p$ in $q$'s position
\end_layout

\begin_layout Plain Layout

if $q = q_{prnt}
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout
\noindent
\align left

	$q_{prnt}
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = p$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$q_{prnt}
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = p$
\end_layout

\begin_layout Plain Layout

$q
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = p
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$p
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = q$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To insert into a treap, generate a random priority, and insert the key as
 if it were a binary search tree (i.e.
 at the bottom), then rotate up until the heap property is restored.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Treap-Insert
\family default

\begin_inset Formula $\left(T,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $T$ is a binary tree that's a treap
\end_layout

\begin_layout Plain Layout

$u = 
\backslash
text{Random}
\backslash
left(0,1
\backslash
right)$ # both ends inclusive
\end_layout

\begin_layout Plain Layout
\noindent
\align left

$ptr = 
\backslash
text{Binary-Tree-Insert}
\backslash
left(T,
\backslash
left(u,k
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$prnt = ptr
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

while $prnt 
\backslash
neq 
\backslash
text{None}$ and $ptr
\backslash
left[
\backslash
text{'val'}
\backslash
right] < prnt
\backslash
left[
\backslash
text{'val'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	if $ptr == prnt
\backslash
left[
\backslash
text{'lchild}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		Right-Rotate$
\backslash
left(prnt
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		Left-Rotate$
\backslash
left(prnt
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$ptr = prnt$
\end_layout

\begin_layout Plain Layout

	$prnt = ptr
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$	
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Treap delete
\end_layout

\begin_layout Standard
To delete a vertex rotate it down until it's a leaf node and then delete
 the leaf node.
 Rotate down according to which of the vertex's children have a higher priority:
 if the left child has a higher priority than the right then rotate right,
 otherwise rotate left.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Treap-Delete
\family default

\begin_inset Formula $\left(T,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $T$ is a binary tree that's a treap
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align left

$ptr = 
\backslash
text{Binary-Tree-Search}
\backslash
left(T,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

while $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$ or $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	if $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$ and $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'val'}
\backslash
right] > ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
left[
\backslash
text{'val'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		Right-Rotate$
\backslash
left(ptr
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		Left-Rotate$
\backslash
left(ptr
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	if $ptr = ptr
\backslash
left[
\backslash
text{'parent'}
\backslash
right]
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$ptr
\backslash
left[
\backslash
text{'parent'}
\backslash
right]
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = 
\backslash
text{None}$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ptr
\backslash
left[
\backslash
text{'parent'}
\backslash
right]
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = 
\backslash
text{None}$
\end_layout

\begin_layout Plain Layout

	del $ptr$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Cartesian Tree
\end_layout

\begin_layout Standard
Given a sequence of 
\series bold
distinct
\series default
 numbers (or any totally ordered objects), there exists a binary min-heap
 whose inorder traversal is that sequence.
 This is known as the Cartesian tree for that sequence.
 A min-treap is an easy way to construct a Cartiesian tree of a sorted sequence.
 Why? Obviously: it's is heap ordered since it obeys the min heap property
 and an in order traversal reproduces the sequence in sorted order.
 How to construct a Cartesian tree for an arbitrary sequence 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

? Process the sequence values in left-to-right order, maintaining the Cartesian
 tree of the nodes processed so far, in a structure that allows both upwards
 and downwards traversal of the tree.
 To process each new value 
\begin_inset Formula $x$
\end_inset

, start at the node representing the value prior to 
\begin_inset Formula $x$
\end_inset

 in the sequence and follow the path from this node to the root of the tree
 until finding a value 
\begin_inset Formula $y$
\end_inset

 smaller than 
\begin_inset Formula $x$
\end_inset

.
 This node 
\begin_inset Formula $y$
\end_inset

 is the parent of 
\begin_inset Formula $x$
\end_inset

, and the previous right child of 
\begin_inset Formula $y$
\end_inset

 becomes the new left child of 
\begin_inset Formula $x$
\end_inset

.
 Running time is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Cartesian-Tree
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$T = 
\backslash
text{btree}
\backslash
left(
\backslash
text{None},
\backslash
text{next}
\backslash
left(c
\backslash
right),A
\backslash
left[1
\backslash
right],
\backslash
text{None},
\backslash
text{None}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ptr = prnt = T$
\end_layout

\begin_layout Plain Layout

for $i= 2:
\backslash
text{len}
\backslash
left(A
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	while $prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$ and $A
\backslash
left[i
\backslash
right] <prnt
\backslash
left[
\backslash
text{'val}
\backslash
right] $
\end_layout

\begin_layout Plain Layout

		$prnt = prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	if $prnt == 
\backslash
text{None}$: # then we're at the root
\end_layout

\begin_layout Plain Layout

		# and $A
\backslash
left[i
\backslash
right]$ is the smallest value we've seen so far
\end_layout

\begin_layout Plain Layout

		$ptr = 
\backslash
text{btree}
\backslash
left(
\backslash
text{None},
\backslash
text{next}
\backslash
left(c
\backslash
right),A
\backslash
left[i
\backslash
right],prnt,
\backslash
text{None}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right] = ptr$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ptr = 
\backslash
text{btree}
\backslash
left(prnt,
\backslash
text{next}
\backslash
left(c
\backslash
right),A
\backslash
left[i
\backslash
right],prnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right],
\backslash
text{None}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$prnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = ptr$
\end_layout

\begin_layout Plain Layout

	$prnt = ptr$
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Interval Trees
\end_layout

\begin_layout Standard
An interval tree is built atop your favotire balanced binary tree data structure
 (treap in our case) and stores left endpoints as key.
 It also keeps track of maximum right endpoint in the subtree rooted at
 a vertex.
 It supports interval intersection tests (very useful).
 Maintaining the max in insertion and deletion is straightforward during
 rotations.
\end_layout

\begin_layout Subsection
Interval search
\end_layout

\begin_layout Standard
Interval search works by being optimistic: 
\begin_inset Formula $i=\left[a,b\right]$
\end_inset

 and 
\begin_inset Formula $j=\left[x,y\right]$
\end_inset

 two intervals overlap if either 
\begin_inset Formula $a\leq x\leq b$
\end_inset

 or 
\begin_inset Formula $x\leq a\leq y$
\end_inset

.
 Therefore at each interval we test for overlap and whether 
\begin_inset Formula $x\leq a\leq y$
\end_inset

 where 
\begin_inset Formula $y$
\end_inset

 is the maximum right endpoint for any interval in the left subtree.
 If so we go left.
 If in fact 
\begin_inset Formula $y<a$
\end_inset

 then no interval in the left subtree could possibly intersect so we go
 right.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Interval-Tree-Search
\family default

\begin_inset Formula $\left(T,i\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $T$ is an interval tree, $i = 
\backslash
left[a,b
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$a,b = i
\backslash
left[1
\backslash
right],i
\backslash
left[2
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# $j
\backslash
left[
\backslash
text{'left'}
\backslash
right]$ is left endpoint of interval and 
\end_layout

\begin_layout Plain Layout

# $j
\backslash
left[
\backslash
text{'right'}
\backslash
right]$ is right endpoint
\end_layout

\begin_layout Plain Layout

intersect $=$ lamba $j$: $a 
\backslash
leq j
\backslash
left[
\backslash
text{'left'}
\backslash
right] 
\backslash
leq b$ or $j
\backslash
left[
\backslash
text{'left'}
\backslash
right] 
\backslash
leq a 
\backslash
leq j
\backslash
left[
\backslash
text{'right'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# 'int' is interval associated with vertex
\end_layout

\begin_layout Plain Layout

while $T 
\backslash
neq 
\backslash
text{None}$ and not intersect$
\backslash
left(T
\backslash
left[
\backslash
text{'int'}
\backslash
right]
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	if $T
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$ and $a 
\backslash
leq T
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'max'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$T = T
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$T = T
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

return $T$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Order Statistics Tree
\end_layout

\begin_layout Standard
Order statistics trees are probably the simplest thing to build atop a balanced
 binary search tree.
 The only extra extra piece of information each vertex stores is the attribute
 
\family typewriter
size 
\family default
where 
\begin_inset Formula $x\left[\texttt{'size'}\right]=x\left[\texttt{'lchild'}\right]\left[\texttt{'size'}\right]+x\left[\texttt{'rchild'}\right]\left[\texttt{'size'}\right]+1$
\end_inset

.
\end_layout

\begin_layout Subsection
Select
\end_layout

\begin_layout Standard
Finding the 
\begin_inset Formula $i$
\end_inset

th ordered element in the tree works just like Quickselect
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
OS-Select
\family default

\begin_inset Formula $\left(T,i\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $T$ is an interval tree, $i$ is the rank we're looking for
\end_layout

\begin_layout Plain Layout

$r = T
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'size'}
\backslash
right] + 1 $
\end_layout

\begin_layout Plain Layout

if $i == r$:
\end_layout

\begin_layout Plain Layout

	return $x$
\end_layout

\begin_layout Plain Layout

elif $i < r$:
\end_layout

\begin_layout Plain Layout

	return OS-Select$
\backslash
left(T
\backslash
left[
\backslash
text{'lchild'}
\backslash
right],i
\backslash
right)$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	return OS-Select$
\backslash
left(T
\backslash
left[
\backslash
text{'rchild'}
\backslash
right],i-r
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rank
\end_layout

\begin_layout Standard
We can find the rank of an element by finding how many elements are to its
 left.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
OS-Rank
\family default

\begin_inset Formula $\left(T,x\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$x$ is a pointer to a vertex in the tree
\end_layout

\begin_layout Plain Layout

$r  = x
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'size'}
\backslash
right] + 1 $
\end_layout

\begin_layout Plain Layout

$prnt = x$
\end_layout

\begin_layout Plain Layout

# while $prnt$ is not root of $T$
\end_layout

\begin_layout Plain Layout

while $prnt 
\backslash
neq T$:
\end_layout

\begin_layout Plain Layout

	if $ prnt == prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right]
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$r  = r+ prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right]
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'size'}
\backslash
right] + 1 $
\end_layout

\begin_layout Plain Layout

	$prnt = prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

return $r$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Maintenance
\end_layout

\begin_layout Standard
Maintaining 
\family typewriter
size 
\family default
is easy: for example in 
\family typewriter
Left-Rotate 
\family default
add lines 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

13 
\begin_inset Formula $y\left[\texttt{'size'}\right]=x\left[\texttt{'size'}\right]$
\end_inset


\begin_inset Newline newline
\end_inset

14 
\begin_inset Formula $x\left[\texttt{'size'}\right]=x\left[\texttt{'lchild'}\right]\left[\texttt{'size'}\right]+x\left[\texttt{'rchild'}\right]\left[\texttt{'size'}\right]+1$
\end_inset


\end_layout

\begin_layout Standard
and similarly for 
\family typewriter
Right-Rotate.
\end_layout

\begin_layout Section
Union-Find
\end_layout

\begin_layout Standard
A union-find data structure is a data structure suited for taking unions
 and finding members (duh).
 The particular units of the data structures are sets (not hash table derivative
s), each with a representative.
 The data structure is very thin, basically a wrapper for the primitive
 data, except for a pointer to the representative of the set and two heuristics
 that speed up the operations.
 The path compression heuristic 
\begin_inset Quotes eld
\end_inset

compresses
\begin_inset Quotes erd
\end_inset

 the path to representative of the set by setting it to be equal to that
 representative (which it might not be after a union).
 The weighted union heuristic makes it so that the smaller of the two sets
 unioned is the one whose representative pointers need to be updated.
\end_layout

\begin_layout Standard
Amortized complexity of 
\begin_inset Formula $n$
\end_inset

 
\family typewriter
Make-Set
\family default
, 
\family typewriter
Find-Set, Union,
\family default
 operations where 
\begin_inset Formula $m$
\end_inset

 are 
\family typewriter
Make-Set
\family default
 is 
\begin_inset Formula $O\left(m\alpha\left(n\right)\right)$
\end_inset

 where 
\begin_inset Formula $\alpha\left(n\right)$
\end_inset

 is the Ackermann function and 
\begin_inset Formula $\alpha\left(n\right)\leq4$
\end_inset

 for any realistic application.
\end_layout

\begin_layout Subsection
Make set
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Make-Set
\family default

\begin_inset Formula $\left(x\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

return {'val':$x$,'rep':$x$,'rank':0}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Find set
\end_layout

\begin_layout Standard
Find set is interesting: it unwinds the stack in order to reset all the
 representatives from 
\begin_inset Formula $x$
\end_inset

 to the representative of the set.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Find-Set
\family default

\begin_inset Formula $\left(x\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $x
\backslash
left[
\backslash
text{'rep'}
\backslash
right]
\backslash
neq x$:
\end_layout

\begin_layout Plain Layout

	$x
\backslash
left[
\backslash
text{'rep'}
\backslash
right] = 
\backslash
text{Find-Set}
\backslash
left(x
\backslash
left[
\backslash
text{'rep'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Union
\end_layout

\begin_layout Standard
Find set is interesting: it unwinds the stack in order to reset all the
 representatives from 
\begin_inset Formula $x$
\end_inset

 to the representative of the set.
 Running time is 
\begin_inset Formula $O\left(m\lg n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Union
\family default

\begin_inset Formula $\left(x,y\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$x_{rep} = 
\backslash
text{Find-Set}
\backslash
left(x
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$y_{rep} = 
\backslash
text{Find-Set}
\backslash
left(y
\backslash
right)$
\end_layout

\begin_layout Plain Layout

if $x_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right] > y_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$y_{rep}
\backslash
left[
\backslash
text{'rep'}
\backslash
right] = x_{rep}$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$x_{rep}
\backslash
left[
\backslash
text{'rep'}
\backslash
right] = y_{rep}$
\end_layout

\begin_layout Plain Layout

	if $x_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right] == y_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right] $
\end_layout

\begin_layout Plain Layout

		# it's an approximate rank.
\end_layout

\begin_layout Plain Layout

		$y_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right] = y_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right] + 1$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Euler circuit
\end_layout

\begin_layout Standard
An Euler circuit visits each vertex in graph twice - once going past it
 and once coming back across it.
 How do you print out an Euler circuit of a tree? Use a modified depth first
 traversal.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Euler-Circuit
\family default

\begin_inset Formula $\left(u\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $u$ is a vertex with children
\end_layout

\begin_layout Plain Layout

# print it going past
\end_layout

\begin_layout Plain Layout

print$
\backslash
left(u
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $v$ in $u
\backslash
left[
\backslash
text{'children'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	Euler-Circuit$
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# print is coming back
\end_layout

\begin_layout Plain Layout

	print$
\backslash
left(u
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Tarjan's Least Common Ancestor
\end_layout

\begin_layout Standard
The least common ancestor 
\begin_inset Formula $w$
\end_inset

 of two vertices 
\begin_inset Formula $u,v$
\end_inset

 in a tree is the ancestor common to both that's of greatest depth.
 The algorithm is useful for range-minimum querying.
 It uses the same traversal as 
\family typewriter
Euler-Circuit
\family default
 and the Union-Find data structure augmented with a property 
\family typewriter
ancestor
\family default
.
 The algorithm proceeds by growing 
\begin_inset Quotes eld
\end_inset

bottom up
\begin_inset Quotes erd
\end_inset

 sets corresponding to subtrees whose roots are the least common ancestors
 of any pair of vertices in the tree 
\series bold
which have been completely traversed by the Euler circuit
\series default
.
 Let 
\begin_inset Formula $P$
\end_inset

 be a global with the set of vertices you're interested in finding least
 common ancestor of and initialize all vertices to have 
\family typewriter
color 
\family default
\color blue
Blue
\color inherit
 in order to represent unfinishined (i.e.
 not completely traversed by the Euler circuit).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Least-Common-Ancestor
\family default

\begin_inset Formula $\left(u\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $u$ is the root of a tree
\end_layout

\begin_layout Plain Layout

$u_{set} = 
\backslash
text{Make-Set}
\backslash
left(u
\backslash
right)$
\end_layout

\begin_layout Plain Layout

#this is the Euler-Circuit transformation (equivalent of print)
\end_layout

\begin_layout Plain Layout

$u_{set}
\backslash
left[
\backslash
text{'ancestor'}
\backslash
right]= u$
\end_layout

\begin_layout Plain Layout

for $v$ in $u
\backslash
left[
\backslash
text{'children'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	$
\backslash
text{Least-Common-Ancestor}
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# let's pretend there's a big table where i can fetch $v_{set}$ from
\end_layout

\begin_layout Plain Layout

	Union$
\backslash
left(u_{set},v_{set}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$u_{set}
\backslash
left[
\backslash
text{'ancestor'}
\backslash
right]= u$
\end_layout

\begin_layout Plain Layout

# $u_{set}
\backslash
left[
\backslash
text{'val'}
\backslash
right] = u$
\end_layout

\begin_layout Plain Layout

$u_{set}
\backslash
left[
\backslash
text{'val'}
\backslash
right]
\backslash
left[
\backslash
text{'color'}
\backslash
right] = 
\backslash
color{red}
\backslash
text{Red}$
\end_layout

\begin_layout Plain Layout

for each $v$ such that $
\backslash
{u,v
\backslash
} 
\backslash
in P$:
\end_layout

\begin_layout Plain Layout

	if $v
\backslash
left[
\backslash
text{'color'}
\backslash
right] == 
\backslash
color{red}
\backslash
text{Red}$:
\end_layout

\begin_layout Plain Layout

		print$
\backslash
left(
\backslash
text{"Least common ancestor of } 
\backslash
{u,v
\backslash
} 
\backslash
text{ is " } + v_{set}
\backslash
left[
\backslash
text{'ancestor'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Range Minimum Queries
\end_layout

\begin_layout Standard
Given a sequence of distinct values and a subsequence (specified by it's
 end points) what is the minimum value of the in that subsequences? It's
 just the least common ancestor of the end points in the cartesian tree
 representing the sequence.
\end_layout

\begin_layout Part
Advanced Design Techniques
\end_layout

\begin_layout Section
Dynamic Programming
\end_layout

\begin_layout Standard
Note this is a fairly formal explanation of dynamic programming.
 Skip if you're not interested in formalism.
 If you want a good intuitive interpretation of Dynamic programming read
 chapter 6 of Vazirani (where he says that dynamic programming is simply
 traversing the topological sort of the problem dependency graph).
\end_layout

\begin_layout Standard
Dynamic programming does not means writing code dynamically or changing
 code dynamically or anything like that.
 The sense in which programming is being used here is the same sense as
 setting a program for an festival or something, and dynamic means making
 decisions in-situ rather than a priori.
 dynamic programming is an optimization technique - minimizing travel time,
 minimizing cost, maximizing profits, maximizing utility, et cetera.
 The central concept is the 
\series bold
Bellman equation
\series default
 so I'm going to crib here the wikipedia article on the Bellman equation
 (yes the whole thing).
 
\end_layout

\begin_layout Standard
First, any optimization problem has some objective – minimizing travel time,
 minimizing cost, maximizing profits, maximizing utility, et cetera.
 The function that describes this objective is called the 
\series bold
objective function
\series default
 or 
\series bold
cost function
\series default
,i.e.
 the travel time, cost, or profits as a function of time.
 Dynamic programming breaks a multi-period planning problem into simpler
 steps.
 Therefore, it requires keeping track of how the circumstances, as the concern
 the decision at each step, change over time.
 The information about the current situation which is needed to make a correct
 decision is called the 
\begin_inset Quotes eld
\end_inset

state".
 For example, to decide how much to consume and spend at each point in time,
 people would need to know (among other things) their initial wealth.
 Therefore, current wealth would be one of their 
\series bold
state variables
\series default
.
 The decisions made at each step are represented by 
\series bold
control variables
\series default
.

\series bold
 
\series default
For example, in the simplest case, today's wealth (the state) and how much
 is consumed (the control) determine tomorrow's wealth (the new state).
\end_layout

\begin_layout Standard
The dynamic programming approach describes the optimal plan by finding a
 rule that tells what the controls should be, given any possible value of
 the state.
 For example, if consumption 
\begin_inset Formula $c$
\end_inset

 depends only on wealth 
\begin_inset Formula $W$
\end_inset

, we would seek a rule 
\begin_inset Formula $c\left(W\right)$
\end_inset

 that gives consumption as a function of wealth.
 Such a rule, determining the controls as a function of the states, is called
 a 
\series bold
policy function
\series default
.
\end_layout

\begin_layout Standard
Finally, by definition, the optimal decision rule is the one that achieves
 the best possible value of the objective.
 For example, if someone chooses consumption, given wealth (wealth is fixed),
 in order to maximize happiness (assuming happiness 
\begin_inset Formula $H$
\end_inset

 can be represented by a function, such as a 
\series bold
utility function
\series default
), then each level of wealth will be associated with some highest possible
 level of happiness, 
\begin_inset Formula $H\left(W\right)$
\end_inset

.
 The best possible value of the objective, written as a function of the
 state, is called the 
\series bold
value function
\series default
.
\end_layout

\begin_layout Standard
I have no idea what this value function is and how it is distinct from the
 objective function (but I guess I'll find out).
\end_layout

\begin_layout Standard
Richard Bellman showed that a dynamic optimization problem in discrete time
 can be stated in a recursive, step-by-step form known as 
\series bold
backward induction
\series default
 by writing down the relationship between the value function
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This has gotta mean cost function,or imply that the value function is the
 cost function.
\end_layout

\end_inset

 in one period and the value function in the next period.
 The relationship between these two value functions is called the "Bellman
 equation".
 In this approach, the optimal policy in the final time period is specified
 in advance as a function of the state variable's value at that time, and
 the resulting optimal value of the objective function is thus expressed
 in terms of that value of the state variable.
 Next, the next-to-final period's optimization involves maximizing the sum
 of that period's period-specific objective function and the optimal value
 of the future objective function, giving that period's optimal policy contingen
t upon the value of the state variable as of the next-to-last period decision.
 This logic continues recursively back in time, until the first period decision
 rule is derived, as a function of the initial state variable value, by
 optimizing the sum of the first-period-specific objective function and
 the value of the second period's value function, which gives the value
 for all the future periods.
 Thus, each period's decision is made by explicitly acknowledging that all
 future decisions will be optimally made.
\end_layout

\begin_layout Subsection
Fibonacci Sequence
\end_layout

\begin_layout Standard
The simplest dynamic programming algorithm is computing the 
\begin_inset Formula $n$
\end_inset

th Fibonacci number faster than using the naive recursive definition
\begin_inset Formula 
\[
F_{n}=F_{n-1}+F_{n-2}
\]

\end_inset

What's the idea? Overlapping substructure: look at the 
\begin_inset Quotes eld
\end_inset

call stack
\begin_inset Quotes erd
\end_inset

 for trying to compute 
\begin_inset Formula $F_{n}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fib.png
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Look at all of the repeated calls to 
\begin_inset Formula $F_{j}$
\end_inset

.
 Rewrite the calculation so that there's no redundant work.
 There are two ways to do this: using a hashtable to memoize calls or do
 the computation bottom up.
 Running time is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Fibonacci
\family default

\begin_inset Formula $\left(n\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $n == 1$ or $n == 2$:
\end_layout

\begin_layout Plain Layout

	return $1$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$F_{k-1} = 1$
\end_layout

\begin_layout Plain Layout

	$F_{k} = 1$
\end_layout

\begin_layout Plain Layout

	$k = 2$
\end_layout

\begin_layout Plain Layout

	while $k < n$:
\end_layout

\begin_layout Plain Layout

		# k is not a parameter, subscripts are labels not indices
\end_layout

\begin_layout Plain Layout

		$F_{k+1} = F_k + F_{k-1}$
\end_layout

\begin_layout Plain Layout

		$F_k = F_{k+1}$
\end_layout

\begin_layout Plain Layout

		$F_{k-1} = F_k$
\end_layout

\begin_layout Plain Layout

		$k = k+1$ 
\end_layout

\begin_layout Plain Layout

return $F_{k+1}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rod Cutting
\end_layout

\begin_layout Standard
Given a rod of length 
\begin_inset Formula $n$
\end_inset

 and a table of price 
\begin_inset Formula $P=\left[p_{1},\dots,p_{n}\right]$
\end_inset

 corresponding to cuts at 
\begin_inset Formula $i$
\end_inset

 units of length what's the maximum value 
\begin_inset Formula $r_{n}$
\end_inset

 obtained by cutting up the rod? The naive solution is to try all 
\begin_inset Formula $2^{n-1}$
\end_inset

 partitions of the rod.
 Clearly not efficient.
 The optimal substructure of the problem is such the maximum value is the
 sum of maximum value of the potential partitions around a particular cut,
 and not cutting at all.
 Therefore the Bellman equation is
\begin_inset Formula 
\[
r_{i}=\max\left\{ p_{i},r_{1}+r_{i-1},r_{1}+r_{i-1},r_{2}+r_{i-2},\dots,r_{i-1}+r_{1}\right\} =\max_{j=1,\dots,i}\left\{ p_{i},r_{j}+r_{i-j}\right\} 
\]

\end_inset

Notice the duplication in the first expression, which corresponds to mirror
 symmetry of the rod (turning the rod around maps a cut 
\begin_inset Formula $r_{j}+r_{i-j}$
\end_inset

 to 
\begin_inset Formula $r_{i-j}+r_{j}$
\end_inset

).
 Therefore the less redundant Bellman equation is 
\begin_inset Formula 
\[
r_{i}=\max_{j<i-j}\left\{ p_{i},r_{j}+r_{i-j}\right\} 
\]

\end_inset

An equivalent formulation (all cuts of this form correspond to all cuts
 of the prior form) is one solid piece of length 
\begin_inset Formula $i$
\end_inset

 and a potentially further subdivided piece of length 
\begin_inset Formula $n-i$
\end_inset

.
 Therefore the Bellman equation is (with the 
\begin_inset Formula $r_{0}\equiv0$
\end_inset

) 
\begin_inset Formula 
\[
r_{i}=\max_{j=1,\dots,i}\left\{ p_{j}+r_{i-j}\right\} 
\]

\end_inset

The naive recursive implementation runs in 
\begin_inset Formula $O\left(2^{n}\right)$
\end_inset

 because it recomputes solutions to subproblems several times unnecessarily.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Rod-Cut-Rec
\family default

\begin_inset Formula $\left(P,n\right)$
\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $n == 0$:
\end_layout

\begin_layout Plain Layout

	return $0$
\end_layout

\begin_layout Plain Layout

$r = -
\backslash
infty$
\end_layout

\begin_layout Plain Layout

for $i = 1:n$:
\end_layout

\begin_layout Plain Layout

	$r=
\backslash
max
\backslash
left
\backslash
{ r,P
\backslash
left[i
\backslash
right]+
\backslash
text{Rod-Cut-Rec}
\backslash
left(P,n-i
\backslash
right)
\backslash
right
\backslash
} $
\end_layout

\begin_layout Plain Layout

return $r$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To speed this up you need to 
\begin_inset Quotes eld
\end_inset

memoize
\begin_inset Quotes erd
\end_inset

 redundant calls (hash table with already computed values) 
\emph on
or
\emph default
 compute values bottom up.
 The more elegant solution solution is the bottom up computation.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Bottom-Up-Rod-Cut
\family default

\begin_inset Formula $\left(P,n\right)$
\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ r = n
\backslash
cdot 
\backslash
left[0
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i = 1:n$:
\end_layout

\begin_layout Plain Layout

	$q = 0$
\end_layout

\begin_layout Plain Layout

	for $j=1:i$:
\end_layout

\begin_layout Plain Layout

		# recall $r
\backslash
left[0
\backslash
right] 
\backslash
equiv 0$
\end_layout

\begin_layout Plain Layout

		$q=
\backslash
max
\backslash
left
\backslash
{ q,P
\backslash
left[i
\backslash
right]+r
\backslash
left[i-j
\backslash
right]
\backslash
right
\backslash
} $
\end_layout

\begin_layout Plain Layout

	$r
\backslash
left[i
\backslash
right] = q$
\end_layout

\begin_layout Plain Layout

return $r
\backslash
left[n
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Getting to work
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This example is Applied Mathematical Programming by Bradley,Hax, Magnanti
 chapter 11.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a neighborhood of 
\begin_inset Formula $n$
\end_inset

 commuters and 
\begin_inset Formula $n$
\end_inset

 downtown parking lots what is the fastest way for each commuter to get
 to work given that intersection have delays?
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename commute.png
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Imagine instersections are on a rectified grid and that the cost (in time)
 of getting to intersection 
\begin_inset Formula $i,j$
\end_inset

 from some house is 
\begin_inset Formula $q\left(i,j\right)$
\end_inset

 and 
\begin_inset Formula $c\left(i,j\right)$
\end_inset

 is the time to get between intersection (left to right - one way streets).
 Seems like you'd have to start at the end (parking lots) and work backwards
 right? But no in fact this problem has optimal substructure
\begin_inset Formula 
\[
q\left(i,j\right)=\begin{cases}
\infty & j<1\text{ or }j>n\\
c\left(i,j\right) & i=1\\
\min\left\{ q\left(i-1,j-1\right),q\left(i-1,j+1\right)\right\} +c\left(i,j\right) & \text{otherwise}
\end{cases}
\]

\end_inset

Starting from any particular household 
\begin_inset Formula $\left(1,j\right)$
\end_inset

 we can compute the shortest path cost to any parking lot by forward iteration.
 Running time is 
\begin_inset Formula $O\left(nk\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Shortest-Path-Parkin
\family default
g
\begin_inset Formula $\left(A,c\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $A$ is an $n
\backslash
times k$ grid (or something like that)
\end_layout

\begin_layout Plain Layout

# and $c$ is the associated costs with getting
\end_layout

\begin_layout Plain Layout

# to the intersection
\end_layout

\begin_layout Plain Layout

$ n = 
\backslash
text{len}
\backslash
left(A
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$q = n
\backslash
cdot
\backslash
left[n
\backslash
cdot
\backslash
left[
\backslash
infty
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	# initialize first hop intersections
\end_layout

\begin_layout Plain Layout

	$q
\backslash
left[1,i
\backslash
right] = c
\backslash
left[1,i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=2:n$:
\end_layout

\begin_layout Plain Layout

	for $j=1:n$:
\end_layout

\begin_layout Plain Layout

		# i'll let you figure out how to 
\end_layout

\begin_layout Plain Layout

		# bumper the $q$ array so that 
\end_layout

\begin_layout Plain Layout

		# when $i,j=1$ the entries
\end_layout

\begin_layout Plain Layout

		# $q
\backslash
left[i-1,j-1
\backslash
right] = 
\backslash
infty$
\end_layout

\begin_layout Plain Layout

		$q
\backslash
left[i,j
\backslash
right] = 
\backslash
min
\backslash
left
\backslash
{ q
\backslash
left[i-1,j-1
\backslash
right],q
\backslash
left[i-1,j+1
\backslash
right] 
\backslash
right
\backslash
} +c
\backslash
left[i,j
\backslash
right] $
\end_layout

\begin_layout Plain Layout

return $q$
\end_layout

\end_inset


\end_layout

\end_inset

In order to return the actual path to any parking garage just modify the
 
\family typewriter
for
\family default
 loop to keep track of which of 
\begin_inset Formula $q\left(i-1,j-1\right)$
\end_inset

 or 
\begin_inset Formula $q\left(i-1,j+1\right)$
\end_inset

 was chosen in the min.
\end_layout

\begin_layout Subsection
Towers of Hanoi
\end_layout

\begin_layout Standard
Move all the disks from the left rod to the far right one only one disk
 (top disk) at a time.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Tower_of_Hanoi.jpeg
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This problem has optimal substructure in that there's no real difference
 between any of the rods or disks: so moving 
\begin_inset Formula $n$
\end_inset

 disks from the first rod to the third involves moving 
\begin_inset Formula $n-1$
\end_inset

 disks (from some rod) to the third rod.
 The solution is purely recursive: let 
\begin_inset Formula $S\left(n,h,t\right)$
\end_inset

 be the solution to moving 
\begin_inset Formula $n$
\end_inset

 disks from their 
\begin_inset Quotes eld
\end_inset

home
\begin_inset Quotes erd
\end_inset

 rod 
\begin_inset Formula $h$
\end_inset

 to a target rod 
\begin_inset Formula $t$
\end_inset

.
 Then 
\begin_inset Formula 
\[
S\left(1,h,t\right)=\text{just move the disk}
\]

\end_inset

and 
\begin_inset Formula 
\begin{eqnarray*}
S\left(n,h,t\right) & = & \text{first }S\left(n-1,h,\text{not}\left(h,t\right)\right)\\
 &  & \text{second }S\left(1,h,t\right)\\
 &  & \text{third }S\left(n-1,\text{not}\left(h,t\right),t\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(2^{n}\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Egg drop
\end_layout

\begin_layout Subsubsection

\series bold
2 eggs 100 floors
\end_layout

\begin_layout Standard
Suppose you have 2 eggs and a 100 story building and we want to find out
 the highest floor 
\emph on
an
\emph default
 can be dropped from safely.
 The assumptions are 
\end_layout

\begin_layout Itemize
An egg that survives a fall can be used again.
\end_layout

\begin_layout Itemize
A broken egg must be discarded.
\end_layout

\begin_layout Itemize
The effect of a fall is the same for all eggs.
\end_layout

\begin_layout Itemize
If an egg breaks when dropped from some floor, then it will break if dropped
 from higher floors.
\end_layout

\begin_layout Itemize
If an egg survives a fall, then it would survive a fall from a lower floor.
\end_layout

\begin_layout Standard
Starting from the 14th floor is the best strategy because the number of
 attempts (in the worst case) is always 14.
 Why? If the first egg breaks at the 14th floor then you have to check floors
 1 through 13 with the second egg for a total of 14 floors.
 If the egg doesn't break then move to the 27th floor.
 If it breaks then you have to check floors 15 through 26 for a total of
 
\begin_inset Formula $13+1=14$
\end_inset

.
 Then move to the 39th floor and etc.
 The sequence of floors is 
\begin_inset Formula $14,27,39,50,60,69,77,84,90,95,99,100$
\end_inset

.
 If the egg breaks at any point before getting to floor 100 you have to
 test 13 more floors.
 If it doesn't break until the 100th floor then you have to perform only
 12 drops.
\end_layout

\begin_layout Subsubsection

\series bold
2 eggs 
\begin_inset Formula $k$
\end_inset

 floors
\end_layout

\begin_layout Standard
Suppose that for the best strategy, the number of drops in the worst case
 is 
\begin_inset Formula $x$
\end_inset

.
 Then, you should start at the 
\begin_inset Formula $x$
\end_inset

th floor.
 If the first egg breaks then you have 
\begin_inset Formula $x-1$
\end_inset

 floors to check for a total of 
\begin_inset Formula $1+\left(x-1\right)=x$
\end_inset

 floors to check.
 If it doesn't break then you should check 
\begin_inset Formula $x+\left(x-1\right)$
\end_inset

th floor.
 If it breaks then with the second egg you have to check floors 
\begin_inset Formula $x+1,x+2,\dots,\left(x+\left(x-1\right)-1\right)$
\end_inset

, for a total of 
\begin_inset Formula 
\[
\left(x+\left(x-1\right)-1\right)-\left(x+1\right)+1=x-2
\]

\end_inset

plus the drop at floor 
\begin_inset Formula $x$
\end_inset

 and floor 
\begin_inset Formula $x+\left(x-1\right)$
\end_inset

 makes for a total of 
\begin_inset Formula $x$
\end_inset

 drops.
\end_layout

\begin_layout Standard
What's actually happening is assuming that using the best strategy the minimum
 number of drops is 
\begin_inset Formula $x$
\end_inset

 we are searching for the best strategy that covers all of the floors.
 Suppose the minimum number of attempts, in the worst case, while using
 the best strategy is 
\begin_inset Formula $x$
\end_inset

.
 How many floors can we cover?
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x+\left(x-1\right)+\left(x-2\right)+\cdots+2+1=\frac{x\left(x+1\right)}{2}
\]

\end_inset

So we need 
\begin_inset Formula 
\[
\frac{x\left(x+1\right)}{2}\geq k
\]

\end_inset

or 
\begin_inset Formula 
\[
x=\left\lceil \frac{-1+\sqrt{1+8k}}{2}\right\rceil 
\]

\end_inset

which for 
\begin_inset Formula $k=100$
\end_inset

 implies 
\begin_inset Formula $x=14$
\end_inset

.
\end_layout

\begin_layout Subsubsection

\series bold
N eggs, k floors
\end_layout

\begin_layout Standard
Suppose you have 
\begin_inset Formula $n$
\end_inset

 eggs, 
\begin_inset Formula $h$
\end_inset

 consecutive floors to be tested, and you drop an egg at floor 
\begin_inset Formula $i$
\end_inset

 in this sequence of 
\begin_inset Formula $h$
\end_inset

 floors.
 If the egg breaks then the problem reduces to 
\begin_inset Formula $n-1$
\end_inset

 eggs and 
\begin_inset Formula $i-1$
\end_inset

 remaining floors.
 If the egg doesn't break then the problem reduces to 
\begin_inset Formula $n$
\end_inset

 eggs and 
\begin_inset Formula $h-i$
\end_inset

 remaining floors.
 This is the optimal substructure of the problem: the floors we want to
 test are irrelevant, only their quantity.
 Let 
\begin_inset Formula $W\left(n,h\right)$
\end_inset

 be the minimum number of drops required to find the threshold floor in
 the worst case, while using the best strategy.
 Then 
\begin_inset Formula 
\[
W\left(n,h\right)=1+\min_{i=1,\dots,h}\left(\max\left\{ W\left(n-1,i-1\right),W\left(n,h-i\right)\right\} \right)
\]

\end_inset

If you have only one egg then the minimum number of tests using the best
 strategy (the one that potentially covers all the floors), if the threshold
 floor, is the top one is 
\begin_inset Formula $h$
\end_inset

.
 So 
\begin_inset Formula $W\left(1,h\right)=h$
\end_inset

.
 If there's only 1 floor we only need 1 egg so 
\begin_inset Formula $W\left(n,1\right)=1$
\end_inset

, and if there are no floors then we need 0 eggs so 
\begin_inset Formula $W\left(n,0\right)=0$
\end_inset

.
 Running time is 
\begin_inset Formula $O\left(nh^{2}\right)$
\end_inset

 because of the min over 
\begin_inset Formula $i=1,\dots,h$
\end_inset

.
 Since 
\begin_inset Formula $W\left(n-1,i-1\right)$
\end_inset

 is increasing in 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $W\left(n,h-i\right)$
\end_inset

 is decreasing in 
\begin_inset Formula $i$
\end_inset

 a local min of 
\begin_inset Formula $g\left(i\right)=\max\left\{ W\left(n-1,i-1\right),W\left(n,h-i\right)\right\} $
\end_inset

 is a global min and so you can use binary search so speed the min loop
 to get a running time of 
\begin_inset Formula $O\left(nh\log h\right)$
\end_inset

.
 But there's an even faster solution.
 Recall that 
\begin_inset Formula 
\[
\binom{n}{k}=\frac{n!}{k!\left(n-k\right)!}
\]

\end_inset

and
\begin_inset Formula 
\[
\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}
\]

\end_inset

Let 
\begin_inset Formula $f\left(d,n\right)$
\end_inset

 be the number of floors we can cover using 
\begin_inset Formula $n$
\end_inset

 eggs and with 
\begin_inset Formula $d$
\end_inset

 remaining drops.
 If the egg breaks we will be able to cover 
\begin_inset Formula $f\left(d-1,n-1\right)$
\end_inset

 floors and otherwise 
\begin_inset Formula $f\left(d-1,n\right)$
\end_inset

.
 Hence
\begin_inset Formula 
\[
f\left(d,n\right)=1+f\left(d-1,n-1\right)+f\left(d-1,n\right)
\]

\end_inset

Solving for 
\begin_inset Formula $f$
\end_inset

 solves the problem.
 Let 
\begin_inset Formula $g\left(d,n\right)=f\left(d,n+1\right)-f\left(d,n\right)$
\end_inset

 (an auxiliary function).
 Then substituting in the recurrence relation for 
\begin_inset Formula $f\left(d,n\right)$
\end_inset

 we get
\begin_inset Formula 
\[
g\left(d,n\right)=g\left(d-1,n\right)+g\left(d-1,n-1\right)
\]

\end_inset

which is the recurrence relation for the binomial coefficient, and so it
 seems that 
\begin_inset Formula $g\left(d,n\right)=\binom{d}{n}$
\end_inset

.
 Problem is 
\begin_inset Formula $f\left(0,n\right)=0$
\end_inset

 for all 
\begin_inset Formula $n$
\end_inset

 and so should 
\begin_inset Formula $g\left(0,n\right)$
\end_inset

 but 
\begin_inset Formula $g\left(0,0\right)=\binom{0}{0}=1$
\end_inset

.
 Defining 
\begin_inset Formula $g\left(d,n\right)=\binom{d}{n+1}$
\end_inset

 the recursion is still satisfied and no contradictions.
 
\end_layout

\begin_layout Standard
Now to solve the problme: using a telescoping sum for 
\begin_inset Formula $f\left(d,n\right)$
\end_inset


\begin_inset Formula 
\begin{eqnarray*}
f\left(d,n\right) & = & \left[f\left(d,n\right)-f\left(d,n-1\right)\right]\\
 & + & \left[f\left(d,n-1\right)-f\left(d,n-2\right)\right]\\
 &  & \vdots\\
 & + & \left[f\left(d,1\right)-f\left(d,0\right)\right]\\
 & + & f\left(d,0\right)
\end{eqnarray*}

\end_inset

where 
\begin_inset Formula $f\left(d,0\right)=0$
\end_inset

 we get that 
\begin_inset Formula 
\begin{eqnarray*}
f\left(d,n\right) & = & g\left(d,n-1\right)+g\left(d,n-2\right)+\cdots+g\left(d,0\right)\\
 & = & \binom{d}{n}+\binom{d}{n-1}+\cdots+\binom{d}{1}\\
 & = & \sum_{i=1}^{n}\binom{d}{i}
\end{eqnarray*}

\end_inset

So we just have to find 
\begin_inset Formula $d$
\end_inset

 such that 
\begin_inset Formula 
\[
\sum_{i=1}^{N}\binom{d}{i}\geq k
\]

\end_inset

which can be done in linear time using the relation 
\begin_inset Formula 
\[
\binom{a}{b+1}=\binom{a}{b}\frac{a-b}{b+1}
\]

\end_inset


\end_layout

\begin_layout Subsection
Maximum Positive Subarray/Kidane's algorithm
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

, how to find the subarray with the maximum positive sum? Use dynamic programmin
g solution called Kidane's algorithm.
 Change the problem to look at maximum sum subarray ending at some 
\begin_inset Formula $j$
\end_inset

.
 Maximum sum subarray ending at 
\begin_inset Formula $j$
\end_inset

 is either empty, i.e.
 has negative sum, in which case its sum is 0, or includes 
\begin_inset Formula $A\left[j\right]$
\end_inset

.
 The maximum sum subarray in all of 
\begin_inset Formula $A$
\end_inset

 is the maximum of all subarrays ending at all 
\begin_inset Formula $j$
\end_inset

.
 Running time is 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Kidane-Max-Subarray
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $m$_  is max
\end_layout

\begin_layout Plain Layout

$m_{here} = m_{all} = A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=2:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	$m_{here} = 
\backslash
max
\backslash
left(0,m_{here}+A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m_{all} = 
\backslash
max
\backslash
left(m_{all},m_{here}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $m_{all}$
\end_layout

\end_inset


\end_layout

\end_inset

Note that if at 
\begin_inset Formula $j-1$
\end_inset

 the subarray was empty, and hence 
\begin_inset Formula $m_{here}=0$
\end_inset

 then at 
\begin_inset Formula $j$
\end_inset

 it's the case that 
\begin_inset Formula $m_{here}=A\left[j\right]$
\end_inset

.
 In order to recover the actual subarray you need to keep track of whether
 counting is reset or subarray is extended.
 Easiest way to do this is using Python tricks.
 In general this is calling keeping 
\begin_inset Quotes eld
\end_inset

back-pointers
\begin_inset Quotes erd
\end_inset

 and works in all such cases for reconstructing the solution (forthwith
 omitted).
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Kidane-Max-Subarray-Mod
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$m_{here} = m_{all} = 
\backslash
left[[~],A
\backslash
left[1
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=2:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	# take max wrt.
 first entry of arguments, i.e.
 $
\backslash
max
\backslash
left(0,m_{here}+A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m_{here}=
\backslash
max
\backslash
left(
\backslash
left[0,[~]
\backslash
right],
\backslash
left[m_{here}+A
\backslash
left[i
\backslash
right],m_{here}
\backslash
text{.append}
\backslash
left(A
\backslash
left[i
\backslash
right]
\backslash
right)
\backslash
right] ,
\backslash
text{key=itemgetter}
\backslash
left(1
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m_{all} = 
\backslash
max
\backslash
left(m_{all},m_{here},
\backslash
text{key=itemgetter}
\backslash
left(1
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $m_{all}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Longest increasing subsequence
\end_layout

\begin_layout Standard
A subsequence of a sequence 
\begin_inset Formula $A=\left[a_{1},a_{2},\dots,a_{n}\right]$
\end_inset

 need not be contiguous.
 Just like in Kidane's algorithm you should be looking at subsequences ending
 at some index 
\begin_inset Formula $i$
\end_inset

: let 
\begin_inset Formula $L\left[i\right]$
\end_inset

 be the longest strictly increasing subsequence ending at index 
\begin_inset Formula $i$
\end_inset

.
 What's the 
\begin_inset Quotes eld
\end_inset

optimal
\begin_inset Quotes erd
\end_inset

 way to obtain 
\begin_inset Formula $L\left[i\right]$
\end_inset

? Extend some smaller optimal subsequence ending at index 
\begin_inset Formula $j$
\end_inset

.
 But when can you extend some subsequence ending at position 
\begin_inset Formula $j$
\end_inset

? Only when 
\begin_inset Formula $A\left[j\right]<A\left[i\right]$
\end_inset

 since it should be an increasing subsequence! Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
LIS
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(A
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$L = n
\backslash
cdot
\backslash
left[
\backslash
infty
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	$L
\backslash
left[i
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

	for $j=1:i-1$:
\end_layout

\begin_layout Plain Layout

		if $A
\backslash
left[j
\backslash
right] < A
\backslash
left[i
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			$L
\backslash
left[i
\backslash
right] = 
\backslash
max
\backslash
left
\backslash
{L
\backslash
left[i
\backslash
right],1+L
\backslash
left[j
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

return $
\backslash
max
\backslash
left
\backslash
{L
\backslash
right
\backslash
}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Box stacking
\begin_inset Foot
status open

\begin_layout Plain Layout
From here on down I stole these from https://people.cs.clemson.edu/~bcdean/dp_pract
ice/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You have 
\begin_inset Formula $n$
\end_inset

 boxes 
\begin_inset Formula $B=\left[b_{1},\dots,b_{n}\right]$
\end_inset

 with dimensions height 
\begin_inset Formula $h_{i}$
\end_inset

, width 
\begin_inset Formula $w_{i}$
\end_inset

, and depth 
\begin_inset Formula $d_{i}$
\end_inset

.
 What's the tallest stack of boxes you can make? A box 
\begin_inset Formula $b_{i}$
\end_inset

 can be stacked atop another box 
\begin_inset Formula $b_{j}$
\end_inset

 if 
\begin_inset Formula $b_{i}$
\end_inset

 can oriented such that one of its faces is smaller than the upwarding face
 of 
\begin_inset Formula $b_{j}$
\end_inset

.
 To simplify the problem simply 
\begin_inset Quotes eld
\end_inset

replicate
\begin_inset Quotes erd
\end_inset

 the boxes such that one box with dimensions 
\begin_inset Formula $h_{i},w_{i},d_{i}$
\end_inset

 corresponds to 3 boxes
\begin_inset Formula 
\begin{eqnarray*}
h_{i},w_{i},d_{i} & = & h_{i},w_{i},d_{i}\\
h_{i}^{'},w_{i}^{'},d_{i}^{'} & = & w_{i},d_{i},h_{i}\\
h_{i}^{''},w_{i}^{''},d_{i}^{''} & = & d_{i},h_{i},w_{i}
\end{eqnarray*}

\end_inset

where without loss of generality (i.e.
 fix an orientation of the base 
\begin_inset Formula $w_{i}\times d_{i}$
\end_inset

) we require 
\begin_inset Formula $w_{i}\leq d_{i}$
\end_inset

.
 For example if we have a box of dimension 
\begin_inset Formula $1\times2\times3$
\end_inset

 then really we have 3 boxes 
\begin_inset Formula 
\begin{eqnarray*}
h_{i},w_{i},d_{i} & = & 1,2,3\\
h_{i}^{'},w_{i}^{'},d_{i}^{'} & = & 2,1,3\\
h_{i}^{''},w_{i}^{''},d_{i}^{''} & = & 3,1,2
\end{eqnarray*}

\end_inset

where the requirement that 
\begin_inset Formula $w_{i}\leq d_{i}$
\end_inset

 forces us to define 
\begin_inset Formula $h_{i}^{'},w_{i}^{'},d_{i}^{'}=2,1,3$
\end_inset

 instead of 
\begin_inset Formula $h_{i}^{'},w_{i}^{'},d_{i}^{'}=2,3,1$
\end_inset

 (which would be the same box).
 Call 
\begin_inset Formula $w_{i}\times d_{i}$
\end_inset

 the base of a box.
 So box 
\begin_inset Formula $b_{i}$
\end_inset

 can be stacked atop 
\begin_inset Formula $b_{j}$
\end_inset

 if the base of box 
\begin_inset Formula $b_{i}$
\end_inset

 is smaller than the base of box 
\begin_inset Formula $b_{j}$
\end_inset

.
 This is quite similar to the longest increasing subsequence substructure
 except the relation is geometric rather than simple magnitude: instead
 of just 
\begin_inset Formula $A\left[j\right]<A\left[i\right]$
\end_inset

 we have that 
\begin_inset Formula $w_{i}<w_{j}\,\wedge\,d_{i}<d_{j}$
\end_inset

.
 So what's the algorithm? First sort the boxes (the 
\begin_inset Formula $3n$
\end_inset

 boxes) by decreasing base dimension.
 Why? We didn't do that for the longest increasing subsequence problem right?
 Well the natural ordering of the LIS is the order it's given to us in;
 it's in the statement of the problem that we should look for the longest
 increasing subsequence of the given sequence.
 The boxes aren't presented to us in any given order so we must impose one
 such that we're able to select a longest 
\begin_inset Quotes eld
\end_inset

increasing
\begin_inset Quotes erd
\end_inset

 subsequence, where we've redefined increasing.
 Then the rest is just like longest increasing subsequence (except for base
 comparison).
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

 just like longest increasing subsequence.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Box-Stacking
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(B
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# let's pretend this returns only the second entry, i.e.
 the $b_i$
\end_layout

\begin_layout Plain Layout

$B = 
\backslash
text{sorted}
\backslash
left(
\backslash
left[ 
\backslash
left(b
\backslash
left[
\backslash
text{'w'}
\backslash
right] 
\backslash
times b
\backslash
left[
\backslash
text{'d'}
\backslash
right],b 
\backslash
right) 
\backslash
text{for }b
\backslash
text{ in } B
\backslash
right],
\backslash
text{key}=
\backslash
text{itemgetter}
\backslash
left(1
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$L = n
\backslash
cdot
\backslash
left[
\backslash
infty
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	$L
\backslash
left[i
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

	for $j=1:i-1$:
\end_layout

\begin_layout Plain Layout

		if $B
\backslash
left[j
\backslash
right]
\backslash
left[
\backslash
text{'w'}
\backslash
right] < B
\backslash
left[i
\backslash
right]
\backslash
left[
\backslash
text{'w'}
\backslash
right]$ and $B
\backslash
left[j
\backslash
right]
\backslash
left[
\backslash
text{'d'}
\backslash
right] < B
\backslash
left[i
\backslash
right]
\backslash
left[
\backslash
text{'d'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			$L
\backslash
left[i
\backslash
right] = 
\backslash
max
\backslash
left
\backslash
{L
\backslash
left[i
\backslash
right],1+L
\backslash
left[j
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

return $
\backslash
max
\backslash
left
\backslash
{L
\backslash
right
\backslash
}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Bridge crossings
\end_layout

\begin_layout Standard
You have a river crossing a state with 
\begin_inset Formula $n$
\end_inset

 cities on the south bank and 
\begin_inset Formula $n$
\end_inset

 corresponding cities on the north bank (not necessarily in the same order).
 You want to build as many bridges connecting corresponding cities as possible
 without building bridges that intersect.
 Let 
\begin_inset Formula $x_{i}$
\end_inset

 be the index of the city on the north shore corresponding to the 
\begin_inset Formula $i$
\end_inset

th city on the south shore.
 You can figure this out if you're just given the two lists, i.e.
 integer array 
\begin_inset Formula $S=\left[1,2,\dots,n\right]$
\end_inset

 to label the southshore cities and integer array 
\begin_inset Formula $N=\left[\sigma\left(1\right),\sigma\left(2\right),\dots,\sigma\left(n\right)\right]$
\end_inset

 for the permutation on the northshore, by sorting the northshore array
 (while keeping track which index the elements get sorted 
\series bold
from
\series default
 - think about it and you'll understand).
 Then you just need to find the longest increasing subsequence of the 
\begin_inset Formula $x_{i}$
\end_inset

 array.
 Why? A maximal matching with the already sorted sequence of cities on the
 southshore is exactly what that is - in fact this is a pretty good model
 of increasing subsequence period.
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

 just like longest increasing subsequence.
\end_layout

\begin_layout Subsection
Integer Knapsack
\end_layout

\begin_layout Standard
You're a thief with a knapsack that has a finite capacity 
\begin_inset Formula $C$
\end_inset

.
 You break into a store that has 
\begin_inset Formula $n$
\end_inset

 items with integer sizes 
\begin_inset Formula $s_{i}$
\end_inset

 and values 
\begin_inset Formula $v_{i}$
\end_inset

.
 Which items should you steal? You can only take whole items and you're
 allowed duplicates.
 The subproblems here are filling smaller knapsacks duh.
 So let 
\begin_inset Formula $M\left(j\right)$
\end_inset

 be the maximum value obtained by filling a knapsack with capacity exactly
 
\begin_inset Formula $j$
\end_inset

.
 The maximum value 
\begin_inset Formula $j$
\end_inset

 capacity knapsack that can be constructed is either equal to the maximum
 
\begin_inset Formula $j-1$
\end_inset

 capacity knapsack that can be constructed or it includes item 
\begin_inset Formula $i$
\end_inset

 and all of the items in the 
\begin_inset Formula $j-s_{i}$
\end_inset

 capacity knapsack.
 Therefore the Bellman equation is
\begin_inset Formula 
\[
M\left(j\right)=\max\left\{ M\left(j-1\right),\max_{i}\left\{ M\left(i-1,j-s_{i}\right)+v_{i}\right\} \right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(nC\right)$
\end_inset

 because you compute 
\begin_inset Formula $C$
\end_inset

 entries but each computation considers 
\begin_inset Formula $n$
\end_inset

 items.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Integer-Knapsack
\family default

\begin_inset Formula $\left(S,V,C\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $S$ is an array of integer sizes, $V$ is an array of values,
\end_layout

\begin_layout Plain Layout

# and $C$ is the capacity of the knapsack
\end_layout

\begin_layout Plain Layout

$M = C
\backslash
cdot
\backslash
left[0
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $j=1:C$:
\end_layout

\begin_layout Plain Layout

	$M
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right] = 
\backslash
max
\backslash
left
\backslash
{M
\backslash
left[j-1
\backslash
right],M
\backslash
left[i-1
\backslash
right]
\backslash
left[j-S
\backslash
left[i
\backslash
right]
\backslash
right] + V
\backslash
left[i
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

return $M
\backslash
left[C
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
0/1 Knapsack
\end_layout

\begin_layout Standard
In this instance you can only take whole items (that's the 0/1) and there
 are no duplicates.
 The subproblems here are the optimal value for filling a knapsack with
 capacity exactly 
\begin_inset Formula $j$
\end_inset

 and with some subset of the items 
\begin_inset Formula $1,\dots,i$
\end_inset

.
 
\begin_inset Formula $M\left(i,j\right)$
\end_inset

 either includes items 
\begin_inset Formula $i$
\end_inset

, in which case it includes all of the items of the optimal knapsack over
 the items 
\begin_inset Formula $1,\dots,i-1$
\end_inset

, with capacity 
\begin_inset Formula $j-s_{i}$
\end_inset

, and in which case it has value 
\begin_inset Formula $M\left(i-1,j-s_{i}\right)+v_{i}$
\end_inset

, or it does not include item 
\begin_inset Formula $i$
\end_inset

, in which case it has capacity 
\begin_inset Formula $j$
\end_inset

 and has value 
\begin_inset Formula $M\left(i-1,j\right)$
\end_inset

.
 Hence the Bellman equation is 
\begin_inset Formula 
\[
M\left(i,j\right)=\max\left\{ M\left(i-1,j\right),M\left(i-1,j-s_{i}\right)+v_{i}\right\} 
\]

\end_inset

Then the solution to the whole problem is not 
\begin_inset Formula $M\left(n,C\right)$
\end_inset

 but 
\begin_inset Formula $\max_{j}\left\{ M\left(n,j\right)\right\} $
\end_inset

 because you might not need to use the entire capacity.
 Running time is still 
\begin_inset Formula $O\left(nC\right)$
\end_inset

 because there are 
\begin_inset Formula $n\times C$
\end_inset

 subproblems.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
0-1Knapsack
\family default

\begin_inset Formula $\left(S,V,C\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $S$ is an array of integer sizes, $V$ is an array of integer values,
\end_layout

\begin_layout Plain Layout

# and $C$ is the capacity of the knapsack
\end_layout

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(S
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$M = n
\backslash
cdot
\backslash
left[C
\backslash
cdot
\backslash
left[0
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	for $j=1:C$:
\end_layout

\begin_layout Plain Layout

		$M
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right] = 
\backslash
max
\backslash
left
\backslash
{M
\backslash
left[i-1
\backslash
right]
\backslash
left[j
\backslash
right],M
\backslash
left[i-1
\backslash
right]
\backslash
left[j-S
\backslash
left[i
\backslash
right]
\backslash
right] + V
\backslash
left[i
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

return $
\backslash
max
\backslash
left
\backslash
{M
\backslash
left[n
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Balanced Partition
\end_layout

\begin_layout Standard
You get 
\begin_inset Formula $n$
\end_inset

 integers 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

, each in the range 
\begin_inset Formula $0,\dots,k$
\end_inset

, and the goal is to partition 
\begin_inset Formula $A$
\end_inset

 into two sets 
\begin_inset Formula $S_{1},S_{2}$
\end_inset

 minimizing 
\begin_inset Formula $\left|\text{sum}\left(S_{1}\right)-\text{sum}\left(S_{2}\right)\right|$
\end_inset

.
 This is similar to the knapsack problem (probably for the same reason that
 general knapsack is reducible to subset sum).
 The analogy is between capacity and summing to some 
\begin_inset Formula $j$
\end_inset

 and items from the set 
\begin_inset Formula $A$
\end_inset

 playing the role of store items.
 Let 
\begin_inset Formula $P\left(i,j\right)$
\end_inset

 be a boolean that reports whether some subset of 
\begin_inset Formula $\left[a_{1},\dots,a_{i}\right]$
\end_inset

 sum to 
\begin_inset Formula $j$
\end_inset

.
 Then 
\begin_inset Formula $P\left(i,j\right)=1$
\end_inset

 if some subset of 
\begin_inset Formula $\left[a_{1},\dots,a_{i-1}\right]$
\end_inset

 sum to 
\begin_inset Formula $j$
\end_inset

, in which case we don't need to include item 
\begin_inset Formula $i$
\end_inset

, or if some subset of 
\begin_inset Formula $\left[a_{1},\dots,a_{i-1}\right]$
\end_inset

 sums to 
\begin_inset Formula $j-a_{i}$
\end_inset

, in which case we include item 
\begin_inset Formula $a_{i}$
\end_inset

 to get a subset that sums to 
\begin_inset Formula $j$
\end_inset

.
 Hence the Bellman equation is 
\begin_inset Formula 
\[
P\left(i,j\right)=\begin{cases}
1 & \text{if }P\left(i-1,j\right)=1\text{ or }P\left(i-1,j-a_{i}\right)=1\\
0 & \text{otherwise}
\end{cases}
\]

\end_inset

More succinctly 
\begin_inset Formula 
\[
P\left(i,j\right)=\max\left\{ P\left(i-1,j\right),P\left(i-1,j-a_{i}\right)\right\} 
\]

\end_inset

Note this is just a logical or, i.e.
 ||.
 There are 
\begin_inset Formula $n^{2}k$
\end_inset

 problems because 
\begin_inset Formula $i$
\end_inset

 range from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset

 but each 
\begin_inset Formula $a_{i}$
\end_inset

 could have value 
\begin_inset Formula $k$
\end_inset

 so 
\begin_inset Formula $j$
\end_inset

 ranges from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $nk$
\end_inset

.
 How do you use this to solve the original problem? Let 
\begin_inset Formula $S=\sum a_{i}/2$
\end_inset

.
 Then the subset 
\begin_inset Formula $S_{j}$
\end_inset

 such that 
\begin_inset Formula 
\[
\min_{j\leq S}\left\{ S-j\big|P\left(n,j\right)=1\right\} 
\]

\end_inset

produces the solution.
 Running time is the same 
\begin_inset Formula $O\left(n^{2}k\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Longest common subsequence
\end_layout

\begin_layout Standard
Given two strings 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 and 
\begin_inset Formula $B=\left[b_{1},\dots,b_{m}\right]$
\end_inset

 what is the longest common subsequence? Let 
\begin_inset Formula $Z=\left[z_{1},\dots,z_{k}\right]$
\end_inset

 be such a longest common subsequence.
 Working backwards: if 
\begin_inset Formula $a_{n}=b_{m}$
\end_inset

 then 
\begin_inset Formula $z_{k}=a_{n}=b_{m}$
\end_inset

 and 
\begin_inset Formula $\left[z_{1},\dots,z_{k-1}\right]$
\end_inset

 is a longest common subsequence of 
\begin_inset Formula $\left[a_{1},\dots,a_{n-1}\right]$
\end_inset

 and 
\begin_inset Formula $\left[b_{1},\dots,b_{m-1}\right]$
\end_inset

.
 Suppose that the two sequences 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 do not end in the same symbol.
 Then the longest common subsequence of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 is the longer of the two sequences LCS
\begin_inset Formula $\left(\left[a_{1},\dots,a_{n}\right],\left[b_{1},\dots,b_{m-1}\right]\right)$
\end_inset

 and LCS
\begin_inset Formula $\left(\left[a_{1},\dots,a_{n-1}\right],\left[b_{1},\dots,b_{m}\right]\right)$
\end_inset

.
 Why? Consider the two following sequences: 
\begin_inset Formula $A=\left[123467\right]$
\end_inset

 and 
\begin_inset Formula $B=\left[23470\right]$
\end_inset

.
 The LCS of these two sequences either ends with a 7 (the last element of
 sequence 
\begin_inset Formula $A$
\end_inset

) or does not.
 If the LCS does end with a 7 then it cannot end with 0, thus we can discard
 the 0 on the end of 
\begin_inset Formula $B$
\end_inset

 and LCS
\begin_inset Formula $\left(A,B\right)=\text{LCS}\left(A,\left[2347\right]\right)$
\end_inset

.
 If it does not end in 7 then we can similarly discard 7 and LCS
\begin_inset Formula $\left(A,B\right)=\text{LCS}\left(\left[123467\right],\left[23470\right]\right)$
\end_inset

.
 In either case we're considering either LCS
\begin_inset Formula $\left(\left[a_{1},\dots,a_{n}\right],\left[b_{1},\dots,b_{m-1}\right]\right)$
\end_inset

 or LCS
\begin_inset Formula $\left(\left[a_{1},\dots,a_{n-1}\right],\left[b_{1},\dots,b_{m}\right]\right)$
\end_inset

, and in fact the longest of the two.
 Hence the Bellman equation is
\begin_inset Formula 
\[
\text{LCS}\left(\left[a_{1},\dots,a_{i}\right],\left[b_{1},\dots,b_{j}\right]\right)=\begin{cases}
0 & \text{if }i=0\text{ or }j=0\\
\text{LCS}\left(\left[a_{1},\dots,a_{i-1}\right],\left[b_{1},\dots,b_{j-1}\right]\right)+1 & \text{if }a_{i}=b_{j}\\
\max\left\{ LCS\left(\left[a_{1},\dots,a_{i}\right],\left[b_{1},\dots,b_{j-1}\right]\right),\left(\left[a_{1},\dots,a_{i-1}\right],\left[b_{1},\dots,b_{j}\right]\right)\right\}  & \text{if }a_{i}\neq b_{j}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(nm\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Edit distance
\end_layout

\begin_layout Standard
Given two strings 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 and 
\begin_inset Formula $B=\left[b_{1},\dots,b_{m}\right]$
\end_inset

 what is minimum the 
\begin_inset Quotes eld
\end_inset

cost
\begin_inset Quotes erd
\end_inset

 of transforming one string into the other, where the costs associated with
 insertion, deletion, and replacement are 
\begin_inset Formula $C_{i},C_{d},C_{r}$
\end_inset

 respectively.
 The subproblems here are similar to those in longest common subsequence.
 Let 
\begin_inset Formula $T\left(i,j\right)$
\end_inset

 be the minimum cost of transforming 
\begin_inset Formula $\left[a_{1},\dots,a_{i}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j}\right]$
\end_inset

.
 There are 4 ways to transform 
\begin_inset Formula $\left[a_{1},\dots,a_{i}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j}\right]$
\end_inset

: either delete 
\begin_inset Formula $a_{i}$
\end_inset

 and transform 
\begin_inset Formula $\left[a_{1},\dots,a_{i-1}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j}\right]$
\end_inset

, transform 
\begin_inset Formula $\left[a_{1},\dots,a_{i}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j-1}\right]$
\end_inset

 then insert 
\begin_inset Formula $b_{j}$
\end_inset

, or replace 
\begin_inset Formula $a_{i}$
\end_inset

 with 
\begin_inset Formula $b_{j}$
\end_inset

 and then transform 
\begin_inset Formula $\left[a_{1},\dots,a_{i-1}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j-1}\right]$
\end_inset

.
 Finally if 
\begin_inset Formula $a_{i}=b_{j}$
\end_inset

 then just transform 
\begin_inset Formula $\left[a_{1},\dots,a_{i-1}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j-1}\right]$
\end_inset

.
 Therefore the Bellman equation is
\begin_inset Formula 
\[
T\left(i,j\right)=\min\left\{ C_{d}+T\left(i-1,j\right),T\left(i,j-1\right)+C_{i},T\left(i-1,j-1\right)+C_{r},T\left(i-1,j-1\right)\text{ if }a_{i}=b_{j}\right\} 
\]

\end_inset

Running time is 
\begin_inset Formula $O\left(nm\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Counting Boolean Parenthesizations
\end_layout

\begin_layout Standard
Given a boolean expression with 
\begin_inset Formula $n$
\end_inset

 literals and 
\begin_inset Formula $n-1$
\end_inset

 operators how many different ways are there to parenthesize such that the
 expression evaluates to true.
 Let 
\begin_inset Formula $T\left(i,j\right)$
\end_inset

 be the number of ways to parenthesize literal 
\begin_inset Formula $i$
\end_inset

 through 
\begin_inset Formula $j$
\end_inset

 such that the subexpression evaluates to true and 
\begin_inset Formula $F\left(i,j\right)$
\end_inset

 to be the number of ways such that the subexpression evaluates to false.
 The base cases 
\begin_inset Formula $T\left(i,i\right),F\left(i,i\right)$
\end_inset

 are just function of the literals.
 Note that 
\begin_inset Formula $i<j$
\end_inset

 so we then seek to compute 
\begin_inset Formula $T\left(i,i+1\right),F\left(i,i+1\right),T\left(i,i+2\right),F\left(i,i+2\right)$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

.
 How? Well 
\begin_inset Formula $T\left(i,j\right)$
\end_inset

 is always a function of two subexpression and the operand between them:
 the literals from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

 and from 
\begin_inset Formula $k+1$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

.
 For example if the operand is 
\begin_inset Formula $\wedge$
\end_inset

 then 
\begin_inset Formula $T\left(i,j\right)>T\left(i,k\right)\cdot T\left(k+1,j\right)$
\end_inset

 since the expression including the literals from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

 will be true for any values of the subexpression from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

 which evaluate to true and any values of the subexpression 
\begin_inset Formula $k+1$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

 which evaluate to true.
 If the operator were 
\begin_inset Formula $\vee$
\end_inset

 then it would be 
\begin_inset Formula $T\left(i,k\right)\cdot T\left(k+1,j\right)+T\left(i,k\right)\cdot F\left(k+1,j\right)+F\left(i,k\right)\cdot T\left(k+1,j\right)$
\end_inset

.
 And we need to sum over all possible splits 
\begin_inset Formula $k$
\end_inset

.
 So the Bellman equation is 
\begin_inset Formula 
\[
T\left(i,j\right)=\sum_{i\leq k\leq j-1}\begin{cases}
T\left(i,k\right)\cdot T\left(k+1,j\right) & \text{if }k\text{th operator is }\wedge\\
T\left(i,k\right)\cdot T\left(k+1,j\right)+T\left(i,k\right)\cdot F\left(k+1,j\right)+F\left(i,k\right)\cdot T\left(k+1,j\right) & \text{if }k\text{th operator is }\vee\\
T\left(i,k\right)\cdot F\left(k+1,j\right)+F\left(i,k\right)\cdot T\left(k+1,j\right) & \text{\text{if }k\text{th operator is }xor}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(n^{3}\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Coin game
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $n$
\end_inset

 coins layed out in a row with values 
\begin_inset Formula $v_{1},\dots,v_{n}$
\end_inset

 you play a game against an opponent where on each turn you pick up one
 of the two outside coins.
 The goal is to maximize the sum of the value of the selected coins.
 Let 
\begin_inset Formula $V\left(i,j\right)$
\end_inset

 be the maximum value you can 
\series bold
definitely 
\series default
win if it's your turn and only the voince 
\begin_inset Formula $v_{i},\dots,v_{j}$
\end_inset

 remain.
 The base cases 
\begin_inset Formula $V\left(i,i\right)$
\end_inset

 and 
\begin_inset Formula $V\left(i,i+1\right)$
\end_inset

 are easily to compute.
 We seek to compute 
\begin_inset Formula $V\left(i,i+2\right)$
\end_inset

 and etc.
 We need to think two steps ahead to compute arbitrary 
\begin_inset Formula $V\left(i,j\right)$
\end_inset

: if we pick 
\begin_inset Formula $v_{i}$
\end_inset

 then our opponent will either pick the 
\begin_inset Formula $j$
\end_inset

th coin of the 
\begin_inset Formula $i+1$
\end_inset

th coin.
 Reasoning conservatively (the opponent will pick the better) we will be
 presented with the minimum possible scenario of coins 
\begin_inset Formula $i+1,\dots,j-1$
\end_inset

 and 
\begin_inset Formula $i+2,\dots,j$
\end_inset

.
 If we pick 
\begin_inset Formula $v_{j}$
\end_inset

 then similarly we will be presented with the minimum possible scenario
 of coins 
\begin_inset Formula $i,\dots,j+2$
\end_inset

 and 
\begin_inset Formula $i+1,\dots,j-1$
\end_inset

.
 Therefore the Bellman equation is
\begin_inset Formula 
\[
V\left(i,j\right)=\max\left\{ \underset{\text{pick }v_{i}}{\underbrace{\min\left\{ V\left(i+1,j-1\right),V\left(i+2,j\right)\right\} +v_{i}}},\underset{\text{pick }v_{j}}{\underbrace{\min\left\{ V\left(i,j+2\right),V\left(i+1,j-1\right)\right\} +v_{j}}}\right\} 
\]

\end_inset


\end_layout

\begin_layout Section
Greedy Algorithms
\end_layout

\begin_layout Standard
Greedy algorithms are like dynamic programming algorithms except there's
 only one subproblem.
 They're a lot easier to construct than DP algorithms (but take a little
 arguing to prove they're correct).
\end_layout

\begin_layout Subsection
Activity scheduling
\end_layout

\begin_layout Standard
Suppose you have a set of activities 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 with sorted start times 
\begin_inset Formula $S=\left[s_{1},\dots,s_{n}\right]$
\end_inset

and sorted finish times 
\begin_inset Formula $F=\left[f_{1},\dots,f_{n}\right]$
\end_inset

.
 How to schedule the most non-overlapping acitivities? Let 
\begin_inset Formula $S_{ij}$
\end_inset

 be the set of activities that start after 
\begin_inset Formula $a_{i}$
\end_inset

 finishes and end before 
\begin_inset Formula $a_{j}$
\end_inset

 starts.
 Standard DP argument (partitioning around a parking activity 
\begin_inset Formula $a_{k}$
\end_inset

 leads to the Bellman equation for 
\begin_inset Formula $C\left(i,j\right)$
\end_inset

 the maximal number of activities is
\begin_inset Formula 
\[
C\left(i,j\right)=\begin{cases}
0 & \text{\text{if }}S_{ij}=\emptyset\\
\max_{a_{k}\in S_{ij}}\left\{ C\left(i,k\right)+C\left(k,j\right)+1\right\}  & \text{\text{if }}S_{ij}\neq\emptyset
\end{cases}
\]

\end_inset

Then memoize or bottom-up it and you have an 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

 DP algorithm.
 But there's an obvious greedy algorithm: always pick the job that doesn't
 overlap with already picked jobs and ends the soonest.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Greedy-Activity
\family default

\begin_inset Formula $\left(A,S,F\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ n = 
\backslash
text{len}
\backslash
left(S
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# assume $a_1$ is the job that ends first
\end_layout

\begin_layout Plain Layout

$ J = 
\backslash
left[A
\backslash
left[1
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$ k = 1$
\end_layout

\begin_layout Plain Layout

for $m = 2:n$:
\end_layout

\begin_layout Plain Layout

	if $F
\backslash
left[k
\backslash
right] 
\backslash
leq S
\backslash
left[m
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$J
\backslash
text{.append}
\backslash
left(A
\backslash
left[m
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$k = m$
\end_layout

\begin_layout Plain Layout

return $A$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Fractional Knapsack
\end_layout

\begin_layout Standard
This is the same as Integer Knapsack but you can take fractions of items
 (imagine you broke into a spice shop).
 The greedy strategy that optimally picks items is one that chooses items
 that give most bang per weight, a kind of value density: pick as much of
 the item that has the highest 
\begin_inset Formula $v_{i}/w_{i}$
\end_inset

 until it's exhausted.
 Then continue on to the next most value dense item.
\end_layout

\begin_layout Subsection
Huffman codes
\end_layout

\begin_layout Standard
What's the most optimal way to encode a message using a 
\begin_inset Formula $\left\{ 0,1\right\} $
\end_inset

 code given the distribution over the input alphabet? Letters that appear
 most often should have the smallest code words and conversely letters that
 appear rarely should have the longest code words.
 Using prefix-free codes (codes such that no codeword is a prefix of any
 other codeword) we can achieve optimal compression so without loss of generalit
y we can use them, and we will since they make things easiest.
 
\end_layout

\begin_layout Standard
Given the frequency distribution 
\begin_inset Formula $C$
\end_inset

 we can construct a binary tree called a Huffman tree whose traversal produces
 the prefix-free codes using a min-queue.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Huffman-Tree
\family default

\begin_inset Formula $\left(C\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ n = 
\backslash
text{len}
\backslash
left(C
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# "cast" $C$ to be a min-priority-queue
\end_layout

\begin_layout Plain Layout

$ Q = 
\backslash
text{minQueue}
\backslash
left(C
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $i = 1:n-1$:
\end_layout

\begin_layout Plain Layout

	$z = 
\backslash
text{btree}
\backslash
left(
\backslash
text{None},
\backslash
text{next}
\backslash
left(c
\backslash
right),
\backslash
text{None},
\backslash
text{None},
\backslash
text{None}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$z
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = x =  
\backslash
text{Extract-Min}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$z
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = y =  
\backslash
text{Extract-Min}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# 'val' is character frequency
\end_layout

\begin_layout Plain Layout

	$z
\backslash
left[
\backslash
text{'val'}
\backslash
right] = x
\backslash
left[
\backslash
text{'val'}
\backslash
right] + y
\backslash
left[
\backslash
text{'val'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	Insert$
\backslash
left(Q,z
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# return root of tree
\end_layout

\begin_layout Plain Layout

return Extract-Min$
\backslash
left(Q
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset

Running time is 
\begin_inset Formula $O\left(n\log n\right)$
\end_inset

 due to the min-queue operations.
 Constructing the codes is done by performing a depth-first traversal of
 the Huffman tree and keeping track of lefts and rights (zeros and ones).
\end_layout

\begin_layout Subsection
Making change with unlimited coins
\end_layout

\begin_layout Standard
Consider the problem of making change for 
\begin_inset Formula $n$
\end_inset

 cents using the fewest number of coins 
\begin_inset Formula $K=\left[c_{1},\dots,c_{k}=1\right]$
\end_inset

.
 Assume each coin's value is an integer.
 If the coins are the US quarters, dimes, nickels, and pennies then a greedy
 algorith is optimal: change as much for quarters as you can, then as much
 for dimes, etc.
 The greedy strategy does not always work: suppose the coins are of denomination
 
\begin_inset Formula $4\cent,3\cent,1\cent$
\end_inset

 to change 
\begin_inset Formula $6\cent$
\end_inset

.
 In general you need to use dynamic programming - solution is similar to
 integer knapsack with duplicates.
 Let 
\begin_inset Formula $C\left(i\right)$
\end_inset

 be the optimal number of coins used to make change for 
\begin_inset Formula $i\cent$
\end_inset

 using any of the coins.
 The minimum number of coins needed to change 
\begin_inset Formula $i$
\end_inset

 is 1 plus 
\begin_inset Formula $C\left(i-c_{j}\right)$
\end_inset

 where 
\begin_inset Formula $c_{j}$
\end_inset

 is the coin denomination that minimizes 
\begin_inset Formula $C\left(i-c_{j}\right)$
\end_inset

 and 
\begin_inset Formula $c_{j}<i$
\end_inset

.
 Therefore the Bellman equation is 
\begin_inset Formula 
\[
C\left(i\right)=\min_{j}\left\{ C\left(i-c_{j}\right)\bigg|c_{j}<i\right\} +1
\]

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(nk\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Making change with fixed coins
\end_layout

\begin_layout Standard
Here is another solution.
 I don't understand why there should be another solution but here it is.
 Suppose the coins come sorted in decreasing order so 
\begin_inset Formula $c_{1}>c_{2}>\cdots>c_{k}=1$
\end_inset

.
 Let 
\begin_inset Formula $C\left(i,j\right)$
\end_inset

 be the optimal number of coins used to make change for 
\begin_inset Formula $i\cent$
\end_inset

 using only coins 
\begin_inset Formula $j,\dots,k$
\end_inset

.
 We either use coin 
\begin_inset Formula $c_{j}$
\end_inset

 or we don't.
 If we do not then we're solving the problem 
\begin_inset Formula $C\left(i,j+1\right)$
\end_inset

.
 For example we might not use coin 
\begin_inset Formula $c_{j}$
\end_inset

 if 
\begin_inset Formula $c_{j}>i$
\end_inset

.
 If we do use coin 
\begin_inset Formula $c_{j}$
\end_inset

 then the rest 
\begin_inset Formula $\left(i-c_{j}\right)\cent$
\end_inset

 needs to be changed, potentially using the coin 
\begin_inset Formula $j$
\end_inset

 again.
 
\begin_inset Formula 
\[
C\left(i,j\right)=\begin{cases}
C\left(i,j+1\right) & \text{if }c_{j}>i\\
\min_{j}\left\{ C\left(i,j+1\right),C\left(i-c_{j},j\right)+1\right\}  & \text{if }c_{j}\leq i
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Running time is also 
\begin_inset Formula $O\left(nk\right)$
\end_inset

.
\end_layout

\begin_layout Part
Graph Algorithms
\end_layout

\begin_layout Section
Representations of Graphs
\end_layout

\begin_layout Standard
There are two ways to represent a graph 
\begin_inset Formula $G=\left(E,V\right)$
\end_inset

: 
\series bold
adjacency matrix
\series default
 and 
\series bold
adjacency list
\series default
.
 
\end_layout

\begin_layout Subsection
Adjaceny matrix
\end_layout

\begin_layout Standard
The former is a table with 
\begin_inset Formula $n=\left|V\right|$
\end_inset

 rows and 
\begin_inset Formula $n$
\end_inset

 columns and with an entry in row 
\begin_inset Formula $i$
\end_inset

 column 
\begin_inset Formula $j$
\end_inset

 if there's an edge between vertex 
\begin_inset Formula $i$
\end_inset

 and vertex 
\begin_inset Formula $j$
\end_inset

.
 The value of the entry could be anything from simply 1 to indicate an undirecte
d edge, 
\begin_inset Formula $-1$
\end_inset

 to represent a directed edge, 
\begin_inset Formula $k$
\end_inset

 to represent an edge weight, 
\begin_inset Formula $0$
\end_inset

 to represent no edge.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Adjacency-Matrix
\family default

\begin_inset Formula $\left(n,E\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# n is the number of vertices, $E$ is the edge list (a list of tuples)
\end_layout

\begin_layout Plain Layout

# default is directed (so double edges indicate undirected)
\end_layout

\begin_layout Plain Layout

$mat = n
\backslash
cdot
\backslash
left[n
\backslash
cdot
\backslash
left[0
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $u,v,w$ in $E$:
\end_layout

\begin_layout Plain Layout

	$mat
\backslash
left[u
\backslash
right]
\backslash
left[v
\backslash
right] = w$
\end_layout

\begin_layout Plain Layout

return $mat$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Adjacency list
\end_layout

\begin_layout Standard
The latter is a list of lists where the 
\begin_inset Formula $i$
\end_inset

 entry in the list is a list containing all 
\begin_inset Formula $j$
\end_inset

 such that edge 
\begin_inset Formula $\left(i,j\right)\in E$
\end_inset

.
 Most algorithms in this section will use the adjacency list representation.
 Further more we assume that other attributes will be stored in a hash table
 keyed on the vertex 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

, which is a number.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Adjacency-list
\family default

\begin_inset Formula $\left(n,E\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# n is the number of vertices, $E$ is the edge list (a list of tuples)
\end_layout

\begin_layout Plain Layout

# default is directed (so double edges indicate undirected
\end_layout

\begin_layout Plain Layout

$adj = n
\backslash
cdot
\backslash
left[
\backslash
left[~
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $u,v,w$ in $E$:
\end_layout

\begin_layout Plain Layout

	$adj
\backslash
left[u
\backslash
right]
\backslash
text{.append}
\backslash
left(
\backslash
left(v,w
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $adj$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Transpose
\end_layout

\begin_layout Standard
The transpose graph 
\begin_inset Formula $G^{T}=\left(V,E^{T}\right)$
\end_inset

 where 
\begin_inset Formula $\left(u,v\right)\in E^{T}$
\end_inset

 iff 
\begin_inset Formula $\left(v,u\right)\in E^{T}$
\end_inset

, i.e.
 reverse all the arrows.
 Computing the transpose graph when a graph is represented by an adjacency
 matrix amounts to just transposing the matrix.
 When the original graph is represented by adjacency lists it's a little
 more complicated but pretty obvious regardless.
\end_layout

\begin_layout Section
Breadth-first Search
\end_layout

\begin_layout Standard
A bread-first search is exactly what it sounds like: all vertices at a certain
 breadth (distance) are visited, then the next breadth, then the next breadth,
 and so on.
 In order to repeatedly the same vertices we need to keep track of which
 vertices we've visited.
 The most elegant way is to "decorate" by constructing tuples 
\begin_inset Formula $\left(i,visited\right)$
\end_inset

 and unpacking.
 An easier way is to just have a hash table that stores that attribute.
 Running time is 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Breadth-first-search
\family default

\begin_inset Formula $\left(s\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $A$ is an adjacency list and $s$ is a source 
\end_layout

\begin_layout Plain Layout

# from which to start searching.
 'state' $=0$ means unvisited,
\end_layout

\begin_layout Plain Layout

# $=1$ means visited but not explored, $=2$ means explored
\end_layout

\begin_layout Plain Layout

$attrs = 
\backslash
{i:
\backslash
{
\backslash
text{'state':0},
\backslash
text{'d':}
\backslash
infty,
\backslash
text{'prnt':None}
\backslash
}
\end_layout

\begin_layout Plain Layout

			
\backslash
text{ for } i=1:n 
\backslash
}$ 
\end_layout

\begin_layout Plain Layout

$attrs
\backslash
left[s
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

$attrs
\backslash
left[s
\backslash
right]
\backslash
left[
\backslash
text{'d'}
\backslash
right] = 0$
\end_layout

\begin_layout Plain Layout

$Q = 
\backslash
left[s
\backslash
right]$
\end_layout

\begin_layout Plain Layout

while len$
\backslash
left(Q
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$u = Q
\backslash
text{.popleft}
\backslash
left(
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	for each $v 
\backslash
in A
\backslash
left[u
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		if $attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] == 0$:
\end_layout

\begin_layout Plain Layout

			$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

			$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'d'}
\backslash
right] = attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'d'}
\backslash
right] + 1$
\end_layout

\begin_layout Plain Layout

			$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = u$
\end_layout

\begin_layout Plain Layout

			$Q
\backslash
text{.append}
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] = 2$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Depth-first Search
\end_layout

\begin_layout Standard
A depth-first search is exactly what it sounds like: go as deep as possible
 then back up until you can go deep again, and so on.
 For depth search we also keep track of what are called opening and closing
 times; they're useful for other algorithms like topological sort.
 Running time is 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Depth-First-Search
\family default

\begin_inset Formula $\left(s\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$attrs = 
\backslash
{i:
\backslash
{
\backslash
text{'state':0},
\backslash
text{'opentime': None},
\backslash
text{'closetime': None},
\backslash
text{'prnt':None}
\backslash
} 
\end_layout

\begin_layout Plain Layout

			
\backslash
text{ for } i=1:n 
\backslash
}$ 
\end_layout

\begin_layout Plain Layout

$time = 0$
\end_layout

\begin_layout Plain Layout

# list of vertices visited
\end_layout

\begin_layout Plain Layout

$visited = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$S = 
\backslash
left[s
\backslash
right]$
\end_layout

\begin_layout Plain Layout

while len$
\backslash
left(S
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$time = time + 1$
\end_layout

\begin_layout Plain Layout

	$u = S
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# if we come back to this point in the stack after having 
\end_layout

\begin_layout Plain Layout

	# explored the vertex that means we've visited all of its children
\end_layout

\begin_layout Plain Layout

	# and it's done
\end_layout

\begin_layout Plain Layout

	if $attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] == 2$:
\end_layout

\begin_layout Plain Layout

		$attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'closetime'}
\backslash
right] == time$
\end_layout

\begin_layout Plain Layout

		$S
\backslash
text{.popright}
\backslash
left(
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$visited
\backslash
text{.append}
\backslash
left(u
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# otherwise we need to leave it on the stack but explore it
\end_layout

\begin_layout Plain Layout

	# really this is superfluous because the only way to get on the stack
\end_layout

\begin_layout Plain Layout

	# is to concomitant with having 'state'$=1$
\end_layout

\begin_layout Plain Layout

	elif $attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] == 1$:
\end_layout

\begin_layout Plain Layout

		$attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'opentime'}
\backslash
right] == time$
\end_layout

\begin_layout Plain Layout

		for each $v 
\backslash
in A
\backslash
left[u
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			if $attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] == 0$:
\end_layout

\begin_layout Plain Layout

				$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

				$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = u$
\end_layout

\begin_layout Plain Layout

				$S
\backslash
text{.append}
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] = 2$
\end_layout

\begin_layout Plain Layout

return $visited$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Topological Sort
\end_layout

\begin_layout Standard
A topological sort of a directed acyclic graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is an ordering on 
\begin_inset Formula $V$
\end_inset

 such that if 
\begin_inset Formula $\left(u,v\right)\in E$
\end_inset

 then 
\begin_inset Formula $u$
\end_inset

 appears before 
\begin_inset Formula $v$
\end_inset

 in the ordering.
 Producing a topological sort is easy using 
\family typewriter
Depth-First-Search
\family default
: the 
\family typewriter
visited
\family default
 array already returns the topological sort! The vertex at the front of
 the list is first in topologically sorted order, the second is the second,
 and so on.
 Why does this produce a topological sort? The intuition is that the last
 vertex to close is 
\begin_inset Quotes eld
\end_inset

behind
\begin_inset Quotes erd
\end_inset

 all of the others - all of the vertices are descendents of it.
 
\end_layout

\begin_layout Standard
If the graph is connected then some vertices might be unvisited after starting
 from a particular source.
 In that case you need to run DFS on every vertex (making sure to not to
 run twice on a vertex that's already been visited).
 Running time is 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Topolgoical-Sort
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$attrs = 
\backslash
{i:
\backslash
{
\backslash
text{'state':0},
\backslash
text{'opentime': None},
\backslash
text{'closetime': None},
\backslash
text{'prnt':None}
\backslash
} 
\end_layout

\begin_layout Plain Layout

			
\backslash
text{ for } i=1:
\backslash
text{len}
\backslash
left(G
\backslash
right) 
\backslash
}$ 
\end_layout

\begin_layout Plain Layout

$time = 0$
\end_layout

\begin_layout Plain Layout

$S = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# let's pretend we have a tuple $G$ where $V$ is a hash table $
\backslash
left
\backslash
{'label':vertex
\backslash
right
\backslash
}$ where 
\end_layout

\begin_layout Plain Layout

# vertex is a pointer to the vertex and $E$ is a list of tuples $
\backslash
left(u,v
\backslash
right)$.
\end_layout

\begin_layout Plain Layout

$E,V = G$
\end_layout

\begin_layout Plain Layout

for $v 
\backslash
in V$:
\end_layout

\begin_layout Plain Layout

	if $attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] == 0$:
\end_layout

\begin_layout Plain Layout

		# let's pretend that we changed DFS to take in addition $attrs,time$
\end_layout

\begin_layout Plain Layout

		# and return $attrs,time$ and the list mentioned above
\end_layout

\begin_layout Plain Layout

		$attrs, time,tsort = 
\backslash
text{Depth-First-Search}
\backslash
left(v,attrs,time
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# concatenate to the front because all closing times are later
\end_layout

\begin_layout Plain Layout

		$S = tsort + S$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Strongly Connected Components
\end_layout

\begin_layout Standard
A connected component of a graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a subset 
\begin_inset Formula $V'\subset V$
\end_inset

 such that for every 
\begin_inset Formula $u,v\in V'$
\end_inset

 there's a path 
\begin_inset Formula $u\rightsquigarrow v$
\end_inset

 and 
\begin_inset Formula $v\rightsquigarrow u$
\end_inset

.
 How do you compute all of the connected components of a graph? A topological
 sort and DFS on the transpose graph 
\begin_inset Formula $G^{T}$
\end_inset

.
 First topological-sort all of the vertices in the graph 
\begin_inset Formula $G$
\end_inset

.
 Then DFS the transpose graph 
\begin_inset Formula $G^{T}$
\end_inset

 in the topologically sorted order produced by the topological sort 
\begin_inset Formula $G$
\end_inset

.
 Why does this work? 
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $f\left(C\right)$
\end_inset

 be the latest finishing time of a strongly connected component and 
\begin_inset Formula $C,C'$
\end_inset

 two distinct connected components.
 Then 
\begin_inset Formula $f\left(C\right)>f\left(C'\right)$
\end_inset

 and in 
\begin_inset Formula $G^{T}$
\end_inset

(which has the same strongly connected components as 
\begin_inset Formula $G$
\end_inset

) 
\begin_inset Formula $f\left(C\right)<f\left(C'\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
That means, by the contrapositive, that in 
\begin_inset Formula $G^{T}$
\end_inset

 if there's an edge between two connected components then 
\begin_inset Formula $f\left(C\right)>f\left(C'\right)$
\end_inset

.
 That's why we visit strongly connected components in topologically sorted
 order: after we discover all vertices in some strongly connected component
 
\begin_inset Formula $C$
\end_inset

 and move on to the next strongly connected component 
\begin_inset Formula $C'$
\end_inset

 the only edges out will be to 
\begin_inset Formula $C$
\end_inset

, which has had all of its vertices already marked as visited (and so the
 second DFS doesn't visit any other connected component's vertices).
 Running time is 
\begin_inset Formula $\Theta\left(V+E\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Strongly-Connected-Components
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# let's pretend tsort just returns labels: $5,4,6,1,
\backslash
dots$
\end_layout

\begin_layout Plain Layout

$tsort = 
\backslash
text{Topological-Sort}
\backslash
left(G
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$G^T = 
\backslash
text{Transpose}
\backslash
left(G
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$V',E^T = G^T$
\end_layout

\begin_layout Plain Layout

$components = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i = 1:
\backslash
text{len}
\backslash
left(G
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	$components
\backslash
text{.append}
\backslash
left(
\backslash
text{Depth-First-Search}
\backslash
left(V'
\backslash
left[tsort
\backslash
left[i
\backslash
right]
\backslash
right]
\backslash
right)
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Minimum Spanning Tree
\end_layout

\begin_layout Standard
A spanning tree of an undirected graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a tree (no cycles) that covers all the vertices: 
\begin_inset Formula $n-1$
\end_inset

 edges and there's a path there's a path 
\begin_inset Formula $u\rightsquigarrow v$
\end_inset

 and 
\begin_inset Formula $v\rightsquigarrow u$
\end_inset

 for all 
\begin_inset Formula $u,v\in V$
\end_inset

; a minimum spanning tree is defined by edges 
\begin_inset Formula $A\subset E$
\end_inset

.
 A minimum weight spanning tree is a spanning tree over a weighted graph
 such that the sum of the weights along the edges is minimal.
 The two algorithms prestend are greedy algorithms that proceed by adding
 
\series bold
safe edges
\series default
: an edge such that the tree unioned with that edge is still a minimum spanning
 tree.
 The algorithms find these safe edges in different ways.
\end_layout

\begin_layout Standard
I'm going to define some things here that will be useful later on.
 A cut 
\begin_inset Formula $\left(S,V\backslash S\right)$
\end_inset

 is a partition of 
\begin_inset Formula $V$
\end_inset

 into two disjoin sets: 
\begin_inset Formula $S$
\end_inset

 and not 
\begin_inset Formula $S$
\end_inset

.
 An edge 
\series bold
crosses
\series default
 a cut if one vertex of the edge is in 
\begin_inset Formula $S$
\end_inset

 and the other in 
\begin_inset Formula $V\backslash S$
\end_inset

.
 A cut 
\series bold
respects 
\series default
a subset 
\begin_inset Formula $A\subset E$
\end_inset

 if and no edges in 
\begin_inset Formula $A$
\end_inset

 cross the cut.
 A 
\series bold
light edge
\series default
 crossing a cut is an edge that crosses the cut and is of minimum weight.
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $A$
\end_inset

 be a subset of 
\begin_inset Formula $E$
\end_inset

 that is included in some minimum spanning tree, let 
\begin_inset Formula $\left(S,V\backslash S\right)$
\end_inset

 be any cut that respects 
\begin_inset Formula $A$
\end_inset

.
 If 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 is a light edge crossing the cut then it's safe for 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Corollary
If 
\begin_inset Formula $C=\left(V_{C},E_{C}\right)$
\end_inset

 is a connected component in the forest 
\begin_inset Formula $G_{A}=\left(V,A\right)$
\end_inset

 and 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 is a light edge connecting 
\begin_inset Formula $C$
\end_inset

 to some other component of 
\begin_inset Formula $G_{A}$
\end_inset

 then 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 is safe for 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
In actuality the two algorithms add light edges.
\end_layout

\begin_layout Subsection
Kruskal's algorithm.
\end_layout

\begin_layout Standard
Kruskal's algorithm uses the Union-Find data structure to build the minimum
 spanning tree.
 It adds edges that haven't been added to 
\begin_inset Formula $A$
\end_inset

 in increasing order by weight.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Kruskal-Minimum-Spanning-Tree
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$A = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

for $v 
\backslash
in V$:
\end_layout

\begin_layout Plain Layout

	$vsets
\backslash
text{.append}
\backslash
left(
\backslash
text{Make-Set}
\backslash
left(v
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# $
\backslash
left(u,v,w
\backslash
right) 
\backslash
in E$ where $w$ is the weight of the edge
\end_layout

\begin_layout Plain Layout

$E = 
\backslash
text{sorted}
\backslash
left(E,
\backslash
text{key}=
\backslash
text{itemgetter}
\backslash
left(3
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $u,v 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

	if $
\backslash
text{Find-Set}
\backslash
left(vset
\backslash
left[u
\backslash
right]
\backslash
right) 
\backslash
neq 
\backslash
text{Find-Set}
\backslash
left(vset
\backslash
left[v
\backslash
right]
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

		$A
\backslash
text{.append}
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{Union}
\backslash
left(vset
\backslash
left[u
\backslash
right],vset
\backslash
left[v
\backslash
right] 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $A$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Firstly the sort costs 
\begin_inset Formula $O\left(E\lg E\right)$
\end_inset

.
 The rest of the running time is a function of the running times of the
 Union-Find data structure operation running times.
 The second 
\family typewriter
for
\family default
 performs 
\begin_inset Formula $O\left(E\right)$
\end_inset

 
\family typewriter
Find-Set
\family default
 and 
\family typewriter
Union
\family default
 operations.
 Along with the 
\begin_inset Formula $O\left(V\right)$
\end_inset

 
\family typewriter
Make-Set
\family default
 operations in the first 
\family typewriter
for
\family default
 the total is 
\begin_inset Formula $O\left(\left(V+E\right)\alpha\left(V\right)\right)$
\end_inset

, where 
\begin_inset Formula $\alpha$
\end_inset

 is the Ackermann function.
 Since we assume 
\begin_inset Formula $G$
\end_inset

 is connected (otherwise it could have no spanning tree) it's the case that
 
\begin_inset Formula $E\geq V-1$
\end_inset

 and so the Union-Find operations actually take 
\begin_inset Formula $O\left(E\alpha\left(V\right)\right)$
\end_inset

.
 Then since 
\begin_inset Formula $\alpha\left(V\right)=O\left(\lg V\right)=O\left(\lg E\right)$
\end_inset

 we get that the run time is 
\begin_inset Formula $O\left(E\lg E\right)$
\end_inset

.
 Finally since 
\begin_inset Formula $\left|E\right|<\left|V\right|^{2}$
\end_inset

 we have that 
\begin_inset Formula $\lg\left(E\right)=O\left(\lg V\right)$
\end_inset

 and therefore the running time is 
\begin_inset Formula $O\left(E\lg V\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Prim's algorithm
\end_layout

\begin_layout Standard
Prim's algorithm uses a min heap to keep the sorted list of 
\begin_inset Quotes eld
\end_inset

nearest
\begin_inset Quotes erd
\end_inset

 vertices and updates approximations of farther vertices as near ones are
 explored.
 It functions very similarly to Dijkstra's shortest path algorithm (which
 is covered in the next section.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Prim-Minimum-Spanning-Tree
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$attrs = 
\backslash
{i:
\backslash
{
\backslash
text{'dist'}:
\backslash
infty,
\backslash
text{'prnt':None}
\backslash
} 
\backslash
text{ for } i=1:
\backslash
text{len}
\backslash
left(G
\backslash
right) 
\backslash
}$ 
\end_layout

\begin_layout Plain Layout

# initialize some vertex to be the nucleation point of the 
\end_layout

\begin_layout Plain Layout

# minimum spanning tree
\end_layout

\begin_layout Plain Layout

$attrs
\backslash
left[1
\backslash
right]
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = 0$
\end_layout

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

# let's pretend this minqueue is keyed on $attrs
\backslash
left[
\backslash
text{'dist'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$ Q = 
\backslash
text{minQueue}
\backslash
left(V
\backslash
right)$
\end_layout

\begin_layout Plain Layout

while $
\backslash
text{len}
\backslash
left(Q
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$u = 
\backslash
text{Extract-Min}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	for $v 
\backslash
in V
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'neighbors'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		# let's pretend $E$ is a dict like $
\backslash
left
\backslash
{
\backslash
left(u,v
\backslash
right):w
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

		# and that we can check membership in $Q$
\end_layout

\begin_layout Plain Layout

		# basically just have a bunch of dicts floating around
\end_layout

\begin_layout Plain Layout

			if $v 
\backslash
in Q$ and $E
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right] < attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'dist'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

				$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = E
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right]$
\end_layout

\begin_layout Plain Layout

				# crucially you need to be able to adjust the priority key in the min
 queue
\end_layout

\begin_layout Plain Layout

				$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = u$
\end_layout

\begin_layout Plain Layout

# minimum spanning tree is parent edges along shortest path
\end_layout

\begin_layout Plain Layout

return $
\backslash
left[ 
\backslash
left(attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'prnt'}
\backslash
right],v
\backslash
right) 
\backslash
text{ for }v
\backslash
in V
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(E\lg E\right)$
\end_inset

 for a standard implementation of a min heap but can be sped up to 
\begin_inset Formula $O\left(E+V\lg V\right)$
\end_inset

 using a Fibonacci heap.
\end_layout

\end_body
\end_document
