#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass amsart
\begin_preamble
\usepackage{tikz}
\usepackage{graphicx}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{decorations.pathreplacing}
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\branch Deleted
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part*
Note
\end_layout

\begin_layout Standard
Everything is 
\begin_inset Formula $1$
\end_inset

 indexed, despite using vaguely Pythonic syntax.
 This means 
\begin_inset Formula $A\left[\text{len}\left(A\right)\right]=A\left[-1\right]$
\end_inset

.
 Slicing is 
\begin_inset Formula $A\left[a:b\right]=\left[A_{a},A_{a+1},\dots,A_{b-1}\right]$
\end_inset

.
 Where bounds checking is obviously necessary it is omitted.
 I assume a different memory model from Python: each entry of 
\begin_inset Formula $B=\left[\left[\right]\right]$
\end_inset

 is an independent list.
 Ranges are represented using MATLAB notation 
\begin_inset Formula $1:n$
\end_inset

.
 In certain place I play fast and loose with what a dictionary is keyed
 on and whether a label is just a label or a pointer (in particular in the
 Graph Algorithms section).
 Also I iterate over a dictionary, which is possible with python's 
\family typewriter
dict.items
\family default

\begin_inset Formula $\left(\right)$
\end_inset

.
\end_layout

\begin_layout Part
Foundations
\end_layout

\begin_layout Section
Insertion Sort
\end_layout

\begin_layout Standard
Maintains the invariant that 
\begin_inset Formula $A\left[1:j-1\right]$
\end_inset

 is sorted by shifting elements right.
 Insertion sort is 
\emph on
stable
\emph default
, i.e.
 two keys already in sorted order remain in the same order at the end.
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Insertion-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

for $j=2: 
\backslash
text{len}
\backslash
left(A
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	$key=A
\backslash
left[j
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$i = j-1$
\end_layout

\begin_layout Plain Layout

	while $i>0$ and $A
\backslash
left[i
\backslash
right] > key$:
\end_layout

\begin_layout Plain Layout

		$A
\backslash
left[i+1
\backslash
right] = A
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		$i = i- 1$
\end_layout

\begin_layout Plain Layout

	# either we're one passed the left end
\end_layout

\begin_layout Plain Layout

	# or $A
\backslash
left[i
\backslash
right] 
\backslash
leq $ key and so 
\end_layout

\begin_layout Plain Layout

	# $A
\backslash
left[i+1
\backslash
right]$ is the proper place for key
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[i+1
\backslash
right] = $ key
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Selection Sort
\end_layout

\begin_layout Standard
Maintains the same invariant as Insertion Sort but does so by going forward
 and 
\emph on
selecting
\emph default
 the smallest element each time.
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Selection-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

for $j=1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[j
\backslash
right] = 
\backslash
min
\backslash
left(A
\backslash
left[j+1:
\backslash
right]
\backslash
right)$ 	
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Bubble Sort
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Bubble up
\begin_inset Quotes erd
\end_inset

 pair by pair.
 Stop when no more 
\begin_inset Quotes eld
\end_inset

bubblings
\begin_inset Quotes erd
\end_inset

 are possible.
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Bubble-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align center

$flips=$ True
\end_layout

\begin_layout Plain Layout

while flips:
\end_layout

\begin_layout Plain Layout

	$flips=$ False
\end_layout

\begin_layout Plain Layout

	for $i = 1:
\backslash
text{len}
\backslash
left(A
\backslash
right)-1$:
\end_layout

\begin_layout Plain Layout

		if $A
\backslash
left[i
\backslash
right] > A
\backslash
left[i+1
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			$A
\backslash
left[i
\backslash
right], A
\backslash
left[i+1
\backslash
right] = A
\backslash
left[i+1
\backslash
right], A
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			$flips=$ True		
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Merge Sort
\end_layout

\begin_layout Standard
Divide and conquer approach.
 Divide the array in half, recurse, combine results by merging, i.e.
 taking the smallest entry from each piece in turn.
 Base case is just an array with one element.
 Running time is 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Merge-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if len$
\backslash
left(A
\backslash
right)==1$:
\end_layout

\begin_layout Plain Layout

	return $A$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$h = 
\backslash
left
\backslash
lfloor
\backslash
frac{
\backslash
text{len}
\backslash
left(A
\backslash
right)}{2}
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$L=$ Merge-Sort$
\backslash
left(A
\backslash
left[h:
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$R=$ Merge-Sort$
\backslash
left(A
\backslash
left[1:h
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$M= 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	while len$
\backslash
left(L
\backslash
right) > 0 $ and len$
\backslash
left(R
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

		# take the minimum of the $
\backslash
left
\backslash
{L
\backslash
left[1
\backslash
right],R
\backslash
left[1
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

		# and remove it from further contention
\end_layout

\begin_layout Plain Layout

		if $L
\backslash
left[1
\backslash
right] < R
\backslash
left[1
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			$M$.append$
\backslash
left(L
\backslash
left[1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

			del $L
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			$M$.append$
\backslash
left(R
\backslash
left[1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

			del $R
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# one of $L,R$ is large by one element.
\end_layout

\begin_layout Plain Layout

	if len$
\backslash
left(L
\backslash
right) > 0 $
\end_layout

\begin_layout Plain Layout

		$M$.append$
\backslash
left(L
\backslash
left[1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else: 
\end_layout

\begin_layout Plain Layout

		$M$.append$
\backslash
left(R
\backslash
left[1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$M$.append$
\backslash
left(R
\backslash
left[-1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	return $M$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Binary search
\end_layout

\begin_layout Standard
If an array is already sorted then you can find an element in it faster
 than 
\begin_inset Formula $O\left(n\right)$
\end_inset

 time; you can find it in 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 time.
 Search in either the left side of the middle entry or the right side.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Search
\family default

\begin_inset Formula $\left(A,x\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $x == A
\backslash
left[h
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	return True
\end_layout

\begin_layout Plain Layout

elif $x < A
\backslash
left[h
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	return Binary-Search$
\backslash
left(A
\backslash
left[1:h
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	return Binary-Search$
\backslash
left(A
\backslash
left[h:
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Horner's Rule
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 the coefficients of a polynomial and a value 
\begin_inset Formula $x$
\end_inset

 a faster way to calculate 
\begin_inset Formula $p\left(x\right)$
\end_inset

 is 
\begin_inset Formula 
\[
p\left(x\right)=\sum_{k=1}^{n}a_{k}x^{k}=a_{1}+x\left(a_{2}+x\left(a_{3}+\cdots+x\left(a_{n-1}+xa_{n}\right)\right)\right)
\]

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Horners-Rule
\family default

\begin_inset Formula $\left(A,x\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$y=0$
\end_layout

\begin_layout Plain Layout

for $i = n:1$:
\end_layout

\begin_layout Plain Layout

	$y = A
\backslash
left[i
\backslash
right]+x 
\backslash
cdot y$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Reservoir Sampling
\end_layout

\begin_layout Subsection
Unweighted simple
\end_layout

\begin_layout Standard
Suppose you want to sample 
\begin_inset Formula $k$
\end_inset

 items from 
\begin_inset Formula $n$
\end_inset

 items 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 fairly, i.e.
 uniform random, 
\series bold
without replacement
\series default
, draws.
 If you have all 
\begin_inset Formula $n$
\end_inset

 items available immediately then this is simple, but if you're solving
 the problem 
\emph on
online
\emph default
 it's slightly more involved.
 For example you might not want to store all 
\begin_inset Formula $n$
\end_inset

 items.
 Put the first 
\begin_inset Formula $k$
\end_inset

 items into a 
\emph on
reservoir 
\begin_inset Formula $R$
\end_inset


\emph default
 then for item 
\begin_inset Formula $i>k$
\end_inset

 draw 
\begin_inset Formula $j\in\left\{ 1,\dots,i\right\} $
\end_inset

 inclusive.
 If 
\begin_inset Formula $i\leq k$
\end_inset

 the replace 
\begin_inset Formula $i$
\end_inset

th item.
 Running time is 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Unweighted-Reservoir-One
\family default

\begin_inset Formula $\left(A,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$R = 
\backslash
left[a_{0},a_{1},
\backslash
dots,a_{k}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=k+1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	$j = $ Random$
\backslash
left(1,i
\backslash
right)$ # both ends inclusive
\end_layout

\begin_layout Plain Layout

	if $j 
\backslash
leq k$:
\end_layout

\begin_layout Plain Layout

		$R
\backslash
left[j
\backslash
right] = A
\backslash
left[i
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Unweighted slightly more involved
\end_layout

\begin_layout Standard
Another way to do solve the same problem is to use a priority queue.
 Why complicate things? This solution generalizes to weighted sampling.
 Running time takes 
\begin_inset Formula $O\left(n\lg k\right)$
\end_inset

 because of potentially 
\begin_inset Formula $n$
\end_inset

 
\family typewriter
Extract-Min 
\family default
operations on a 
\begin_inset Formula $k$
\end_inset

 length priority queue
\family typewriter
.
\family default

\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Unweighted-Reservoir-Two
\family default

\begin_inset Formula $\left(A,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$R = $ Min-Priority-Queue
\end_layout

\begin_layout Plain Layout

for $i = 1:k$:
\end_layout

\begin_layout Plain Layout

	$u 
\backslash
sim 
\backslash
text{Uniform}
\backslash
left(0,1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# priority key is first entry in argument
\end_layout

\begin_layout Plain Layout

	$H
\backslash
text{.insert}
\backslash
left(u,A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $i=k+1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	$u 
\backslash
sim 
\backslash
text{Uniform}
\backslash
left(0,1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# $H$.min returns value of minimum without extracting
\end_layout

\begin_layout Plain Layout

	if $u < H$.min:
\end_layout

\begin_layout Plain Layout

		$H$.Extract-Min$
\backslash
left(
\backslash
right)$		
\end_layout

\begin_layout Plain Layout

		$H
\backslash
text{.insert}
\backslash
left(u,A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Weighted
\end_layout

\begin_layout Standard
Suppose the same sampling problem but each element has a weight associated
 with it.
 
\family typewriter
Unweighted-Reservoir-Two 
\family default
extends naturally (sort of).
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Weighted-Reservoir
\family default

\begin_inset Formula $\left(A,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$R = $ Min-Priority-Queue
\end_layout

\begin_layout Plain Layout

for $i = 1:k$:
\end_layout

\begin_layout Plain Layout

	$u 
\backslash
sim 
\backslash
text{Uniform}
\backslash
left(0,1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$u = u^{1/A
\backslash
left[i
\backslash
right]
\backslash
text{.weight}}$
\end_layout

\begin_layout Plain Layout

	$H
\backslash
text{.insert}
\backslash
left(u,A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $i=k+1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	$u 
\backslash
sim 
\backslash
text{Uniform}
\backslash
left(0,1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$u = u^{1/A
\backslash
left[i
\backslash
right]
\backslash
text{.weight}}$
\end_layout

\begin_layout Plain Layout

	if $u < H$.min:
\end_layout

\begin_layout Plain Layout

		$H$.Extract-Min$
\backslash
left(
\backslash
right)$		
\end_layout

\begin_layout Plain Layout

		$H
\backslash
text{.insert}
\backslash
left(u,A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Online Maximum
\end_layout

\begin_layout Standard
Suppose you wanted to compute a maximum of 
\begin_inset Formula $n$
\end_inset

 items but we can only make the selection once.
 This is similar to online sampling: fill a reservoir 
\begin_inset Formula $R$
\end_inset

 full of candidates and pick the maximum from the reservoir.
 Then after finding that maximum pick the next maximum (if one exists) that's
 higher; this will be the single selection.
 But what size should the reservoir be? Turns out if 
\begin_inset Formula $k=n/e$
\end_inset

 where 
\begin_inset Formula $e$
\end_inset

 is 
\begin_inset Formula $\exp\left(1\right)$
\end_inset

 then we'll pick the true maximum with probability at least 
\begin_inset Formula $e^{-1}.$
\end_inset

 This can be further simplified by realizing you don't need to keep the
 entire reservoir and you can return after the first forthcoming maximum
 (if one exists).
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Online-Max
\family default

\begin_inset Formula $\left(A,n\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$m = A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# these selections to count against the quota
\end_layout

\begin_layout Plain Layout

for $i = 2:
\backslash
left
\backslash
lceil n/e 
\backslash
right
\backslash
rceil$:
\end_layout

\begin_layout Plain Layout

	if $A
\backslash
left[i
\backslash
right] > m$:
\end_layout

\begin_layout Plain Layout

		$m = A
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# this one is for keeps
\end_layout

\begin_layout Plain Layout

for $i=k+1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	if $A
\backslash
left[i
\backslash
right] > m$:
\end_layout

\begin_layout Plain Layout

		return $A
\backslash
left[i
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Stable Matching
\end_layout

\begin_layout Standard
The task is given 
\begin_inset Formula $n$
\end_inset

 men and 
\begin_inset Formula $n$
\end_inset

 women, where each person has ranked all members of the opposite sex in
 order of preference, marry the men and women together such that there are
 no two people of opposite sex who would both rather have each other than
 their current partners (a stable matching).
 One question is does such a stable matching even exist? In fact it does
 and the algorithm that produces one, the Gale-Shapley algorithm, proves
 it.
 It runs in 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
 The next question is the solution optimal.
 In fact it is not.
 The algorith is simple: first each man proposes to the woman he prefers
 best and each woman accepts provisionally, i.e.
 accepts a proposal but trades up if a more desirable man proposes.
 Do this for 
\begin_inset Formula $n$
\end_inset

 rounds (or until there are no more unengaged men).
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
Matching
\begin_inset Formula $\left(P_{m},P_{w},men\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $men$ is an array of men to be matched
\end_layout

\begin_layout Plain Layout

# $P_m$ is an $n 
\backslash
times n$ preferences matrix for the men, sorted by increasing priority
\end_layout

\begin_layout Plain Layout

# $P_w$ is an $n 
\backslash
times n$ a preferences matrix for the women, sorted
\end_layout

\begin_layout Plain Layout

$matched_M = 
\backslash
{
\backslash
}$
\end_layout

\begin_layout Plain Layout

$matched_W = 
\backslash
{
\backslash
}$
\end_layout

\begin_layout Plain Layout

while len$
\backslash
left(men
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$m = men
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$w = P_m
\backslash
left(m
\backslash
right)
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	if w not in $matched_W$:
\end_layout

\begin_layout Plain Layout

		$matched_M
\backslash
left[m
\backslash
right] = w$
\end_layout

\begin_layout Plain Layout

		$matched_W
\backslash
left[w
\backslash
right] = m$
\end_layout

\begin_layout Plain Layout

		del $P_m
\backslash
left(m
\backslash
right)
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		del $men
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	else: # if $w$ is already matched
\end_layout

\begin_layout Plain Layout

		$m' = matched_W
\backslash
left[w
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		# and prefers $m$ to $m'$
\end_layout

\begin_layout Plain Layout

		if $P_w
\backslash
left[w
\backslash
right]
\backslash
left[m
\backslash
right] > P_w
\backslash
left[w
\backslash
right]
\backslash
left[m' 
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			# match $m$ with $w$
\end_layout

\begin_layout Plain Layout

			$matched_M
\backslash
left[m
\backslash
right] = w$
\end_layout

\begin_layout Plain Layout

			$matched_W
\backslash
left[w
\backslash
right] = m$
\end_layout

\begin_layout Plain Layout

			del $P_m
\backslash
left(m
\backslash
right)
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			del $men
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			# unmatch $m'$
\end_layout

\begin_layout Plain Layout

			del $matched_M
\backslash
left[m' 
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			$matched_M
\backslash
text{.append}
\backslash
left(m' 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Sorting and Order Statistics
\end_layout

\begin_layout Section
Heaps
\end_layout

\begin_layout Standard
Array Heaps
\begin_inset Foot
status open

\begin_layout Plain Layout
Heaps can be built on top of trees.
\end_layout

\end_inset

 are a data structure built on top of an array 
\begin_inset Formula $A$
\end_inset

, i.e.
 a structural invariant and a collection of functions that maintain that
 invariant.
 Heaps come in two flavors: Min heaps and Max heaps.
 The invariant for a Max heap is 
\begin_inset Formula $A\left[i\right]\leq A\left[\left\lfloor i/2\right\rfloor \right]$
\end_inset

.
 Furthermore each entry has 
\begin_inset Quotes eld
\end_inset

children
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Formula $A\left[2i\right]$
\end_inset

 is the left child and 
\begin_inset Formula $A\left[2i+1\right]$
\end_inset

 is the right child of element 
\begin_inset Formula $A\left[i\right]$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Max Heapify
\end_layout

\begin_layout Standard
To re-establish the heap property we use a procedure that fixes violations
 by switching the violator with its largest child and then recursing.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Max-Heapify
\family default

\begin_inset Formula $\left(A,i\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$largest = i$
\end_layout

\begin_layout Plain Layout

# if the left child exists and is greater then potentially switch
\end_layout

\begin_layout Plain Layout

if $ 2i 
\backslash
leq 
\backslash
text{len}
\backslash
left(A
\backslash
right)$ and $A
\backslash
left[2i
\backslash
right] > A
\backslash
left[i
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	$largest = 2i$
\end_layout

\begin_layout Plain Layout

# if the right child exists and is greater then switch
\end_layout

\begin_layout Plain Layout

if $ 2i+1 
\backslash
leq 
\backslash
text{len}
\backslash
left(A
\backslash
right)$ and $A
\backslash
left[2i+1
\backslash
right] > A
\backslash
left[largest
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	$largest = 2i+1$
\end_layout

\begin_layout Plain Layout

$A
\backslash
left[i
\backslash
right],A
\backslash
left[largest
\backslash
right] = A
\backslash
left[largest
\backslash
right],A
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# potentially fix violation between child and one of its children
\end_layout

\begin_layout Plain Layout

Max-Heapify$
\backslash
left(A,largest
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Build Max Heap
\end_layout

\begin_layout Standard
To build a heap from an array notice that the deepest children/leaves are
 already legal heaps so there's no need to 
\family typewriter
Max-Heapify 
\family default
them, and the children start at 
\begin_inset Formula $\left\lfloor \text{len}\left(A\right)/2\right\rfloor $
\end_inset

.
 Running time is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Max-Heapify
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

for $i = 
\backslash
left
\backslash
lfloor 
\backslash
text{len}
\backslash
left(A
\backslash
right)/2
\backslash
right
\backslash
rfloor:1 $:
\end_layout

\begin_layout Plain Layout

	Max-Heapify$
\backslash
left(A,i
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Extract Min
\end_layout

\begin_layout Standard
\begin_inset Formula $A\left[1\right]$
\end_inset

 is the maximum element in the heap (by the Max heap invariant), but removing
 it isn't as simple as just popping it off the top since the invariant might
 be violated.
 It's also not as simple as simple as replacing 
\begin_inset Formula $A\left[1\right]$
\end_inset

 with it's largest child because.
 The solution is to replace with the last element in the heap and then re-establ
ish the invariant.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Extract-Min
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$m = A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$A
\backslash
left[1
\backslash
right] = A
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$A
\backslash
text{.pop}
\backslash
left(
\backslash
right)$
\end_layout

\begin_layout Plain Layout

Max-Heapify$
\backslash
left(A,1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $m$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Heap sort
\end_layout

\begin_layout Standard
You can use 
\family typewriter
Extract-Min
\family default
 in the obvious way to sort an array.
 Running time is 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

.
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
HeapSort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$s = [~]$
\end_layout

\begin_layout Plain Layout

while len$
\backslash
left(A
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$s
\backslash
text{.append}
\backslash
left(
\backslash
text{Extract-Min}
\backslash
left(A
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return reversed$
\backslash
left(s
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Heap increase key
\end_layout

\begin_layout Standard
In various instances you might want to increase the position of a key in
 the heap, such as when each key corresponds to the priority of some task.
 This just involves re-establish the Max heap invariant by 
\begin_inset Quotes eld
\end_inset

percolating
\begin_inset Quotes erd
\end_inset

 the entry up the array.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Heap-Increase-Key
\family default

\begin_inset Formula $\left(A,i,key\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $key < A
\backslash
left[i
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	throw Exception$
\backslash
left(key
\backslash
text{ is smaller than current } i 
\backslash
text{ key}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$A
\backslash
left[i
\backslash
right] = key$
\end_layout

\begin_layout Plain Layout

# if child is bigger then parent then swap
\end_layout

\begin_layout Plain Layout

while $i > 1$ and $A
\backslash
left[
\backslash
left
\backslash
lfloor i/2
\backslash
right
\backslash
rfloor 
\backslash
right] < A
\backslash
left[i
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[
\backslash
left
\backslash
lfloor i/2
\backslash
right
\backslash
rfloor 
\backslash
right], A
\backslash
left[i
\backslash
right] = A
\backslash
left[i
\backslash
right], A
\backslash
left[
\backslash
left
\backslash
lfloor i/2
\backslash
right
\backslash
rfloor 
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$i = 
\backslash
left
\backslash
lfloor i/2
\backslash
right
\backslash
rfloor$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Heap insert
\end_layout

\begin_layout Standard
Using 
\family typewriter
Heap-Increase-Key
\family default
 we can insert into the heap by insert and 
\begin_inset Formula $-\infty$
\end_inset

 element at the end of the heap and then increasing the key to what we want.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Max-Heap-Insert
\family default

\begin_inset Formula $\left(A,key\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$A
\backslash
text{.append}
\backslash
left(-
\backslash
infty
\backslash
right)$
\end_layout

\begin_layout Plain Layout
\noindent
\align left

Heap-Increase-Key$
\backslash
left(A,
\backslash
text{len}
\backslash
left(A
\backslash
right),key
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Quicksort
\end_layout

\begin_layout Standard
Quicksort is experimentally the most efficient sorting algorithm.
 The randomized version runs in 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

 but is typically faster.
 It works by dividing and conquering.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Quicksort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if len$
\backslash
left(A
\backslash
right) 
\backslash
leq 1$:
\end_layout

\begin_layout Plain Layout

	return $A$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	# randomly pick a pivot
\end_layout

\begin_layout Plain Layout

	$p = 
\backslash
text{Random}
\backslash
left(1,
\backslash
text{len}
\backslash
left(A
\backslash
right)
\backslash
right)$ # inclusive
\end_layout

\begin_layout Plain Layout

	# swap so that you can exclude from contention the pivot
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[p
\backslash
right], A
\backslash
left[-1
\backslash
right] = A
\backslash
left[-1
\backslash
right], A
\backslash
left[p
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# partition
\end_layout

\begin_layout Plain Layout

	$A_{left} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e 
\backslash
leq A
\backslash
left[-1
\backslash
right] 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$A_{right} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e > A
\backslash
left[-1
\backslash
right] 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# recursively sort
\end_layout

\begin_layout Plain Layout

	$ A_{left} = 
\backslash
text{Quicksort}
\backslash
left(A_{left}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$ A_{right} = 
\backslash
text{Quicksort}
\backslash
left(A_{right}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# combine
\end_layout

\begin_layout Plain Layout

	return $A_{left} + A
\backslash
left[-1
\backslash
right]+ A_{right}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Counting Sort
\end_layout

\begin_layout Standard
The lower bound on sorting in the comparison model (i.e.
 using comparisons as an ordering relation) is 
\begin_inset Formula $\Theta\left(n\lg n\right)$
\end_inset

.
 But if one doesn't use comparisons then 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 is possible.
 Counting sort is one such 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 algorithm.
 If keys range from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

 in 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 then counting sort counts the number of keys less than or equal to each
 key 
\begin_inset Formula $a_{i}$
\end_inset

 and then places 
\begin_inset Formula $a_{i}$
\end_inset

 in that position.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Counting-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ k = 
\backslash
max
\backslash
left(A
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ C = 
\backslash
left(k+1
\backslash
right)*
\backslash
left[0
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# count how many of values from $1$ to $k$ there is
\end_layout

\begin_layout Plain Layout

for $i = 1:
\backslash
text{len}
\backslash
left(A
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	$C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right] =C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right] + 1$
\end_layout

\begin_layout Plain Layout

# count how entries in $A$ less or equal to $i$
\end_layout

\begin_layout Plain Layout

for $i = 1: k$:
\end_layout

\begin_layout Plain Layout

	$C
\backslash
left[i
\backslash
right] = C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right] + 1$
\end_layout

\begin_layout Plain Layout

# now place the items in the correct places
\end_layout

\begin_layout Plain Layout

$ B = 
\backslash
left(k+1
\backslash
right)*
\backslash
left[None
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# go in reverse direction in order for sort to be stable
\end_layout

\begin_layout Plain Layout

for $i = 
\backslash
text{len}
\backslash
left(A
\backslash
right):1$:
\end_layout

\begin_layout Plain Layout

	# $a_i$ has $C
\backslash
left[a_i
\backslash
right]$ elements to its left in $B$
\end_layout

\begin_layout Plain Layout

	$B
\backslash
left[C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right]
\backslash
right] = A
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# if there are multiples of $a_i$ then the next 
\end_layout

\begin_layout Plain Layout

	# should be left of in order for stable
\end_layout

\begin_layout Plain Layout

	$C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right] = C
\backslash
left[A
\backslash
left[i
\backslash
right]
\backslash
right] -1 $
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Radix Sort
\end_layout

\begin_layout Standard
Radix sort use the same technique that casinos use to sort cards (apparently?):
 sort stably least significant to most significant digit.
 For 
\begin_inset Formula $n$
\end_inset

 numbers in base 
\begin_inset Formula $d$
\end_inset

 where each digit ranges from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

 the running time is 
\begin_inset Formula $\Theta\left(d\left(n+k\right)\right)$
\end_inset

 if the stable sort runs in 
\begin_inset Formula $\Theta\left(n+k\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Radix-Sort
\family default

\begin_inset Formula $\left(A,d\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

for $i=1:d$:
\end_layout

\begin_layout Plain Layout

	# let's pretend i can pass Insertion-Sort a key
\end_layout

\begin_layout Plain Layout

	Insertion-Sort$
\backslash
left(A,
\backslash
text{key=}
\backslash
text{lambda }a: a
\backslash
left[-i
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Bucket Sort
\end_layout

\begin_layout Standard
Bucket sort depends on values being uniformly distributed 
\begin_inset Formula $\left[0,1\right]$
\end_inset

.
 It buckets all the entries and then subsorts.
 Expected run time is 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Bucket-Sort
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$n=
\backslash
text{len}
\backslash
left(A
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$B = n 
\backslash
cdot 
\backslash
left[
\backslash
left[~
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	# bucket (imagine $n=10$).
 
\end_layout

\begin_layout Plain Layout

	# the $+1$ is because $
\backslash
left
\backslash
lfloor 10 
\backslash
left(0.01
\backslash
right) 
\backslash
right
\backslash
rfloor = 0$
\end_layout

\begin_layout Plain Layout

	$B
\backslash
left[ 
\backslash
left
\backslash
lfloor n A
\backslash
left[i
\backslash
right] 
\backslash
right
\backslash
rfloor +1 
\backslash
right] 
\backslash
text{.append}
\backslash
left(A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	Insertion-Sort$
\backslash
left(B
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $B$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Order statistics
\end_layout

\begin_layout Subsection
Quickselect
\end_layout

\begin_layout Standard
Any sorting algorithm can be used to compute 
\begin_inset Formula $k$
\end_inset

th order statistics: simply sort and return the 
\begin_inset Formula $k$
\end_inset

th element.
 But using the ideas of 
\family typewriter
Quicksort
\family default
 you can get down to expected time 
\begin_inset Formula $O\left(n\right)$
\end_inset

: only recurse to one side.
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Quicks
\family default
elect
\begin_inset Formula $\left(A,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if len$
\backslash
left(A
\backslash
right) 
\backslash
leq 1$:
\end_layout

\begin_layout Plain Layout

	return $A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$p = 
\backslash
text{Random}
\backslash
left(1,
\backslash
text{len}
\backslash
left(A
\backslash
right)
\backslash
right)$ # inclusive
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[p
\backslash
right], A
\backslash
left[-1
\backslash
right] = A
\backslash
left[-1
\backslash
right], A
\backslash
left[p
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$A_{left} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e 
\backslash
leq A
\backslash
left[-1
\backslash
right] 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	if $k == 
\backslash
text{len}
\backslash
left(A_{left}+1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# in sorted order $A
\backslash
left[1:
\backslash
text{len}
\backslash
left(A_{left}+1
\backslash
right)
\backslash
right] = A_{left}+
\backslash
left[A
\backslash
left[-1
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		# and so the pivot is 1 "in front" of $A_{left}$
\end_layout

\begin_layout Plain Layout

		return $A
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	elif $k < 
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# the $k$th order statistic in $A$ is still the $k$th order statistic
 in $A_{left}$
\end_layout

\begin_layout Plain Layout

		return Quickselect$
\backslash
left(A_{left},k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$A_{right} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e > x
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# the $k$th order statistic is $
\backslash
left(k-
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)-1
\backslash
right)$th statistic in $A_{right}$
\end_layout

\begin_layout Plain Layout

		# think about it likes this: $A=
\backslash
left[1,2,3,4,5
\backslash
right]$ and we partition on 
\end_layout

\begin_layout Plain Layout

		# 3 and we look for the 4th order statistic.
 well obviously it's 
\end_layout

\begin_layout Plain Layout

		# $4=A_{right}
\backslash
left[k-
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)-1 
\backslash
right] = A_{right}
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		return Quickselect$
\backslash
left(A_{right},k-
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)-1
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Quickerselect
\end_layout

\begin_layout Standard
Using 
\emph on
median-of-medians
\emph default
 in order to guarantee good splits we can get down to 
\begin_inset Formula $O\left(n\right)$
\end_inset

 worst case (not just expected).
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Quickers
\family default
elect
\begin_inset Formula $\left(A,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if len$
\backslash
left(A
\backslash
right) == 0$:
\end_layout

\begin_layout Plain Layout

	return $A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	# divide into $n$ groups of 5 (except for the last one)
\end_layout

\begin_layout Plain Layout

	# and use a sort in order to get medians.
\end_layout

\begin_layout Plain Layout

	$n = 
\backslash
left
\backslash
lfloor 
\backslash
text{len}
\backslash
left(A
\backslash
right) / 5 
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$m_1 = 
\backslash
text{Insertion-Sort}
\backslash
left(A
\backslash
left[1:5+1
\backslash
right]
\backslash
right)
\backslash
left[3
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$m_2 = 
\backslash
text{Insertion-Sort}
\backslash
left(A
\backslash
left[5:10+1
\backslash
right]
\backslash
right)
\backslash
left[3
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$
\backslash
vdots$
\end_layout

\begin_layout Plain Layout

	$m_n = 
\backslash
text{Insertion-Sort}
\backslash
left(A
\backslash
left[5n:
\backslash
right]
\backslash
right)
\backslash
left[ 
\backslash
left
\backslash
lfloor 
\backslash
frac{
\backslash
text{len}
\backslash
left(A
\backslash
left[5n:
\backslash
right]
\backslash
right)}{2}  
\backslash
right
\backslash
rfloor 
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# recursively compute median of medians and use it as the pivot
\end_layout

\begin_layout Plain Layout

	# after this recursive call the pivot is in position $
\backslash
left
\backslash
lfloor n/2 
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$
\backslash
text{Quickerselect}
\backslash
left(
\backslash
left[m_1,m_2,
\backslash
dots,m_n
\backslash
right], 
\backslash
left
\backslash
lfloor n/2 
\backslash
right
\backslash
rfloor
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$A
\backslash
left[
\backslash
left
\backslash
lfloor n/2 
\backslash
right
\backslash
rfloor
\backslash
right], A
\backslash
left[-1
\backslash
right] = A
\backslash
left[-1
\backslash
right], A
\backslash
left[
\backslash
left
\backslash
lfloor n/2 
\backslash
right
\backslash
rfloor
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$x = A
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$A_{left} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e 
\backslash
leq x
\backslash
right) + 
\backslash
left[x
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	if $k == 
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		return $x$
\end_layout

\begin_layout Plain Layout

	elif $k < 
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		return Quickselect$
\backslash
left(A_{left},k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$A_{right} = 
\backslash
text{filter}
\backslash
left(A
\backslash
left[:-1
\backslash
right], 
\backslash
lambda e: e > x
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		return Quickselect$
\backslash
left(A_{right},k-
\backslash
text{len}
\backslash
left(A_{left}
\backslash
right)
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Data Structures
\end_layout

\begin_layout Section
Hash Tables
\end_layout

\begin_layout Standard
Hash tables are 
\begin_inset Formula $m$
\end_inset

 length arrays keyed on strings instead of numbers.
\end_layout

\begin_layout Subsection
Hash function
\end_layout

\begin_layout Standard
A Hash function is something that 
\begin_inset Quotes eld
\end_inset

hashes
\begin_inset Quotes erd
\end_inset

 up strings into numbers.
 It should uniformly distribute the keys over the hash space, meaning each
 key 
\begin_inset Formula $k$
\end_inset

 is equally likely to hash to any of the 
\begin_inset Formula $m$
\end_inset

 slots of the hash table.
 A good hash function according to Knuth is 
\begin_inset Formula 
\[
h\left(k\right)=\left\lfloor m\left(kA\mod1\right)\right\rfloor 
\]

\end_inset

where 
\begin_inset Formula $A\approx\left(\sqrt{5}-1\right)/2$
\end_inset

 and 
\begin_inset Formula $kA\mod1$
\end_inset

 means the fractional part of 
\begin_inset Formula $kA$
\end_inset

, i.e.
 
\begin_inset Formula $kA-\left\lfloor kA\right\rfloor $
\end_inset

.
\end_layout

\begin_layout Subsection
Hashing with chaining 
\end_layout

\begin_layout Standard
Hashing with chaining is basically Bucket Sort, except with the 
\begin_inset Formula $\left\lfloor \right\rfloor $
\end_inset

 replaced by a Hash function and retrieval.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
Hashing with Chaining
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

HashInsert$
\backslash
left(H,k,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# H is hash table, $k$ is key, $v$ is value
\end_layout

\begin_layout Plain Layout

	$m = 
\backslash
text{len}
\backslash
left(H
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$hsh =
\backslash
left
\backslash
lfloor m
\backslash
left(k
\backslash
left(
\backslash
sqrt{5}-1
\backslash
right)/2
\backslash
mod1
\backslash
right)
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$H
\backslash
left[hsh
\backslash
right]
\backslash
text{.append}
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HashRetrieve$
\backslash
left(H,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m = 
\backslash
text{len}
\backslash
left(H
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$hsh =
\backslash
left
\backslash
lfloor m
\backslash
left(k
\backslash
left(
\backslash
sqrt{5}-1
\backslash
right)/2
\backslash
mod1
\backslash
right)
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	if len$
\backslash
left( H
\backslash
left[hsh
\backslash
right]
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

		return $H
\backslash
left[hsh
\backslash
right]
\backslash
left[1
\backslash
right]$ 
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		return None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HashDelete$
\backslash
left(H,k,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m = 
\backslash
text{len}
\backslash
left(H
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$hsh =
\backslash
left
\backslash
lfloor m
\backslash
left(k
\backslash
left(
\backslash
sqrt{5}-1
\backslash
right)/2
\backslash
mod1
\backslash
right)
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$i = 1$
\end_layout

\begin_layout Plain Layout

	while $i 
\backslash
leq 
\backslash
text{len}
\backslash
left(H
\backslash
left[hsh
\backslash
right]
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

		if $H
\backslash
left[hsh
\backslash
right]
\backslash
left[i
\backslash
right] == v$:
\end_layout

\begin_layout Plain Layout

			del $H
\backslash
left[hsh
\backslash
right]
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			return
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			$i = i +1$
\end_layout

\begin_layout Plain Layout

	return "Error: $v$ not in table"	
\end_layout

\end_inset


\end_layout

\end_inset

If 
\begin_inset Formula $n$
\end_inset

 is the total number of items in the hash table and 
\begin_inset Formula $m$
\end_inset

 is the length of the hash table then on average (give uniform hashing)
 each list has 
\begin_inset Formula $\alpha=n/m$
\end_inset

 items.
 Therefore insertion is 
\begin_inset Formula $\Theta\left(1\right)$
\end_inset

, and retrieval/deletion is 
\begin_inset Formula $\Theta\left(1+\alpha\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Hashing with open addressing
\end_layout

\begin_layout Standard
In hashing with open addressing the buckets are 
\begin_inset Quotes eld
\end_inset

linearized
\begin_inset Quotes erd
\end_inset

, i.e.
 just laid out in the table itself: inserts and searches hash and then traverse
 forward in the table until they find a spot.
 Deletion is harder so if deletion is necessary then hashing with chaining
 should be used.
 Insertion costs at most 
\begin_inset Formula $1/\left(1-\alpha\right)$
\end_inset

 and for 
\begin_inset Formula $\alpha<1$
\end_inset

 retrieval costs 
\begin_inset Formula 
\[
\frac{1}{\alpha}\ln\left(\frac{1}{1-\alpha}\right)
\]

\end_inset

Integral to these bounds is that 
\begin_inset Formula $\alpha$
\end_inset

 the load factor stay small.
 In order for the amortized analysis to workout the hash table should be
 doubled in size (and entries copied) when the table becomes full but halve
 it only when the load goes down to below 
\begin_inset Formula $1/4$
\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
Hashing with open addressing
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

HashInsert$
\backslash
left(H,k,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# H is hash table, $k$ is key, $v$ is value
\end_layout

\begin_layout Plain Layout

	$m = 
\backslash
text{len}
\backslash
left(H
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$hsh =
\backslash
left
\backslash
lfloor m
\backslash
left(k
\backslash
left(
\backslash
sqrt{5}-1
\backslash
right)/2
\backslash
mod1
\backslash
right)
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$hsh_{orig} = hsh$
\end_layout

\begin_layout Plain Layout

	if $H
\backslash
left[hsh
\backslash
right] == NIL$:
\end_layout

\begin_layout Plain Layout

		$H
\backslash
left[hsh
\backslash
right] = 
\backslash
left(k,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ hsh = hsh +1 $
\end_layout

\begin_layout Plain Layout

		while $H
\backslash
left[hsh
\backslash
right] 
\backslash
neq NIL$ and $hsh 
\backslash
neq hsh_{orig}$:
\end_layout

\begin_layout Plain Layout

			# mod so it swings back around and $+1$ 
\end_layout

\begin_layout Plain Layout

			# because indexing starts at 1, not 0
\end_layout

\begin_layout Plain Layout

			$hsh = 
\backslash
left(hsh + 1 
\backslash
mod m
\backslash
right) + 1$
\end_layout

\begin_layout Plain Layout

		if $H
\backslash
left[hsh
\backslash
right] == NIL$:
\end_layout

\begin_layout Plain Layout

			$H
\backslash
left[hsh
\backslash
right] = 
\backslash
left(k,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			retun "Error: Hash table full"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HashRetrieve$
\backslash
left(H,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m = 
\backslash
text{len}
\backslash
left(H
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$hsh =
\backslash
left
\backslash
lfloor m
\backslash
left(k
\backslash
left(
\backslash
sqrt{5}-1
\backslash
right)/2
\backslash
mod1
\backslash
right)
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$hsh_{orig} = hsh$
\end_layout

\begin_layout Plain Layout

	if $H
\backslash
left[hsh
\backslash
right]
\backslash
left[1
\backslash
right] == k$:
\end_layout

\begin_layout Plain Layout

		return $H
\backslash
left[hsh
\backslash
right]
\backslash
left[2
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ hsh = hsh +1 $
\end_layout

\begin_layout Plain Layout

		while $H
\backslash
left[hsh
\backslash
right]
\backslash
left[1
\backslash
right] == k$ and $H
\backslash
left[hsh
\backslash
right] 
\backslash
neq NIL$ and $hsh 
\backslash
neq hsh_{orig}$:
\end_layout

\begin_layout Plain Layout

			# mod so it swings back around and $+1$ 
\end_layout

\begin_layout Plain Layout

			# because indexing starts at 1, not 0
\end_layout

\begin_layout Plain Layout

			$hsh = 
\backslash
left(hsh + 1 
\backslash
mod m
\backslash
right) + 1$
\end_layout

\begin_layout Plain Layout

		if $H
\backslash
left[hsh
\backslash
right] == NIL$ or $hsh == hsh_{orig}$:
\end_layout

\begin_layout Plain Layout

			return "Error: key missing"
\end_layout

\begin_layout Plain Layout

		else: 
\end_layout

\begin_layout Plain Layout

			return $H
\backslash
left[hsh
\backslash
right]
\backslash
left[2
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Binary Search Tree
\end_layout

\begin_layout Standard
A binary tree is a graph where each vertex has at most two children.
 A binary search tree is a tree with the further constraint that the key
 of a parent is greater or equal to any of the keys in its left subtree
 and less than or equal to any of the keys in its right subtree.
\end_layout

\begin_layout Standard
The working low-level data structure for trees is dict
\begin_inset Formula $\left(\right)$
\end_inset

.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
Binary Tree
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

btree = lambda $parent$, $name$, $val$, $lchild$, $rchild$: 
\end_layout

\begin_layout Plain Layout

			  {'parent':$parent$, 'name':$name$, 'val':$val$, 
\end_layout

\begin_layout Plain Layout

			   'lchild':$lchild$, 'rchild':$rchild$}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# counter generator is for labeling
\end_layout

\begin_layout Plain Layout

def counter(x):     
\end_layout

\begin_layout Plain Layout

	start = x
\end_layout

\begin_layout Plain Layout

	while True:
\end_layout

\begin_layout Plain Layout

        yield start
\end_layout

\begin_layout Plain Layout

        start += 1
\end_layout

\begin_layout Plain Layout

$c = 
\backslash
text{counter}
\backslash
left(1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$root$ = btree(None,next$
\backslash
left(c
\backslash
right)$,$5$,None,None)
\end_layout

\begin_layout Plain Layout

$left$ = btree($root$,next$
\backslash
left(c
\backslash
right)$,$4$,None,None)
\end_layout

\begin_layout Plain Layout

$right$ = btree($root$,next$
\backslash
left(c
\backslash
right)$,$6$,None,None)
\end_layout

\begin_layout Plain Layout

$root
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = left$
\end_layout

\begin_layout Plain Layout

$root
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = right$
\end_layout

\end_inset


\end_layout

\end_inset

Note that the 
\family typewriter
name is purely 
\family default
a label and has no relation to 
\family typewriter
val
\family default
.
 The tree then looks like 
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

[level distance=1.5cm,
\end_layout

\begin_layout Plain Layout

level 1/.style={sibling distance=3.5cm},
\end_layout

\begin_layout Plain Layout

level 2/.style={sibling distance=1cm}]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{every node}=[circle,draw]
\end_layout

\begin_layout Plain Layout


\backslash
node (Root)  {5}
\end_layout

\begin_layout Plain Layout

    child {
\end_layout

\begin_layout Plain Layout

    node {4} } 
\end_layout

\begin_layout Plain Layout

	child {
\end_layout

\begin_layout Plain Layout

    node {6}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Inserting into a binary search tree
\end_layout

\begin_layout Standard
Inserting into a binary search tree is easy: the insert vertex just has
 to obey the binary search constraint: start at the root, if the root value
 is equal to the key you're inserting then go left, otherwise go right.
 Once you hit a 
\family typewriter
None 
\family default
create a new vertex.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Insert
\family default

\begin_inset Formula $\left(B,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $B$ is a btree dict as described above, corresponding to the
\end_layout

\begin_layout Plain Layout

# root of the tree
\end_layout

\begin_layout Plain Layout

$prnt = ptr = B$
\end_layout

\begin_layout Plain Layout

while $ptr 
\backslash
neq 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	# because of python's memory model we need to keep track
\end_layout

\begin_layout Plain Layout

	# of parent since names are references not pointers, i.e.
\end_layout

\begin_layout Plain Layout

	# you can't reassign pointers like in C
\end_layout

\begin_layout Plain Layout

	$ prnt = ptr$
\end_layout

\begin_layout Plain Layout

	if $ptr
\backslash
left[
\backslash
text{'val'}
\backslash
right] 
\backslash
leq k$:
\end_layout

\begin_layout Plain Layout

		$ptr = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ptr = ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

if $prnt
\backslash
left[
\backslash
text{'val'}
\backslash
right] 
\backslash
leq k$
\end_layout

\begin_layout Plain Layout

	$prnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = 
\backslash
text{btree}
\backslash
left(prnt,
\backslash
text{next}
\backslash
left(c
\backslash
right),k,
\backslash
text{None},
\backslash
text{None}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	return $prnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$prnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = 
\backslash
text{btree}
\backslash
left(prnt,
\backslash
text{next}
\backslash
left(c
\backslash
right),k,
\backslash
text{None},
\backslash
text{None}
\backslash
right)$	
\end_layout

\begin_layout Plain Layout

	return $prnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Searching a binary search tree
\end_layout

\begin_layout Standard
Searching is easy because a binary search tree obey the binary search constraint
: start at the root, if the root value is equal to the key you're searching
 for then you're done, otherwise if the key is less than the value go left,
 otherwise go right.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Search
\family default

\begin_inset Formula $\left(B,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = B$
\end_layout

\begin_layout Plain Layout

while $ptr 
\backslash
neq 
\backslash
text{None}$ and $ptr
\backslash
left[
\backslash
text{'val'}
\backslash
right] 
\backslash
neq k$:
\end_layout

\begin_layout Plain Layout

	if $ptr
\backslash
left[
\backslash
text{'val'}
\backslash
right] < k$:
\end_layout

\begin_layout Plain Layout

		$ptr = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ptr = ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

if $ptr == 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	return "Error: key missing"
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	return $ptr$	
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Binary search tree min/max
\end_layout

\begin_layout Standard
The minimum of a binary tree is the left-est most vertex.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Min
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = B$
\end_layout

\begin_layout Plain Layout

while $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] 
\backslash
neq $None:
\end_layout

\begin_layout Plain Layout

	$ptr = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

return $ptr$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The maximum of a binary tree is the right-est most vertex.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Max
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = B$
\end_layout

\begin_layout Plain Layout

while $ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] 
\backslash
neq $None:
\end_layout

\begin_layout Plain Layout

	$ptr = ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

return $ptr$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Binary search tree predecessor/successor
\end_layout

\begin_layout Standard
The predecessor of a vertex the maximum of a vertex's left subtree.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Predecessor
\family default

\begin_inset Formula $\left(B,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = 
\backslash
text{Binary-Tree-Search}
\backslash
left(B,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return Binary-Tree-Max$
\backslash
left(ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The successor of a vertex the minimum of a vertex's right subtree.
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Predecessor
\family default

\begin_inset Formula $\left(B,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = 
\backslash
text{Binary-Tree-Search}
\backslash
left(B,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return Binary-Tree-Min$
\backslash
left(ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Deleting from a binary search tree
\end_layout

\begin_layout Standard
We need an auxiliary function to wrap up some code that's re-used.
 Running time is constant.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Transplant
\family default

\begin_inset Formula $\left(u,v\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# does not handle case where $u$ is root of tree
\end_layout

\begin_layout Plain Layout

$prnt = u
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

if $prnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] == u$
\end_layout

\begin_layout Plain Layout

	$prnt
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = v$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$prnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = v$
\end_layout

\begin_layout Plain Layout

if $v 
\backslash
neq $None:
\end_layout

\begin_layout Plain Layout

	$v
\backslash
left[
\backslash
text{'parent'}
\backslash
right] = prnt$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Deleting from a binary search tree is a little more complicated.
 Since the binary search tree property needs to be always preserved it's
 unclear what to replace a deleted vertex with.
 A child? A parent? In fact it should be the successor (or predecessor).
 The successor is the vertex whose value would follow the vertex you're
 trying to delete if you listed all the vertices in order.
 How do you find the successor? It's the minimum of the right subtree or
 the vertex (and the minimum of a tree is the farthest left of the tree).
 Then that minimum can be replaced by it's right child (it has no left child).
 Running time is 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 if the tree is balanced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Binary-Tree-Delete
\family default

\begin_inset Formula $\left(B,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ptr = 
\backslash
text{Binary-Tree-Search}
\backslash
left(B,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# trivial case, successor is parent
\end_layout

\begin_layout Plain Layout

if $ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] == 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	Transplant$
\backslash
left(ptr,ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

elif $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] == 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	Transplant$
\backslash
left(ptr,ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$succ = 
\backslash
text{Binary-Tree-Successor}
\backslash
left(ptr
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# if the successor is the right child of $ptr$ then
\end_layout

\begin_layout Plain Layout

	# then right child has no left child and task simple
\end_layout

\begin_layout Plain Layout

	if $succ == ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		Transplant$
\backslash
left(ptr,succ
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'parent'}
\backslash
right] = succ$
\end_layout

\begin_layout Plain Layout

	else: # otherwise we have to fix successor subtrees and do the same thing
 
\end_layout

\begin_layout Plain Layout

		   # including fixing the right child
\end_layout

\begin_layout Plain Layout

		# fix successor
\end_layout

\begin_layout Plain Layout

		Transplant$
\backslash
left(succ,succ
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# don't lose right child of $ptr$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
left[
\backslash
text{'parent'}
\backslash
right] = succ$
\end_layout

\begin_layout Plain Layout

		# move successor into $ptr$'s position
\end_layout

\begin_layout Plain Layout

		Transplant$
\backslash
left(ptr,succ
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		$succ
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'parent'}
\backslash
right] = succ$		
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pre-order/In-order/Post-order traversal
\end_layout

\begin_layout Standard
A Pre-order/In-order/Post-order traversal of a binary tree is a traversal
 the manipulates the vertex either before left and right children, after
 the left child but before the right child, and after both the left and
 right children.
 The easiest way to implement any of these is recursion but iterative versions
 do exist.
 Running time is 
\begin_inset Formula $O\left(n\right)$
\end_inset

 since the traversal visits every vertex.
 For illustrative purposes we simply print the 
\family typewriter
val 
\family default
attribute, but any operation on the vertex could be performed.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Pre-order-traversal
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

print$
\backslash
left(B
\backslash
left[
\backslash
text{'val'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
In-order-traversal
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

print$
\backslash
left(B
\backslash
left[
\backslash
text{'val'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Post-order-traversal
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout
\noindent
\align left

Pre-order-traversal$
\backslash
left(B
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

print$
\backslash
left(B
\backslash
left[
\backslash
text{'val'}
\backslash
right]
\backslash
right)$ 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Treap
\end_layout

\begin_layout Standard
Binary trees have 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 queries and inserts and deletions if they're balanced.
 Turns out keep them balanced is tough - a ton of schemes exist.
 The simpliest is a random binary tree using a treap.
 A treap combines the invariants of a binary tree 
\emph on
and
\emph default
 and a heap.
 There are two sets of attributes: priorities and keys.
 The priorities obey the heap property (children have smaller priority than
 their parents) and the keys obey the binary search property.
 In order to get a balanced binary tree, which is the value of treaps, we
 randomly generate a priority key.
 This then simulates the generation of a random binary tree which on average
 has depth 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

.
 We use a min heap.
\end_layout

\begin_layout Subsection
Treap search
\end_layout

\begin_layout Standard
Just like for binary search tree and hence omitted.
\end_layout

\begin_layout Subsection
Treap insert
\end_layout

\begin_layout Standard
This is easier of the two operations.
 First we need two auxiliary functions 
\family typewriter
Left-Rotate
\family default
 and 
\family typewriter
Right-Rotate
\family default
.
 The easiest way to remember these is pictures
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Tree_rotation.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Left-rotate
\family default

\begin_inset Formula $\left(p\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

$p_{prnt} = p
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$a = p
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$q = p
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# put $q$ in $p$'s position
\end_layout

\begin_layout Plain Layout

if $p = p_{prnt}
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout
\noindent
\align left

	$p_{prnt}
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = q$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$p_{prnt}
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = q$
\end_layout

\begin_layout Plain Layout

$p
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = q
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$q
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = p$
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Right-rotate
\family default

\begin_inset Formula $\left(p\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

$q_{prnt} = q
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$p = q
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$c = q
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# put $p$ in $q$'s position
\end_layout

\begin_layout Plain Layout

if $q = q_{prnt}
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout
\noindent
\align left

	$q_{prnt}
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = p$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$q_{prnt}
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = p$
\end_layout

\begin_layout Plain Layout

$q
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = p
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$p
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = q$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To insert into a treap, generate a random priority, and insert the key as
 if it were a binary search tree (i.e.
 at the bottom), then rotate up until the heap property is restored.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Treap-Insert
\family default

\begin_inset Formula $\left(T,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $T$ is a binary tree that's a treap
\end_layout

\begin_layout Plain Layout

$u = 
\backslash
text{Random}
\backslash
left(0,1
\backslash
right)$ # both ends inclusive
\end_layout

\begin_layout Plain Layout
\noindent
\align left

$ptr = 
\backslash
text{Binary-Tree-Insert}
\backslash
left(T,
\backslash
left(u,k
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$prnt = ptr
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

while $prnt 
\backslash
neq 
\backslash
text{None}$ and $ptr
\backslash
left[
\backslash
text{'val'}
\backslash
right] < prnt
\backslash
left[
\backslash
text{'val'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	if $ptr == prnt
\backslash
left[
\backslash
text{'lchild}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		Right-Rotate$
\backslash
left(prnt
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		Left-Rotate$
\backslash
left(prnt
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$ptr = prnt$
\end_layout

\begin_layout Plain Layout

	$prnt = ptr
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$	
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Treap delete
\end_layout

\begin_layout Standard
To delete a vertex rotate it down until it's a leaf node and then delete
 the leaf node.
 Rotate down according to which of the vertex's children have a higher priority:
 if the left child has a higher priority than the right then rotate right,
 otherwise rotate left.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Treap-Delete
\family default

\begin_inset Formula $\left(T,k\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $T$ is a binary tree that's a treap
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align left

$ptr = 
\backslash
text{Binary-Tree-Search}
\backslash
left(T,k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

while $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$ or $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	if $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$ and $ptr
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'val'}
\backslash
right] > ptr
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]
\backslash
left[
\backslash
text{'val'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		Right-Rotate$
\backslash
left(ptr
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		Left-Rotate$
\backslash
left(ptr
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	if $ptr = ptr
\backslash
left[
\backslash
text{'parent'}
\backslash
right]
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$ptr
\backslash
left[
\backslash
text{'parent'}
\backslash
right]
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = 
\backslash
text{None}$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ptr
\backslash
left[
\backslash
text{'parent'}
\backslash
right]
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = 
\backslash
text{None}$
\end_layout

\begin_layout Plain Layout

	del $ptr$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Cartesian Tree
\end_layout

\begin_layout Standard
Given a sequence of 
\series bold
distinct
\series default
 numbers (or any totally ordered objects), there exists a binary min-heap
 whose inorder traversal is that sequence.
 This is known as the Cartesian tree for that sequence.
 A min-treap is an easy way to construct a Cartiesian tree of a sorted sequence.
 Why? Obviously: it's is heap ordered since it obeys the min heap property
 and an in order traversal reproduces the sequence in sorted order.
 How to construct a Cartesian tree for an arbitrary sequence 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

? Process the sequence values in left-to-right order, maintaining the Cartesian
 tree of the nodes processed so far, in a structure that allows both upwards
 and downwards traversal of the tree.
 To process each new value 
\begin_inset Formula $x$
\end_inset

, start at the node representing the value prior to 
\begin_inset Formula $x$
\end_inset

 in the sequence and follow the path from this node to the root of the tree
 until finding a value 
\begin_inset Formula $y$
\end_inset

 smaller than 
\begin_inset Formula $x$
\end_inset

.
 This node 
\begin_inset Formula $y$
\end_inset

 is the parent of 
\begin_inset Formula $x$
\end_inset

, and the previous right child of 
\begin_inset Formula $y$
\end_inset

 becomes the new left child of 
\begin_inset Formula $x$
\end_inset

.
 Running time is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Cartesian-Tree
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$T = 
\backslash
text{btree}
\backslash
left(
\backslash
text{None},
\backslash
text{next}
\backslash
left(c
\backslash
right),A
\backslash
left[1
\backslash
right],
\backslash
text{None},
\backslash
text{None}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ptr = prnt = T$
\end_layout

\begin_layout Plain Layout

for $i= 2:
\backslash
text{len}
\backslash
left(A
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	while $prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$ and $A
\backslash
left[i
\backslash
right] <prnt
\backslash
left[
\backslash
text{'val}
\backslash
right] $
\end_layout

\begin_layout Plain Layout

		$prnt = prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	if $prnt == 
\backslash
text{None}$: # then we're at the root
\end_layout

\begin_layout Plain Layout

		# and $A
\backslash
left[i
\backslash
right]$ is the smallest value we've seen so far
\end_layout

\begin_layout Plain Layout

		$ptr = 
\backslash
text{btree}
\backslash
left(
\backslash
text{None},
\backslash
text{next}
\backslash
left(c
\backslash
right),A
\backslash
left[i
\backslash
right],prnt,
\backslash
text{None}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right] = ptr$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$ptr = 
\backslash
text{btree}
\backslash
left(prnt,
\backslash
text{next}
\backslash
left(c
\backslash
right),A
\backslash
left[i
\backslash
right],prnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right],
\backslash
text{None}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$prnt
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = ptr$
\end_layout

\begin_layout Plain Layout

	$prnt = ptr$
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Interval Trees
\end_layout

\begin_layout Standard
An interval tree is built atop your favotire balanced binary tree data structure
 (treap in our case) and stores left endpoints as key.
 It also keeps track of maximum right endpoint in the subtree rooted at
 a vertex.
 It supports interval intersection tests (very useful).
 Maintaining the max in insertion and deletion is straightforward during
 rotations.
\end_layout

\begin_layout Subsection
Interval search
\end_layout

\begin_layout Standard
Interval search works by being optimistic: 
\begin_inset Formula $i=\left[a,b\right]$
\end_inset

 and 
\begin_inset Formula $j=\left[x,y\right]$
\end_inset

 two intervals overlap if either 
\begin_inset Formula $a\leq x\leq b$
\end_inset

 or 
\begin_inset Formula $x\leq a\leq y$
\end_inset

.
 Therefore at each interval we test for overlap and whether 
\begin_inset Formula $x\leq a\leq y$
\end_inset

 where 
\begin_inset Formula $y$
\end_inset

 is the maximum right endpoint for any interval in the left subtree.
 If so we go left.
 If in fact 
\begin_inset Formula $y<a$
\end_inset

 then no interval in the left subtree could possibly intersect so we go
 right.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Interval-Tree-Search
\family default

\begin_inset Formula $\left(T,i\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $T$ is an interval tree, $i = 
\backslash
left[a,b
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$a,b = i
\backslash
left[1
\backslash
right],i
\backslash
left[2
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# $j
\backslash
left[
\backslash
text{'left'}
\backslash
right]$ is left endpoint of interval and 
\end_layout

\begin_layout Plain Layout

# $j
\backslash
left[
\backslash
text{'right'}
\backslash
right]$ is right endpoint
\end_layout

\begin_layout Plain Layout

intersect $=$ lamba $j$: $a 
\backslash
leq j
\backslash
left[
\backslash
text{'left'}
\backslash
right] 
\backslash
leq b$ or $j
\backslash
left[
\backslash
text{'left'}
\backslash
right] 
\backslash
leq a 
\backslash
leq j
\backslash
left[
\backslash
text{'right'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# 'int' is interval associated with vertex
\end_layout

\begin_layout Plain Layout

while $T 
\backslash
neq 
\backslash
text{None}$ and not intersect$
\backslash
left(T
\backslash
left[
\backslash
text{'int'}
\backslash
right]
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	if $T
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] 
\backslash
neq 
\backslash
text{None}$ and $a 
\backslash
leq T
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'max'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$T = T
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		$T = T
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

return $T$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Order Statistics Tree
\end_layout

\begin_layout Standard
Order statistics trees are probably the simplest thing to build atop a balanced
 binary search tree.
 The only extra extra piece of information each vertex stores is the attribute
 
\family typewriter
size 
\family default
where 
\begin_inset Formula $x\left[\texttt{'size'}\right]=x\left[\texttt{'lchild'}\right]\left[\texttt{'size'}\right]+x\left[\texttt{'rchild'}\right]\left[\texttt{'size'}\right]+1$
\end_inset

.
\end_layout

\begin_layout Subsection
Select
\end_layout

\begin_layout Standard
Finding the 
\begin_inset Formula $i$
\end_inset

th ordered element in the tree works just like Quickselect
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
OS-Select
\family default

\begin_inset Formula $\left(T,i\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $T$ is an interval tree, $i$ is the rank we're looking for
\end_layout

\begin_layout Plain Layout

$r = T
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'size'}
\backslash
right] + 1 $
\end_layout

\begin_layout Plain Layout

if $i == r$:
\end_layout

\begin_layout Plain Layout

	return $x$
\end_layout

\begin_layout Plain Layout

elif $i < r$:
\end_layout

\begin_layout Plain Layout

	return OS-Select$
\backslash
left(T
\backslash
left[
\backslash
text{'lchild'}
\backslash
right],i
\backslash
right)$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	return OS-Select$
\backslash
left(T
\backslash
left[
\backslash
text{'rchild'}
\backslash
right],i-r
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rank
\end_layout

\begin_layout Standard
We can find the rank of an element by finding how many elements are to its
 left.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
OS-Rank
\family default

\begin_inset Formula $\left(T,x\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$x$ is a pointer to a vertex in the tree
\end_layout

\begin_layout Plain Layout

$r  = x
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'size'}
\backslash
right] + 1 $
\end_layout

\begin_layout Plain Layout

$prnt = x$
\end_layout

\begin_layout Plain Layout

# while $prnt$ is not root of $T$
\end_layout

\begin_layout Plain Layout

while $prnt 
\backslash
neq T$:
\end_layout

\begin_layout Plain Layout

	if $ prnt == prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right]
\backslash
left[
\backslash
text{'rchild'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$r  = r+ prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right]
\backslash
left[
\backslash
text{'lchild'}
\backslash
right]
\backslash
left[
\backslash
text{'size'}
\backslash
right] + 1 $
\end_layout

\begin_layout Plain Layout

	$prnt = prnt
\backslash
left[
\backslash
text{'parent'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

return $r$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Maintenance
\end_layout

\begin_layout Standard
Maintaining 
\family typewriter
size 
\family default
is easy: for example in 
\family typewriter
Left-Rotate 
\family default
add lines 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

13 
\begin_inset Formula $y\left[\texttt{'size'}\right]=x\left[\texttt{'size'}\right]$
\end_inset


\begin_inset Newline newline
\end_inset

14 
\begin_inset Formula $x\left[\texttt{'size'}\right]=x\left[\texttt{'lchild'}\right]\left[\texttt{'size'}\right]+x\left[\texttt{'rchild'}\right]\left[\texttt{'size'}\right]+1$
\end_inset


\end_layout

\begin_layout Standard
and similarly for 
\family typewriter
Right-Rotate.
\end_layout

\begin_layout Section
Union-Find
\end_layout

\begin_layout Standard
A union-find data structure is a data structure suited for taking unions
 and finding members (duh).
 The particular units of the data structures are sets (not hash table derivative
s), each with a representative.
 The data structure is very thin, basically a wrapper for the primitive
 data, except for a pointer to the representative of the set and two heuristics
 that speed up the operations.
 The path compression heuristic 
\begin_inset Quotes eld
\end_inset

compresses
\begin_inset Quotes erd
\end_inset

 the path to representative of the set by setting it to be equal to that
 representative (which it might not be after a union).
 The weighted union heuristic makes it so that the smaller of the two sets
 unioned is the one whose representative pointers need to be updated.
\end_layout

\begin_layout Standard
Amortized complexity of 
\begin_inset Formula $n$
\end_inset

 
\family typewriter
Make-Set
\family default
, 
\family typewriter
Find-Set, Union,
\family default
 operations where 
\begin_inset Formula $m$
\end_inset

 are 
\family typewriter
Make-Set
\family default
 is 
\begin_inset Formula $O\left(m\alpha\left(n\right)\right)$
\end_inset

 where 
\begin_inset Formula $\alpha\left(n\right)$
\end_inset

 is the Ackermann function and 
\begin_inset Formula $\alpha\left(n\right)\leq4$
\end_inset

 for any realistic application.
\end_layout

\begin_layout Subsection
Make set
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Make-Set
\family default

\begin_inset Formula $\left(x\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

return {'val':$x$,'rep':$x$,'rank':0}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Find set
\end_layout

\begin_layout Standard
Find set is interesting: it unwinds the stack in order to reset all the
 representatives from 
\begin_inset Formula $x$
\end_inset

 to the representative of the set.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Find-Set
\family default

\begin_inset Formula $\left(x\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $x
\backslash
left[
\backslash
text{'rep'}
\backslash
right]
\backslash
neq x$:
\end_layout

\begin_layout Plain Layout

	$x
\backslash
left[
\backslash
text{'rep'}
\backslash
right] = 
\backslash
text{Find-Set}
\backslash
left(x
\backslash
left[
\backslash
text{'rep'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Union
\end_layout

\begin_layout Standard
Find set is interesting: it unwinds the stack in order to reset all the
 representatives from 
\begin_inset Formula $x$
\end_inset

 to the representative of the set.
 Running time is 
\begin_inset Formula $O\left(m\lg n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Union
\family default

\begin_inset Formula $\left(x,y\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$x_{rep} = 
\backslash
text{Find-Set}
\backslash
left(x
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$y_{rep} = 
\backslash
text{Find-Set}
\backslash
left(y
\backslash
right)$
\end_layout

\begin_layout Plain Layout

if $x_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right] > y_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$y_{rep}
\backslash
left[
\backslash
text{'rep'}
\backslash
right] = x_{rep}$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$x_{rep}
\backslash
left[
\backslash
text{'rep'}
\backslash
right] = y_{rep}$
\end_layout

\begin_layout Plain Layout

	if $x_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right] == y_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right] $
\end_layout

\begin_layout Plain Layout

		# it's an approximate rank.
\end_layout

\begin_layout Plain Layout

		$y_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right] = y_{rep}
\backslash
left[
\backslash
text{'rank'}
\backslash
right] + 1$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Euler circuit
\end_layout

\begin_layout Standard
An Euler circuit visits each vertex in graph twice - once going past it
 and once coming back across it.
 How do you print out an Euler circuit of a tree? Use a modified depth first
 traversal.
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Euler-Circuit
\family default

\begin_inset Formula $\left(u\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $u$ is a vertex with children
\end_layout

\begin_layout Plain Layout

# print it going past
\end_layout

\begin_layout Plain Layout

print$
\backslash
left(u
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $v$ in $u
\backslash
left[
\backslash
text{'children'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	Euler-Circuit$
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# print is coming back
\end_layout

\begin_layout Plain Layout

	print$
\backslash
left(u
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Tarjan's Least Common Ancestor
\end_layout

\begin_layout Standard
The least common ancestor 
\begin_inset Formula $w$
\end_inset

 of two vertices 
\begin_inset Formula $u,v$
\end_inset

 in a tree is the ancestor common to both that's of greatest depth.
 The algorithm is useful for range-minimum querying.
 It uses the same traversal as 
\family typewriter
Euler-Circuit
\family default
 and the Union-Find data structure augmented with a property 
\family typewriter
ancestor
\family default
.
 The algorithm proceeds by growing 
\begin_inset Quotes eld
\end_inset

bottom up
\begin_inset Quotes erd
\end_inset

 sets corresponding to subtrees whose roots are the least common ancestors
 of any pair of vertices in the tree 
\series bold
which have been completely traversed by the Euler circuit
\series default
.
 Let 
\begin_inset Formula $P$
\end_inset

 be a global with the set of vertices you're interested in finding least
 common ancestor of and initialize all vertices to have 
\family typewriter
color 
\family default
\color blue
Blue
\color inherit
 in order to represent unfinishined (i.e.
 not completely traversed by the Euler circuit).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Least-Common-Ancestor
\family default

\begin_inset Formula $\left(u\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $u$ is the root of a tree
\end_layout

\begin_layout Plain Layout

$u_{set} = 
\backslash
text{Make-Set}
\backslash
left(u
\backslash
right)$
\end_layout

\begin_layout Plain Layout

#this is the Euler-Circuit transformation (equivalent of print)
\end_layout

\begin_layout Plain Layout

$u_{set}
\backslash
left[
\backslash
text{'ancestor'}
\backslash
right]= u$
\end_layout

\begin_layout Plain Layout

for $v$ in $u
\backslash
left[
\backslash
text{'children'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	$
\backslash
text{Least-Common-Ancestor}
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# let's pretend there's a big table where i can fetch $v_{set}$ from
\end_layout

\begin_layout Plain Layout

	Union$
\backslash
left(u_{set},v_{set}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$u_{set}
\backslash
left[
\backslash
text{'ancestor'}
\backslash
right]= u$
\end_layout

\begin_layout Plain Layout

# $u_{set}
\backslash
left[
\backslash
text{'val'}
\backslash
right] = u$
\end_layout

\begin_layout Plain Layout

$u_{set}
\backslash
left[
\backslash
text{'val'}
\backslash
right]
\backslash
left[
\backslash
text{'color'}
\backslash
right] = 
\backslash
color{red}
\backslash
text{Red}$
\end_layout

\begin_layout Plain Layout

for each $v$ such that $
\backslash
{u,v
\backslash
} 
\backslash
in P$:
\end_layout

\begin_layout Plain Layout

	if $v
\backslash
left[
\backslash
text{'color'}
\backslash
right] == 
\backslash
color{red}
\backslash
text{Red}$:
\end_layout

\begin_layout Plain Layout

		print$
\backslash
left(
\backslash
text{"Least common ancestor of } 
\backslash
{u,v
\backslash
} 
\backslash
text{ is " } + v_{set}
\backslash
left[
\backslash
text{'ancestor'}
\backslash
right]
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Range Minimum Queries
\end_layout

\begin_layout Standard
Given a sequence of distinct values and a subsequence (specified by it's
 end points) what is the minimum value of the in that subsequences? It's
 just the least common ancestor of the end points in the cartesian tree
 representing the sequence.
\end_layout

\begin_layout Part
Advanced Design Techniques
\end_layout

\begin_layout Section
Dynamic Programming
\end_layout

\begin_layout Standard
Note this is a fairly formal explanation of dynamic programming.
 Skip if you're not interested in formalism.
 If you want a good intuitive interpretation of Dynamic programming read
 chapter 6 of Vazirani (where he says that dynamic programming is simply
 traversing the topological sort of the problem dependency graph).
\end_layout

\begin_layout Standard
Dynamic programming does not means writing code dynamically or changing
 code dynamically or anything like that.
 The sense in which programming is being used here is the same sense as
 setting a program for an festival or something, and dynamic means making
 decisions in-situ rather than a priori.
 dynamic programming is an optimization technique - minimizing travel time,
 minimizing cost, maximizing profits, maximizing utility, et cetera.
 The central concept is the 
\series bold
Bellman equation
\series default
 so I'm going to crib here the wikipedia article on the Bellman equation
 (yes the whole thing).
 
\end_layout

\begin_layout Standard
First, any optimization problem has some objective – minimizing travel time,
 minimizing cost, maximizing profits, maximizing utility, et cetera.
 The function that describes this objective is called the 
\series bold
objective function
\series default
 or 
\series bold
cost function
\series default
,i.e.
 the travel time, cost, or profits as a function of time.
 Dynamic programming breaks a multi-period planning problem into simpler
 steps.
 Therefore, it requires keeping track of how the circumstances, as the concern
 the decision at each step, change over time.
 The information about the current situation which is needed to make a correct
 decision is called the 
\begin_inset Quotes eld
\end_inset

state".
 For example, to decide how much to consume and spend at each point in time,
 people would need to know (among other things) their initial wealth.
 Therefore, current wealth would be one of their 
\series bold
state variables
\series default
.
 The decisions made at each step are represented by 
\series bold
control variables
\series default
.

\series bold
 
\series default
For example, in the simplest case, today's wealth (the state) and how much
 is consumed (the control) determine tomorrow's wealth (the new state).
\end_layout

\begin_layout Standard
The dynamic programming approach describes the optimal plan by finding a
 rule that tells what the controls should be, given any possible value of
 the state.
 For example, if consumption 
\begin_inset Formula $c$
\end_inset

 depends only on wealth 
\begin_inset Formula $W$
\end_inset

, we would seek a rule 
\begin_inset Formula $c\left(W\right)$
\end_inset

 that gives consumption as a function of wealth.
 Such a rule, determining the controls as a function of the states, is called
 a 
\series bold
policy function
\series default
.
\end_layout

\begin_layout Standard
Finally, by definition, the optimal decision rule is the one that achieves
 the best possible value of the objective.
 For example, if someone chooses consumption, given wealth (wealth is fixed),
 in order to maximize happiness (assuming happiness 
\begin_inset Formula $H$
\end_inset

 can be represented by a function, such as a 
\series bold
utility function
\series default
), then each level of wealth will be associated with some highest possible
 level of happiness, 
\begin_inset Formula $H\left(W\right)$
\end_inset

.
 The best possible value of the objective, written as a function of the
 state, is called the 
\series bold
value function
\series default
.
\end_layout

\begin_layout Standard
I have no idea what this value function is and how it is distinct from the
 objective function (but I guess I'll find out).
\end_layout

\begin_layout Standard
Richard Bellman showed that a dynamic optimization problem in discrete time
 can be stated in a recursive, step-by-step form known as 
\series bold
backward induction
\series default
 by writing down the relationship between the value function
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This has gotta mean cost function,or imply that the value function is the
 cost function.
\end_layout

\end_inset

 in one period and the value function in the next period.
 The relationship between these two value functions is called the "Bellman
 equation".
 In this approach, the optimal policy in the final time period is specified
 in advance as a function of the state variable's value at that time, and
 the resulting optimal value of the objective function is thus expressed
 in terms of that value of the state variable.
 Next, the next-to-final period's optimization involves maximizing the sum
 of that period's period-specific objective function and the optimal value
 of the future objective function, giving that period's optimal policy contingen
t upon the value of the state variable as of the next-to-last period decision.
 This logic continues recursively back in time, until the first period decision
 rule is derived, as a function of the initial state variable value, by
 optimizing the sum of the first-period-specific objective function and
 the value of the second period's value function, which gives the value
 for all the future periods.
 Thus, each period's decision is made by explicitly acknowledging that all
 future decisions will be optimally made.
\end_layout

\begin_layout Subsection
Fibonacci Sequence
\end_layout

\begin_layout Standard
The simplest dynamic programming algorithm is computing the 
\begin_inset Formula $n$
\end_inset

th Fibonacci number faster than using the naive recursive definition
\begin_inset Formula 
\[
F_{n}=F_{n-1}+F_{n-2}
\]

\end_inset

What's the idea? Overlapping substructure: look at the 
\begin_inset Quotes eld
\end_inset

call stack
\begin_inset Quotes erd
\end_inset

 for trying to compute 
\begin_inset Formula $F_{n}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fib.png
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Look at all of the repeated calls to 
\begin_inset Formula $F_{j}$
\end_inset

.
 Rewrite the calculation so that there's no redundant work.
 There are two ways to do this: using a hashtable to memoize calls or do
 the computation bottom up.
 Running time is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Fibonacci
\family default

\begin_inset Formula $\left(n\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $n == 1$ or $n == 2$:
\end_layout

\begin_layout Plain Layout

	return $1$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$F_{k-1} = 1$
\end_layout

\begin_layout Plain Layout

	$F_{k} = 1$
\end_layout

\begin_layout Plain Layout

	$k = 2$
\end_layout

\begin_layout Plain Layout

	while $k < n$:
\end_layout

\begin_layout Plain Layout

		# k is not a parameter, subscripts are labels not indices
\end_layout

\begin_layout Plain Layout

		$F_{k+1} = F_k + F_{k-1}$
\end_layout

\begin_layout Plain Layout

		$F_k = F_{k+1}$
\end_layout

\begin_layout Plain Layout

		$F_{k-1} = F_k$
\end_layout

\begin_layout Plain Layout

		$k = k+1$ 
\end_layout

\begin_layout Plain Layout

return $F_{k+1}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rod Cutting
\end_layout

\begin_layout Standard
Given a rod of length 
\begin_inset Formula $n$
\end_inset

 and a table of price 
\begin_inset Formula $P=\left[p_{1},\dots,p_{n}\right]$
\end_inset

 corresponding to cuts at 
\begin_inset Formula $i$
\end_inset

 units of length what's the maximum value 
\begin_inset Formula $r_{n}$
\end_inset

 obtained by cutting up the rod? The naive solution is to try all 
\begin_inset Formula $2^{n-1}$
\end_inset

 partitions of the rod.
 Clearly not efficient.
 The optimal substructure of the problem is such the maximum value is the
 sum of maximum value of the potential partitions around a particular cut,
 and not cutting at all.
 Therefore the Bellman equation is
\begin_inset Formula 
\[
r_{i}=\max\left\{ p_{i},r_{1}+r_{i-1},r_{1}+r_{i-1},r_{2}+r_{i-2},\dots,r_{i-1}+r_{1}\right\} =\max_{j=1,\dots,i}\left\{ p_{i},r_{j}+r_{i-j}\right\} 
\]

\end_inset

Notice the duplication in the first expression, which corresponds to mirror
 symmetry of the rod (turning the rod around maps a cut 
\begin_inset Formula $r_{j}+r_{i-j}$
\end_inset

 to 
\begin_inset Formula $r_{i-j}+r_{j}$
\end_inset

).
 Therefore the less redundant Bellman equation is 
\begin_inset Formula 
\[
r_{i}=\max_{j<i-j}\left\{ p_{i},r_{j}+r_{i-j}\right\} 
\]

\end_inset

An equivalent formulation (all cuts of this form correspond to all cuts
 of the prior form) is one solid piece of length 
\begin_inset Formula $i$
\end_inset

 and a potentially further subdivided piece of length 
\begin_inset Formula $n-i$
\end_inset

.
 Therefore the Bellman equation is (with the 
\begin_inset Formula $r_{0}\equiv0$
\end_inset

) 
\begin_inset Formula 
\[
r_{i}=\max_{j=1,\dots,i}\left\{ p_{j}+r_{i-j}\right\} 
\]

\end_inset

The naive recursive implementation runs in 
\begin_inset Formula $O\left(2^{n}\right)$
\end_inset

 because it recomputes solutions to subproblems several times unnecessarily.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Rod-Cut-Rec
\family default

\begin_inset Formula $\left(P,n\right)$
\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $n == 0$:
\end_layout

\begin_layout Plain Layout

	return $0$
\end_layout

\begin_layout Plain Layout

$r = -
\backslash
infty$
\end_layout

\begin_layout Plain Layout

for $i = 1:n$:
\end_layout

\begin_layout Plain Layout

	$r=
\backslash
max
\backslash
left
\backslash
{ r,P
\backslash
left[i
\backslash
right]+
\backslash
text{Rod-Cut-Rec}
\backslash
left(P,n-i
\backslash
right)
\backslash
right
\backslash
} $
\end_layout

\begin_layout Plain Layout

return $r$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To speed this up you need to 
\begin_inset Quotes eld
\end_inset

memoize
\begin_inset Quotes erd
\end_inset

 redundant calls (hash table with already computed values) 
\emph on
or
\emph default
 compute values bottom up.
 The more elegant solution solution is the bottom up computation.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Bottom-Up-Rod-Cut
\family default

\begin_inset Formula $\left(P,n\right)$
\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ r = n
\backslash
cdot 
\backslash
left[0
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i = 1:n$:
\end_layout

\begin_layout Plain Layout

	$q = 0$
\end_layout

\begin_layout Plain Layout

	for $j=1:i$:
\end_layout

\begin_layout Plain Layout

		# recall $r
\backslash
left[0
\backslash
right] 
\backslash
equiv 0$
\end_layout

\begin_layout Plain Layout

		$q=
\backslash
max
\backslash
left
\backslash
{ q,P
\backslash
left[i
\backslash
right]+r
\backslash
left[i-j
\backslash
right]
\backslash
right
\backslash
} $
\end_layout

\begin_layout Plain Layout

	$r
\backslash
left[i
\backslash
right] = q$
\end_layout

\begin_layout Plain Layout

return $r
\backslash
left[n
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Getting to work
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This example is Applied Mathematical Programming by Bradley,Hax, Magnanti
 chapter 11.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a neighborhood of 
\begin_inset Formula $n$
\end_inset

 commuters and 
\begin_inset Formula $n$
\end_inset

 downtown parking lots what is the fastest way for each commuter to get
 to work given that intersection have delays?
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename commute.png
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Imagine instersections are on a rectified grid and that the cost (in time)
 of getting to intersection 
\begin_inset Formula $i,j$
\end_inset

 from some house is 
\begin_inset Formula $q\left(i,j\right)$
\end_inset

 and 
\begin_inset Formula $c\left(i,j\right)$
\end_inset

 is the time to get between intersection (left to right - one way streets).
 Seems like you'd have to start at the end (parking lots) and work backwards
 right? But no in fact this problem has optimal substructure
\begin_inset Formula 
\[
q\left(i,j\right)=\begin{cases}
\infty & j<1\text{ or }j>n\\
c\left(i,j\right) & i=1\\
\min\left\{ q\left(i-1,j-1\right),q\left(i-1,j+1\right)\right\} +c\left(i,j\right) & \text{otherwise}
\end{cases}
\]

\end_inset

Starting from any particular household 
\begin_inset Formula $\left(1,j\right)$
\end_inset

 we can compute the shortest path cost to any parking lot by forward iteration.
 Running time is 
\begin_inset Formula $O\left(nk\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Shortest-Path-Parkin
\family default
g
\begin_inset Formula $\left(A,c\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $A$ is an $n
\backslash
times k$ grid (or something like that)
\end_layout

\begin_layout Plain Layout

# and $c$ is the associated costs with getting
\end_layout

\begin_layout Plain Layout

# to the intersection
\end_layout

\begin_layout Plain Layout

$ n = 
\backslash
text{len}
\backslash
left(A
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$q = n
\backslash
cdot
\backslash
left[n
\backslash
cdot
\backslash
left[
\backslash
infty
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	# initialize first hop intersections
\end_layout

\begin_layout Plain Layout

	$q
\backslash
left[1,i
\backslash
right] = c
\backslash
left[1,i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=2:n$:
\end_layout

\begin_layout Plain Layout

	for $j=1:n$:
\end_layout

\begin_layout Plain Layout

		# i'll let you figure out how to 
\end_layout

\begin_layout Plain Layout

		# bumper the $q$ array so that 
\end_layout

\begin_layout Plain Layout

		# when $i,j=1$ the entries
\end_layout

\begin_layout Plain Layout

		# $q
\backslash
left[i-1,j-1
\backslash
right] = 
\backslash
infty$
\end_layout

\begin_layout Plain Layout

		$q
\backslash
left[i,j
\backslash
right] = 
\backslash
min
\backslash
left
\backslash
{ q
\backslash
left[i-1,j-1
\backslash
right],q
\backslash
left[i-1,j+1
\backslash
right] 
\backslash
right
\backslash
} +c
\backslash
left[i,j
\backslash
right] $
\end_layout

\begin_layout Plain Layout

return $q$
\end_layout

\end_inset


\end_layout

\end_inset

In order to return the actual path to any parking garage just modify the
 
\family typewriter
for
\family default
 loop to keep track of which of 
\begin_inset Formula $q\left(i-1,j-1\right)$
\end_inset

 or 
\begin_inset Formula $q\left(i-1,j+1\right)$
\end_inset

 was chosen in the min.
\end_layout

\begin_layout Subsection
Towers of Hanoi
\end_layout

\begin_layout Standard
Move all the disks from the left rod to the far right one only one disk
 (top disk) at a time.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Tower_of_Hanoi.jpeg
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This problem has optimal substructure in that there's no real difference
 between any of the rods or disks: so moving 
\begin_inset Formula $n$
\end_inset

 disks from the first rod to the third involves moving 
\begin_inset Formula $n-1$
\end_inset

 disks (from some rod) to the third rod.
 The solution is purely recursive: let 
\begin_inset Formula $S\left(n,h,t\right)$
\end_inset

 be the solution to moving 
\begin_inset Formula $n$
\end_inset

 disks from their 
\begin_inset Quotes eld
\end_inset

home
\begin_inset Quotes erd
\end_inset

 rod 
\begin_inset Formula $h$
\end_inset

 to a target rod 
\begin_inset Formula $t$
\end_inset

.
 Then 
\begin_inset Formula 
\[
S\left(1,h,t\right)=\text{just move the disk}
\]

\end_inset

and 
\begin_inset Formula 
\begin{eqnarray*}
S\left(n,h,t\right) & = & \text{first }S\left(n-1,h,\text{not}\left(h,t\right)\right)\\
 &  & \text{second }S\left(1,h,t\right)\\
 &  & \text{third }S\left(n-1,\text{not}\left(h,t\right),t\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(2^{n}\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Egg drop
\end_layout

\begin_layout Subsubsection

\series bold
2 eggs 100 floors
\end_layout

\begin_layout Standard
Suppose you have 2 eggs and a 100 story building and we want to find out
 the highest floor 
\emph on
an
\emph default
 can be dropped from safely.
 The assumptions are 
\end_layout

\begin_layout Itemize
An egg that survives a fall can be used again.
\end_layout

\begin_layout Itemize
A broken egg must be discarded.
\end_layout

\begin_layout Itemize
The effect of a fall is the same for all eggs.
\end_layout

\begin_layout Itemize
If an egg breaks when dropped from some floor, then it will break if dropped
 from higher floors.
\end_layout

\begin_layout Itemize
If an egg survives a fall, then it would survive a fall from a lower floor.
\end_layout

\begin_layout Standard
Starting from the 14th floor is the best strategy because the number of
 attempts (in the worst case) is always 14.
 Why? If the first egg breaks at the 14th floor then you have to check floors
 1 through 13 with the second egg for a total of 14 floors.
 If the egg doesn't break then move to the 27th floor.
 If it breaks then you have to check floors 15 through 26 for a total of
 
\begin_inset Formula $13+1=14$
\end_inset

.
 Then move to the 39th floor and etc.
 The sequence of floors is 
\begin_inset Formula $14,27,39,50,60,69,77,84,90,95,99,100$
\end_inset

.
 If the egg breaks at any point before getting to floor 100 you have to
 test 13 more floors.
 If it doesn't break until the 100th floor then you have to perform only
 12 drops.
\end_layout

\begin_layout Subsubsection

\series bold
2 eggs 
\begin_inset Formula $k$
\end_inset

 floors
\end_layout

\begin_layout Standard
Suppose that for the best strategy, the number of drops in the worst case
 is 
\begin_inset Formula $x$
\end_inset

.
 Then, you should start at the 
\begin_inset Formula $x$
\end_inset

th floor.
 If the first egg breaks then you have 
\begin_inset Formula $x-1$
\end_inset

 floors to check for a total of 
\begin_inset Formula $1+\left(x-1\right)=x$
\end_inset

 floors to check.
 If it doesn't break then you should check 
\begin_inset Formula $x+\left(x-1\right)$
\end_inset

th floor.
 If it breaks then with the second egg you have to check floors 
\begin_inset Formula $x+1,x+2,\dots,\left(x+\left(x-1\right)-1\right)$
\end_inset

, for a total of 
\begin_inset Formula 
\[
\left(x+\left(x-1\right)-1\right)-\left(x+1\right)+1=x-2
\]

\end_inset

plus the drop at floor 
\begin_inset Formula $x$
\end_inset

 and floor 
\begin_inset Formula $x+\left(x-1\right)$
\end_inset

 makes for a total of 
\begin_inset Formula $x$
\end_inset

 drops.
\end_layout

\begin_layout Standard
What's actually happening is assuming that using the best strategy the minimum
 number of drops is 
\begin_inset Formula $x$
\end_inset

 we are searching for the best strategy that covers all of the floors.
 Suppose the minimum number of attempts, in the worst case, while using
 the best strategy is 
\begin_inset Formula $x$
\end_inset

.
 How many floors can we cover?
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x+\left(x-1\right)+\left(x-2\right)+\cdots+2+1=\frac{x\left(x+1\right)}{2}
\]

\end_inset

So we need 
\begin_inset Formula 
\[
\frac{x\left(x+1\right)}{2}\geq k
\]

\end_inset

or 
\begin_inset Formula 
\[
x=\left\lceil \frac{-1+\sqrt{1+8k}}{2}\right\rceil 
\]

\end_inset

which for 
\begin_inset Formula $k=100$
\end_inset

 implies 
\begin_inset Formula $x=14$
\end_inset

.
\end_layout

\begin_layout Subsubsection

\series bold
N eggs, k floors
\end_layout

\begin_layout Standard
Suppose you have 
\begin_inset Formula $n$
\end_inset

 eggs, 
\begin_inset Formula $h$
\end_inset

 consecutive floors to be tested, and you drop an egg at floor 
\begin_inset Formula $i$
\end_inset

 in this sequence of 
\begin_inset Formula $h$
\end_inset

 floors.
 If the egg breaks then the problem reduces to 
\begin_inset Formula $n-1$
\end_inset

 eggs and 
\begin_inset Formula $i-1$
\end_inset

 remaining floors.
 If the egg doesn't break then the problem reduces to 
\begin_inset Formula $n$
\end_inset

 eggs and 
\begin_inset Formula $h-i$
\end_inset

 remaining floors.
 This is the optimal substructure of the problem: the floors we want to
 test are irrelevant, only their quantity.
 Let 
\begin_inset Formula $W\left(n,h\right)$
\end_inset

 be the minimum number of drops required to find the threshold floor in
 the worst case, while using the best strategy.
 Then 
\begin_inset Formula 
\[
W\left(n,h\right)=1+\min_{i=1,\dots,h}\left(\max\left\{ W\left(n-1,i-1\right),W\left(n,h-i\right)\right\} \right)
\]

\end_inset

If you have only one egg then the minimum number of tests using the best
 strategy (the one that potentially covers all the floors), if the threshold
 floor, is the top one is 
\begin_inset Formula $h$
\end_inset

.
 So 
\begin_inset Formula $W\left(1,h\right)=h$
\end_inset

.
 If there's only 1 floor we only need 1 egg so 
\begin_inset Formula $W\left(n,1\right)=1$
\end_inset

, and if there are no floors then we need 0 eggs so 
\begin_inset Formula $W\left(n,0\right)=0$
\end_inset

.
 Running time is 
\begin_inset Formula $O\left(nh^{2}\right)$
\end_inset

 because of the min over 
\begin_inset Formula $i=1,\dots,h$
\end_inset

.
 Since 
\begin_inset Formula $W\left(n-1,i-1\right)$
\end_inset

 is increasing in 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $W\left(n,h-i\right)$
\end_inset

 is decreasing in 
\begin_inset Formula $i$
\end_inset

 a local min of 
\begin_inset Formula $g\left(i\right)=\max\left\{ W\left(n-1,i-1\right),W\left(n,h-i\right)\right\} $
\end_inset

 is a global min and so you can use binary search so speed the min loop
 to get a running time of 
\begin_inset Formula $O\left(nh\log h\right)$
\end_inset

.
 But there's an even faster solution.
 Recall that 
\begin_inset Formula 
\[
\binom{n}{k}=\frac{n!}{k!\left(n-k\right)!}
\]

\end_inset

and
\begin_inset Formula 
\[
\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}
\]

\end_inset

Let 
\begin_inset Formula $f\left(d,n\right)$
\end_inset

 be the number of floors we can cover using 
\begin_inset Formula $n$
\end_inset

 eggs and with 
\begin_inset Formula $d$
\end_inset

 remaining drops.
 If the egg breaks we will be able to cover 
\begin_inset Formula $f\left(d-1,n-1\right)$
\end_inset

 floors and otherwise 
\begin_inset Formula $f\left(d-1,n\right)$
\end_inset

.
 Hence
\begin_inset Formula 
\[
f\left(d,n\right)=1+f\left(d-1,n-1\right)+f\left(d-1,n\right)
\]

\end_inset

Solving for 
\begin_inset Formula $f$
\end_inset

 solves the problem.
 Let 
\begin_inset Formula $g\left(d,n\right)=f\left(d,n+1\right)-f\left(d,n\right)$
\end_inset

 (an auxiliary function).
 Then substituting in the recurrence relation for 
\begin_inset Formula $f\left(d,n\right)$
\end_inset

 we get
\begin_inset Formula 
\[
g\left(d,n\right)=g\left(d-1,n\right)+g\left(d-1,n-1\right)
\]

\end_inset

which is the recurrence relation for the binomial coefficient, and so it
 seems that 
\begin_inset Formula $g\left(d,n\right)=\binom{d}{n}$
\end_inset

.
 Problem is 
\begin_inset Formula $f\left(0,n\right)=0$
\end_inset

 for all 
\begin_inset Formula $n$
\end_inset

 and so should 
\begin_inset Formula $g\left(0,n\right)$
\end_inset

 but 
\begin_inset Formula $g\left(0,0\right)=\binom{0}{0}=1$
\end_inset

.
 Defining 
\begin_inset Formula $g\left(d,n\right)=\binom{d}{n+1}$
\end_inset

 the recursion is still satisfied and no contradictions.
 
\end_layout

\begin_layout Standard
Now to solve the problme: using a telescoping sum for 
\begin_inset Formula $f\left(d,n\right)$
\end_inset


\begin_inset Formula 
\begin{eqnarray*}
f\left(d,n\right) & = & \left[f\left(d,n\right)-f\left(d,n-1\right)\right]\\
 & + & \left[f\left(d,n-1\right)-f\left(d,n-2\right)\right]\\
 &  & \vdots\\
 & + & \left[f\left(d,1\right)-f\left(d,0\right)\right]\\
 & + & f\left(d,0\right)
\end{eqnarray*}

\end_inset

where 
\begin_inset Formula $f\left(d,0\right)=0$
\end_inset

 we get that 
\begin_inset Formula 
\begin{eqnarray*}
f\left(d,n\right) & = & g\left(d,n-1\right)+g\left(d,n-2\right)+\cdots+g\left(d,0\right)\\
 & = & \binom{d}{n}+\binom{d}{n-1}+\cdots+\binom{d}{1}\\
 & = & \sum_{i=1}^{n}\binom{d}{i}
\end{eqnarray*}

\end_inset

So we just have to find 
\begin_inset Formula $d$
\end_inset

 such that 
\begin_inset Formula 
\[
\sum_{i=1}^{N}\binom{d}{i}\geq k
\]

\end_inset

which can be done in linear time using the relation 
\begin_inset Formula 
\[
\binom{a}{b+1}=\binom{a}{b}\frac{a-b}{b+1}
\]

\end_inset


\end_layout

\begin_layout Subsection
Maximum Positive Subarray/Kidane's algorithm
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

, how to find the subarray with the maximum positive sum? Use dynamic programmin
g solution called Kidane's algorithm.
 Change the problem to look at maximum sum subarray ending at some 
\begin_inset Formula $j$
\end_inset

.
 Maximum sum subarray ending at 
\begin_inset Formula $j$
\end_inset

 is either empty, i.e.
 has negative sum, in which case its sum is 0, or includes 
\begin_inset Formula $A\left[j\right]$
\end_inset

.
 The maximum sum subarray in all of 
\begin_inset Formula $A$
\end_inset

 is the maximum of all subarrays ending at all 
\begin_inset Formula $j$
\end_inset

.
 Running time is 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Kidane-Max-Subarray
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $m$_  is max
\end_layout

\begin_layout Plain Layout

$m_{here} = m_{all} = A
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=2:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	$m_{here} = 
\backslash
max
\backslash
left(0,m_{here}+A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m_{all} = 
\backslash
max
\backslash
left(m_{all},m_{here}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $m_{all}$
\end_layout

\end_inset


\end_layout

\end_inset

Note that if at 
\begin_inset Formula $j-1$
\end_inset

 the subarray was empty, and hence 
\begin_inset Formula $m_{here}=0$
\end_inset

 then at 
\begin_inset Formula $j$
\end_inset

 it's the case that 
\begin_inset Formula $m_{here}=A\left[j\right]$
\end_inset

.
 In order to recover the actual subarray you need to keep track of whether
 counting is reset or subarray is extended.
 Easiest way to do this is using Python tricks.
 In general this is calling keeping 
\begin_inset Quotes eld
\end_inset

back-pointers
\begin_inset Quotes erd
\end_inset

 and works in all such cases for reconstructing the solution (forthwith
 omitted).
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Kidane-Max-Subarray-Mod
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$m_{here} = m_{all} = 
\backslash
left[[~],A
\backslash
left[1
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=2:
\backslash
text{len}
\backslash
left(A
\backslash
right)$: 
\end_layout

\begin_layout Plain Layout

	# take max wrt.
 first entry of arguments, i.e.
 $
\backslash
max
\backslash
left(0,m_{here}+A
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m_{here}=
\backslash
max
\backslash
left(
\backslash
left[0,[~]
\backslash
right],
\backslash
left[m_{here}+A
\backslash
left[i
\backslash
right],m_{here}
\backslash
text{.append}
\backslash
left(A
\backslash
left[i
\backslash
right]
\backslash
right)
\backslash
right] ,
\backslash
text{key=itemgetter}
\backslash
left(1
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$m_{all} = 
\backslash
max
\backslash
left(m_{all},m_{here},
\backslash
text{key=itemgetter}
\backslash
left(1
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $m_{all}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Longest increasing subsequence
\end_layout

\begin_layout Standard
A subsequence of a sequence 
\begin_inset Formula $A=\left[a_{1},a_{2},\dots,a_{n}\right]$
\end_inset

 need not be contiguous.
 Just like in Kidane's algorithm you should be looking at subsequences ending
 at some index 
\begin_inset Formula $i$
\end_inset

: let 
\begin_inset Formula $L\left[i\right]$
\end_inset

 be the longest strictly increasing subsequence ending at index 
\begin_inset Formula $i$
\end_inset

.
 What's the 
\begin_inset Quotes eld
\end_inset

optimal
\begin_inset Quotes erd
\end_inset

 way to obtain 
\begin_inset Formula $L\left[i\right]$
\end_inset

? Extend some smaller optimal subsequence ending at index 
\begin_inset Formula $j$
\end_inset

.
 But when can you extend some subsequence ending at position 
\begin_inset Formula $j$
\end_inset

? Only when 
\begin_inset Formula $A\left[j\right]<A\left[i\right]$
\end_inset

 since it should be an increasing subsequence! Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
LIS
\family default

\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(A
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$L = n
\backslash
cdot
\backslash
left[
\backslash
infty
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	$L
\backslash
left[i
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

	for $j=1:i-1$:
\end_layout

\begin_layout Plain Layout

		if $A
\backslash
left[j
\backslash
right] < A
\backslash
left[i
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			$L
\backslash
left[i
\backslash
right] = 
\backslash
max
\backslash
left
\backslash
{L
\backslash
left[i
\backslash
right],1+L
\backslash
left[j
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

return $
\backslash
max
\backslash
left
\backslash
{L
\backslash
right
\backslash
}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Box stacking
\begin_inset Foot
status open

\begin_layout Plain Layout
From here on down I stole these from https://people.cs.clemson.edu/~bcdean/dp_pract
ice/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You have 
\begin_inset Formula $n$
\end_inset

 boxes 
\begin_inset Formula $B=\left[b_{1},\dots,b_{n}\right]$
\end_inset

 with dimensions height 
\begin_inset Formula $h_{i}$
\end_inset

, width 
\begin_inset Formula $w_{i}$
\end_inset

, and depth 
\begin_inset Formula $d_{i}$
\end_inset

.
 What's the tallest stack of boxes you can make? A box 
\begin_inset Formula $b_{i}$
\end_inset

 can be stacked atop another box 
\begin_inset Formula $b_{j}$
\end_inset

 if 
\begin_inset Formula $b_{i}$
\end_inset

 can oriented such that one of its faces is smaller than the upwarding face
 of 
\begin_inset Formula $b_{j}$
\end_inset

.
 To simplify the problem simply 
\begin_inset Quotes eld
\end_inset

replicate
\begin_inset Quotes erd
\end_inset

 the boxes such that one box with dimensions 
\begin_inset Formula $h_{i},w_{i},d_{i}$
\end_inset

 corresponds to 3 boxes
\begin_inset Formula 
\begin{eqnarray*}
h_{i},w_{i},d_{i} & = & h_{i},w_{i},d_{i}\\
h_{i}^{'},w_{i}^{'},d_{i}^{'} & = & w_{i},d_{i},h_{i}\\
h_{i}^{''},w_{i}^{''},d_{i}^{''} & = & d_{i},h_{i},w_{i}
\end{eqnarray*}

\end_inset

where without loss of generality (i.e.
 fix an orientation of the base 
\begin_inset Formula $w_{i}\times d_{i}$
\end_inset

) we require 
\begin_inset Formula $w_{i}\leq d_{i}$
\end_inset

.
 For example if we have a box of dimension 
\begin_inset Formula $1\times2\times3$
\end_inset

 then really we have 3 boxes 
\begin_inset Formula 
\begin{eqnarray*}
h_{i},w_{i},d_{i} & = & 1,2,3\\
h_{i}^{'},w_{i}^{'},d_{i}^{'} & = & 2,1,3\\
h_{i}^{''},w_{i}^{''},d_{i}^{''} & = & 3,1,2
\end{eqnarray*}

\end_inset

where the requirement that 
\begin_inset Formula $w_{i}\leq d_{i}$
\end_inset

 forces us to define 
\begin_inset Formula $h_{i}^{'},w_{i}^{'},d_{i}^{'}=2,1,3$
\end_inset

 instead of 
\begin_inset Formula $h_{i}^{'},w_{i}^{'},d_{i}^{'}=2,3,1$
\end_inset

 (which would be the same box).
 Call 
\begin_inset Formula $w_{i}\times d_{i}$
\end_inset

 the base of a box.
 So box 
\begin_inset Formula $b_{i}$
\end_inset

 can be stacked atop 
\begin_inset Formula $b_{j}$
\end_inset

 if the base of box 
\begin_inset Formula $b_{i}$
\end_inset

 is smaller than the base of box 
\begin_inset Formula $b_{j}$
\end_inset

.
 This is quite similar to the longest increasing subsequence substructure
 except the relation is geometric rather than simple magnitude: instead
 of just 
\begin_inset Formula $A\left[j\right]<A\left[i\right]$
\end_inset

 we have that 
\begin_inset Formula $w_{i}<w_{j}\,\wedge\,d_{i}<d_{j}$
\end_inset

.
 So what's the algorithm? First sort the boxes (the 
\begin_inset Formula $3n$
\end_inset

 boxes) by decreasing base dimension.
 Why? We didn't do that for the longest increasing subsequence problem right?
 Well the natural ordering of the LIS is the order it's given to us in;
 it's in the statement of the problem that we should look for the longest
 increasing subsequence of the given sequence.
 The boxes aren't presented to us in any given order so we must impose one
 such that we're able to select a longest 
\begin_inset Quotes eld
\end_inset

increasing
\begin_inset Quotes erd
\end_inset

 subsequence, where we've redefined increasing.
 Then the rest is just like longest increasing subsequence (except for base
 comparison).
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

 just like longest increasing subsequence.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Box-Stacking
\family default

\begin_inset Formula $\left(B\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(B
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# let's pretend this returns only the second entry, i.e.
 the $b_i$
\end_layout

\begin_layout Plain Layout

$B = 
\backslash
text{sorted}
\backslash
left(
\backslash
left[ 
\backslash
left(b
\backslash
left[
\backslash
text{'w'}
\backslash
right] 
\backslash
times b
\backslash
left[
\backslash
text{'d'}
\backslash
right],b 
\backslash
right) 
\backslash
text{for }b
\backslash
text{ in } B
\backslash
right],
\backslash
text{key}=
\backslash
text{itemgetter}
\backslash
left(1
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$L = n
\backslash
cdot
\backslash
left[
\backslash
infty
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	$L
\backslash
left[i
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

	for $j=1:i-1$:
\end_layout

\begin_layout Plain Layout

		if $B
\backslash
left[j
\backslash
right]
\backslash
left[
\backslash
text{'w'}
\backslash
right] < B
\backslash
left[i
\backslash
right]
\backslash
left[
\backslash
text{'w'}
\backslash
right]$ and $B
\backslash
left[j
\backslash
right]
\backslash
left[
\backslash
text{'d'}
\backslash
right] < B
\backslash
left[i
\backslash
right]
\backslash
left[
\backslash
text{'d'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			$L
\backslash
left[i
\backslash
right] = 
\backslash
max
\backslash
left
\backslash
{L
\backslash
left[i
\backslash
right],1+L
\backslash
left[j
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

return $
\backslash
max
\backslash
left
\backslash
{L
\backslash
right
\backslash
}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Bridge crossings
\end_layout

\begin_layout Standard
You have a river crossing a state with 
\begin_inset Formula $n$
\end_inset

 cities on the south bank and 
\begin_inset Formula $n$
\end_inset

 corresponding cities on the north bank (not necessarily in the same order).
 You want to build as many bridges connecting corresponding cities as possible
 without building bridges that intersect.
 Let 
\begin_inset Formula $x_{i}$
\end_inset

 be the index of the city on the north shore corresponding to the 
\begin_inset Formula $i$
\end_inset

th city on the south shore.
 You can figure this out if you're just given the two lists, i.e.
 integer array 
\begin_inset Formula $S=\left[1,2,\dots,n\right]$
\end_inset

 to label the southshore cities and integer array 
\begin_inset Formula $N=\left[\sigma\left(1\right),\sigma\left(2\right),\dots,\sigma\left(n\right)\right]$
\end_inset

 for the permutation on the northshore, by sorting the northshore array
 (while keeping track which index the elements get sorted 
\series bold
from
\series default
 - think about it and you'll understand).
 Then you just need to find the longest increasing subsequence of the 
\begin_inset Formula $x_{i}$
\end_inset

 array.
 Why? A maximal matching with the already sorted sequence of cities on the
 southshore is exactly what that is - in fact this is a pretty good model
 of increasing subsequence period.
 Running time is 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

 just like longest increasing subsequence.
\end_layout

\begin_layout Subsection
Integer Knapsack
\end_layout

\begin_layout Standard
You're a thief with a knapsack that has a finite capacity 
\begin_inset Formula $C$
\end_inset

.
 You break into a store that has 
\begin_inset Formula $n$
\end_inset

 items with integer sizes 
\begin_inset Formula $s_{i}$
\end_inset

 and values 
\begin_inset Formula $v_{i}$
\end_inset

.
 Which items should you steal? You can only take whole items and you're
 allowed duplicates.
 The subproblems here are filling smaller knapsacks duh.
 So let 
\begin_inset Formula $M\left(j\right)$
\end_inset

 be the maximum value obtained by filling a knapsack with capacity exactly
 
\begin_inset Formula $j$
\end_inset

.
 The maximum value 
\begin_inset Formula $j$
\end_inset

 capacity knapsack that can be constructed is either equal to the maximum
 
\begin_inset Formula $j-1$
\end_inset

 capacity knapsack that can be constructed or it includes item 
\begin_inset Formula $i$
\end_inset

 and all of the items in the 
\begin_inset Formula $j-s_{i}$
\end_inset

 capacity knapsack.
 Therefore the Bellman equation is
\begin_inset Formula 
\[
M\left(j\right)=\max\left\{ M\left(j-1\right),\max_{i}\left\{ M\left(i-1,j-s_{i}\right)+v_{i}\right\} \right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(nC\right)$
\end_inset

 because you compute 
\begin_inset Formula $C$
\end_inset

 entries but each computation considers 
\begin_inset Formula $n$
\end_inset

 items.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Integer-Knapsack
\family default

\begin_inset Formula $\left(S,V,C\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $S$ is an array of integer sizes, $V$ is an array of values,
\end_layout

\begin_layout Plain Layout

# and $C$ is the capacity of the knapsack
\end_layout

\begin_layout Plain Layout

$M = C
\backslash
cdot
\backslash
left[0
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $j=1:C$:
\end_layout

\begin_layout Plain Layout

	$M
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right] = 
\backslash
max
\backslash
left
\backslash
{M
\backslash
left[j-1
\backslash
right],M
\backslash
left[i-1
\backslash
right]
\backslash
left[j-S
\backslash
left[i
\backslash
right]
\backslash
right] + V
\backslash
left[i
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

return $M
\backslash
left[C
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
0/1 Knapsack
\end_layout

\begin_layout Standard
In this instance you can only take whole items (that's the 0/1) and there
 are no duplicates.
 The subproblems here are the optimal value for filling a knapsack with
 capacity exactly 
\begin_inset Formula $j$
\end_inset

 and with some subset of the items 
\begin_inset Formula $1,\dots,i$
\end_inset

.
 
\begin_inset Formula $M\left(i,j\right)$
\end_inset

 either includes items 
\begin_inset Formula $i$
\end_inset

, in which case it includes all of the items of the optimal knapsack over
 the items 
\begin_inset Formula $1,\dots,i-1$
\end_inset

, with capacity 
\begin_inset Formula $j-s_{i}$
\end_inset

, and in which case it has value 
\begin_inset Formula $M\left(i-1,j-s_{i}\right)+v_{i}$
\end_inset

, or it does not include item 
\begin_inset Formula $i$
\end_inset

, in which case it has capacity 
\begin_inset Formula $j$
\end_inset

 and has value 
\begin_inset Formula $M\left(i-1,j\right)$
\end_inset

.
 Hence the Bellman equation is 
\begin_inset Formula 
\[
M\left(i,j\right)=\max\left\{ M\left(i-1,j\right),M\left(i-1,j-s_{i}\right)+v_{i}\right\} 
\]

\end_inset

Then the solution to the whole problem is not 
\begin_inset Formula $M\left(n,C\right)$
\end_inset

 but 
\begin_inset Formula $\max_{j}\left\{ M\left(n,j\right)\right\} $
\end_inset

 because you might not need to use the entire capacity.
 Running time is still 
\begin_inset Formula $O\left(nC\right)$
\end_inset

 because there are 
\begin_inset Formula $n\times C$
\end_inset

 subproblems.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
0-1Knapsack
\family default

\begin_inset Formula $\left(S,V,C\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $S$ is an array of integer sizes, $V$ is an array of integer values,
\end_layout

\begin_layout Plain Layout

# and $C$ is the capacity of the knapsack
\end_layout

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(S
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$M = n
\backslash
cdot
\backslash
left[C
\backslash
cdot
\backslash
left[0
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	for $j=1:C$:
\end_layout

\begin_layout Plain Layout

		$M
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right] = 
\backslash
max
\backslash
left
\backslash
{M
\backslash
left[i-1
\backslash
right]
\backslash
left[j
\backslash
right],M
\backslash
left[i-1
\backslash
right]
\backslash
left[j-S
\backslash
left[i
\backslash
right]
\backslash
right] + V
\backslash
left[i
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

return $
\backslash
max
\backslash
left
\backslash
{M
\backslash
left[n
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Balanced Partition
\end_layout

\begin_layout Standard
You get 
\begin_inset Formula $n$
\end_inset

 integers 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

, each in the range 
\begin_inset Formula $0,\dots,k$
\end_inset

, and the goal is to partition 
\begin_inset Formula $A$
\end_inset

 into two sets 
\begin_inset Formula $S_{1},S_{2}$
\end_inset

 minimizing 
\begin_inset Formula $\left|\text{sum}\left(S_{1}\right)-\text{sum}\left(S_{2}\right)\right|$
\end_inset

.
 This is similar to the knapsack problem (probably for the same reason that
 general knapsack is reducible to subset sum).
 The analogy is between capacity and summing to some 
\begin_inset Formula $j$
\end_inset

 and items from the set 
\begin_inset Formula $A$
\end_inset

 playing the role of store items.
 Let 
\begin_inset Formula $P\left(i,j\right)$
\end_inset

 be a boolean that reports whether some subset of 
\begin_inset Formula $\left[a_{1},\dots,a_{i}\right]$
\end_inset

 sum to 
\begin_inset Formula $j$
\end_inset

.
 Then 
\begin_inset Formula $P\left(i,j\right)=1$
\end_inset

 if some subset of 
\begin_inset Formula $\left[a_{1},\dots,a_{i-1}\right]$
\end_inset

 sum to 
\begin_inset Formula $j$
\end_inset

, in which case we don't need to include item 
\begin_inset Formula $i$
\end_inset

, or if some subset of 
\begin_inset Formula $\left[a_{1},\dots,a_{i-1}\right]$
\end_inset

 sums to 
\begin_inset Formula $j-a_{i}$
\end_inset

, in which case we include item 
\begin_inset Formula $a_{i}$
\end_inset

 to get a subset that sums to 
\begin_inset Formula $j$
\end_inset

.
 Hence the Bellman equation is 
\begin_inset Formula 
\[
P\left(i,j\right)=\begin{cases}
1 & \text{if }P\left(i-1,j\right)=1\text{ or }P\left(i-1,j-a_{i}\right)=1\\
0 & \text{otherwise}
\end{cases}
\]

\end_inset

More succinctly 
\begin_inset Formula 
\[
P\left(i,j\right)=\max\left\{ P\left(i-1,j\right),P\left(i-1,j-a_{i}\right)\right\} 
\]

\end_inset

Note this is just a logical or, i.e.
 ||.
 There are 
\begin_inset Formula $n^{2}k$
\end_inset

 problems because 
\begin_inset Formula $i$
\end_inset

 range from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset

 but each 
\begin_inset Formula $a_{i}$
\end_inset

 could have value 
\begin_inset Formula $k$
\end_inset

 so 
\begin_inset Formula $j$
\end_inset

 ranges from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $nk$
\end_inset

.
 How do you use this to solve the original problem? Let 
\begin_inset Formula $S=\sum a_{i}/2$
\end_inset

.
 Then the subset 
\begin_inset Formula $S_{j}$
\end_inset

 such that 
\begin_inset Formula 
\[
\min_{j\leq S}\left\{ S-j\big|P\left(n,j\right)=1\right\} 
\]

\end_inset

produces the solution.
 Running time is the same 
\begin_inset Formula $O\left(n^{2}k\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Longest common subsequence
\end_layout

\begin_layout Standard
Given two strings 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 and 
\begin_inset Formula $B=\left[b_{1},\dots,b_{m}\right]$
\end_inset

 what is the longest common subsequence? Let 
\begin_inset Formula $Z=\left[z_{1},\dots,z_{k}\right]$
\end_inset

 be such a longest common subsequence.
 Working backwards: if 
\begin_inset Formula $a_{n}=b_{m}$
\end_inset

 then 
\begin_inset Formula $z_{k}=a_{n}=b_{m}$
\end_inset

 and 
\begin_inset Formula $\left[z_{1},\dots,z_{k-1}\right]$
\end_inset

 is a longest common subsequence of 
\begin_inset Formula $\left[a_{1},\dots,a_{n-1}\right]$
\end_inset

 and 
\begin_inset Formula $\left[b_{1},\dots,b_{m-1}\right]$
\end_inset

.
 Suppose that the two sequences 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 do not end in the same symbol.
 Then the longest common subsequence of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 is the longer of the two sequences LCS
\begin_inset Formula $\left(\left[a_{1},\dots,a_{n}\right],\left[b_{1},\dots,b_{m-1}\right]\right)$
\end_inset

 and LCS
\begin_inset Formula $\left(\left[a_{1},\dots,a_{n-1}\right],\left[b_{1},\dots,b_{m}\right]\right)$
\end_inset

.
 Why? Consider the two following sequences: 
\begin_inset Formula $A=\left[123467\right]$
\end_inset

 and 
\begin_inset Formula $B=\left[23470\right]$
\end_inset

.
 The LCS of these two sequences either ends with a 7 (the last element of
 sequence 
\begin_inset Formula $A$
\end_inset

) or does not.
 If the LCS does end with a 7 then it cannot end with 0, thus we can discard
 the 0 on the end of 
\begin_inset Formula $B$
\end_inset

 and LCS
\begin_inset Formula $\left(A,B\right)=\text{LCS}\left(A,\left[2347\right]\right)$
\end_inset

.
 If it does not end in 7 then we can similarly discard 7 and LCS
\begin_inset Formula $\left(A,B\right)=\text{LCS}\left(\left[123467\right],\left[23470\right]\right)$
\end_inset

.
 In either case we're considering either LCS
\begin_inset Formula $\left(\left[a_{1},\dots,a_{n}\right],\left[b_{1},\dots,b_{m-1}\right]\right)$
\end_inset

 or LCS
\begin_inset Formula $\left(\left[a_{1},\dots,a_{n-1}\right],\left[b_{1},\dots,b_{m}\right]\right)$
\end_inset

, and in fact the longest of the two.
 Hence the Bellman equation is
\begin_inset Formula 
\[
\text{LCS}\left(\left[a_{1},\dots,a_{i}\right],\left[b_{1},\dots,b_{j}\right]\right)=\begin{cases}
0 & \text{if }i=0\text{ or }j=0\\
\text{LCS}\left(\left[a_{1},\dots,a_{i-1}\right],\left[b_{1},\dots,b_{j-1}\right]\right)+1 & \text{if }a_{i}=b_{j}\\
\max\left\{ LCS\left(\left[a_{1},\dots,a_{i}\right],\left[b_{1},\dots,b_{j-1}\right]\right),\left(\left[a_{1},\dots,a_{i-1}\right],\left[b_{1},\dots,b_{j}\right]\right)\right\}  & \text{if }a_{i}\neq b_{j}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(nm\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Edit distance
\end_layout

\begin_layout Standard
Given two strings 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 and 
\begin_inset Formula $B=\left[b_{1},\dots,b_{m}\right]$
\end_inset

 what is minimum the 
\begin_inset Quotes eld
\end_inset

cost
\begin_inset Quotes erd
\end_inset

 of transforming one string into the other, where the costs associated with
 insertion, deletion, and replacement are 
\begin_inset Formula $C_{i},C_{d},C_{r}$
\end_inset

 respectively.
 The subproblems here are similar to those in longest common subsequence.
 Let 
\begin_inset Formula $T\left(i,j\right)$
\end_inset

 be the minimum cost of transforming 
\begin_inset Formula $\left[a_{1},\dots,a_{i}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j}\right]$
\end_inset

.
 There are 4 ways to transform 
\begin_inset Formula $\left[a_{1},\dots,a_{i}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j}\right]$
\end_inset

: either delete 
\begin_inset Formula $a_{i}$
\end_inset

 and transform 
\begin_inset Formula $\left[a_{1},\dots,a_{i-1}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j}\right]$
\end_inset

, transform 
\begin_inset Formula $\left[a_{1},\dots,a_{i}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j-1}\right]$
\end_inset

 then insert 
\begin_inset Formula $b_{j}$
\end_inset

, or replace 
\begin_inset Formula $a_{i}$
\end_inset

 with 
\begin_inset Formula $b_{j}$
\end_inset

 and then transform 
\begin_inset Formula $\left[a_{1},\dots,a_{i-1}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j-1}\right]$
\end_inset

.
 Finally if 
\begin_inset Formula $a_{i}=b_{j}$
\end_inset

 then just transform 
\begin_inset Formula $\left[a_{1},\dots,a_{i-1}\right]$
\end_inset

 into 
\begin_inset Formula $\left[b_{1},\dots,b_{j-1}\right]$
\end_inset

.
 Therefore the Bellman equation is
\begin_inset Formula 
\[
T\left(i,j\right)=\min\left\{ C_{d}+T\left(i-1,j\right),T\left(i,j-1\right)+C_{i},T\left(i-1,j-1\right)+C_{r},T\left(i-1,j-1\right)\text{ if }a_{i}=b_{j}\right\} 
\]

\end_inset

Running time is 
\begin_inset Formula $O\left(nm\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Counting Boolean Parenthesizations
\end_layout

\begin_layout Standard
Given a boolean expression with 
\begin_inset Formula $n$
\end_inset

 literals and 
\begin_inset Formula $n-1$
\end_inset

 operators how many different ways are there to parenthesize such that the
 expression evaluates to true.
 Let 
\begin_inset Formula $T\left(i,j\right)$
\end_inset

 be the number of ways to parenthesize literal 
\begin_inset Formula $i$
\end_inset

 through 
\begin_inset Formula $j$
\end_inset

 such that the subexpression evaluates to true and 
\begin_inset Formula $F\left(i,j\right)$
\end_inset

 to be the number of ways such that the subexpression evaluates to false.
 The base cases 
\begin_inset Formula $T\left(i,i\right),F\left(i,i\right)$
\end_inset

 are just function of the literals.
 Note that 
\begin_inset Formula $i<j$
\end_inset

 so we then seek to compute 
\begin_inset Formula $T\left(i,i+1\right),F\left(i,i+1\right),T\left(i,i+2\right),F\left(i,i+2\right)$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

.
 How? Well 
\begin_inset Formula $T\left(i,j\right)$
\end_inset

 is always a function of two subexpression and the operand between them:
 the literals from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

 and from 
\begin_inset Formula $k+1$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

.
 For example if the operand is 
\begin_inset Formula $\wedge$
\end_inset

 then 
\begin_inset Formula $T\left(i,j\right)>T\left(i,k\right)\cdot T\left(k+1,j\right)$
\end_inset

 since the expression including the literals from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

 will be true for any values of the subexpression from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

 which evaluate to true and any values of the subexpression 
\begin_inset Formula $k+1$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

 which evaluate to true.
 If the operator were 
\begin_inset Formula $\vee$
\end_inset

 then it would be 
\begin_inset Formula $T\left(i,k\right)\cdot T\left(k+1,j\right)+T\left(i,k\right)\cdot F\left(k+1,j\right)+F\left(i,k\right)\cdot T\left(k+1,j\right)$
\end_inset

.
 And we need to sum over all possible splits 
\begin_inset Formula $k$
\end_inset

.
 So the Bellman equation is 
\begin_inset Formula 
\[
T\left(i,j\right)=\sum_{i\leq k\leq j-1}\begin{cases}
T\left(i,k\right)\cdot T\left(k+1,j\right) & \text{if }k\text{th operator is }\wedge\\
T\left(i,k\right)\cdot T\left(k+1,j\right)+T\left(i,k\right)\cdot F\left(k+1,j\right)+F\left(i,k\right)\cdot T\left(k+1,j\right) & \text{if }k\text{th operator is }\vee\\
T\left(i,k\right)\cdot F\left(k+1,j\right)+F\left(i,k\right)\cdot T\left(k+1,j\right) & \text{\text{if }k\text{th operator is }xor}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(n^{3}\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Coin game
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $n$
\end_inset

 coins layed out in a row with values 
\begin_inset Formula $v_{1},\dots,v_{n}$
\end_inset

 you play a game against an opponent where on each turn you pick up one
 of the two outside coins.
 The goal is to maximize the sum of the value of the selected coins.
 Let 
\begin_inset Formula $V\left(i,j\right)$
\end_inset

 be the maximum value you can 
\series bold
definitely 
\series default
win if it's your turn and only the voince 
\begin_inset Formula $v_{i},\dots,v_{j}$
\end_inset

 remain.
 The base cases 
\begin_inset Formula $V\left(i,i\right)$
\end_inset

 and 
\begin_inset Formula $V\left(i,i+1\right)$
\end_inset

 are easily to compute.
 We seek to compute 
\begin_inset Formula $V\left(i,i+2\right)$
\end_inset

 and etc.
 We need to think two steps ahead to compute arbitrary 
\begin_inset Formula $V\left(i,j\right)$
\end_inset

: if we pick 
\begin_inset Formula $v_{i}$
\end_inset

 then our opponent will either pick the 
\begin_inset Formula $j$
\end_inset

th coin of the 
\begin_inset Formula $i+1$
\end_inset

th coin.
 Reasoning conservatively (the opponent will pick the better) we will be
 presented with the minimum possible scenario of coins 
\begin_inset Formula $i+1,\dots,j-1$
\end_inset

 and 
\begin_inset Formula $i+2,\dots,j$
\end_inset

.
 If we pick 
\begin_inset Formula $v_{j}$
\end_inset

 then similarly we will be presented with the minimum possible scenario
 of coins 
\begin_inset Formula $i,\dots,j+2$
\end_inset

 and 
\begin_inset Formula $i+1,\dots,j-1$
\end_inset

.
 Therefore the Bellman equation is
\begin_inset Formula 
\[
V\left(i,j\right)=\max\left\{ \underset{\text{pick }v_{i}}{\underbrace{\min\left\{ V\left(i+1,j-1\right),V\left(i+2,j\right)\right\} +v_{i}}},\underset{\text{pick }v_{j}}{\underbrace{\min\left\{ V\left(i,j+2\right),V\left(i+1,j-1\right)\right\} +v_{j}}}\right\} 
\]

\end_inset


\end_layout

\begin_layout Section
Greedy Algorithms
\end_layout

\begin_layout Standard
Greedy algorithms are like dynamic programming algorithms except there's
 only one subproblem.
 They're a lot easier to construct than DP algorithms (but take a little
 arguing to prove they're correct).
\end_layout

\begin_layout Subsection
Activity scheduling
\end_layout

\begin_layout Standard
Suppose you have a set of activities 
\begin_inset Formula $A=\left[a_{1},\dots,a_{n}\right]$
\end_inset

 with sorted start times 
\begin_inset Formula $S=\left[s_{1},\dots,s_{n}\right]$
\end_inset

and sorted finish times 
\begin_inset Formula $F=\left[f_{1},\dots,f_{n}\right]$
\end_inset

.
 How to schedule the most non-overlapping acitivities? Let 
\begin_inset Formula $S_{ij}$
\end_inset

 be the set of activities that start after 
\begin_inset Formula $a_{i}$
\end_inset

 finishes and end before 
\begin_inset Formula $a_{j}$
\end_inset

 starts.
 Standard DP argument (partitioning around a parking activity 
\begin_inset Formula $a_{k}$
\end_inset

 leads to the Bellman equation for 
\begin_inset Formula $C\left(i,j\right)$
\end_inset

 the maximal number of activities is
\begin_inset Formula 
\[
C\left(i,j\right)=\begin{cases}
0 & \text{\text{if }}S_{ij}=\emptyset\\
\max_{a_{k}\in S_{ij}}\left\{ C\left(i,k\right)+C\left(k,j\right)+1\right\}  & \text{\text{if }}S_{ij}\neq\emptyset
\end{cases}
\]

\end_inset

Then memoize or bottom-up it and you have an 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

 DP algorithm.
 But there's an obvious greedy algorithm: always pick the job that doesn't
 overlap with already picked jobs and ends the soonest.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Greedy-Activity
\family default

\begin_inset Formula $\left(A,S,F\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ n = 
\backslash
text{len}
\backslash
left(S
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# assume $a_1$ is the job that ends first
\end_layout

\begin_layout Plain Layout

$ J = 
\backslash
left[A
\backslash
left[1
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$ k = 1$
\end_layout

\begin_layout Plain Layout

for $m = 2:n$:
\end_layout

\begin_layout Plain Layout

	if $F
\backslash
left[k
\backslash
right] 
\backslash
leq S
\backslash
left[m
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$J
\backslash
text{.append}
\backslash
left(A
\backslash
left[m
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$k = m$
\end_layout

\begin_layout Plain Layout

return $A$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Fractional Knapsack
\end_layout

\begin_layout Standard
This is the same as Integer Knapsack but you can take fractions of items
 (imagine you broke into a spice shop).
 The greedy strategy that optimally picks items is one that chooses items
 that give most bang per weight, a kind of value density: pick as much of
 the item that has the highest 
\begin_inset Formula $v_{i}/w_{i}$
\end_inset

 until it's exhausted.
 Then continue on to the next most value dense item.
\end_layout

\begin_layout Subsection
Huffman codes
\end_layout

\begin_layout Standard
What's the most optimal way to encode a message using a 
\begin_inset Formula $\left\{ 0,1\right\} $
\end_inset

 code given the distribution over the input alphabet? Letters that appear
 most often should have the smallest code words and conversely letters that
 appear rarely should have the longest code words.
 Using prefix-free codes (codes such that no codeword is a prefix of any
 other codeword) we can achieve optimal compression so without loss of generalit
y we can use them, and we will since they make things easiest.
 
\end_layout

\begin_layout Standard
Given the frequency distribution 
\begin_inset Formula $C$
\end_inset

 we can construct a binary tree called a Huffman tree whose traversal produces
 the prefix-free codes using a min-queue.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Huffman-Tree
\family default

\begin_inset Formula $\left(C\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ n = 
\backslash
text{len}
\backslash
left(C
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# "cast" $C$ to be a min-priority-queue
\end_layout

\begin_layout Plain Layout

$ Q = 
\backslash
text{minQueue}
\backslash
left(C
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $i = 1:n-1$:
\end_layout

\begin_layout Plain Layout

	$z = 
\backslash
text{btree}
\backslash
left(
\backslash
text{None},
\backslash
text{next}
\backslash
left(c
\backslash
right),
\backslash
text{None},
\backslash
text{None},
\backslash
text{None}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$z
\backslash
left[
\backslash
text{'lchild'}
\backslash
right] = x =  
\backslash
text{Extract-Min}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$z
\backslash
left[
\backslash
text{'rchild'}
\backslash
right] = y =  
\backslash
text{Extract-Min}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# 'val' is character frequency
\end_layout

\begin_layout Plain Layout

	$z
\backslash
left[
\backslash
text{'val'}
\backslash
right] = x
\backslash
left[
\backslash
text{'val'}
\backslash
right] + y
\backslash
left[
\backslash
text{'val'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	Insert$
\backslash
left(Q,z
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# return root of tree
\end_layout

\begin_layout Plain Layout

return Extract-Min$
\backslash
left(Q
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset

Running time is 
\begin_inset Formula $O\left(n\log n\right)$
\end_inset

 due to the min-queue operations.
 Constructing the codes is done by performing a depth-first traversal of
 the Huffman tree and keeping track of lefts and rights (zeros and ones).
\end_layout

\begin_layout Subsection
Making change with unlimited coins
\end_layout

\begin_layout Standard
Consider the problem of making change for 
\begin_inset Formula $n$
\end_inset

 cents using the fewest number of coins 
\begin_inset Formula $K=\left[c_{1},\dots,c_{k}=1\right]$
\end_inset

.
 Assume each coin's value is an integer.
 If the coins are the US quarters, dimes, nickels, and pennies then a greedy
 algorith is optimal: change as much for quarters as you can, then as much
 for dimes, etc.
 The greedy strategy does not always work: suppose the coins are of denomination
 
\begin_inset Formula $4\cent,3\cent,1\cent$
\end_inset

 to change 
\begin_inset Formula $6\cent$
\end_inset

.
 In general you need to use dynamic programming - solution is similar to
 integer knapsack with duplicates.
 Let 
\begin_inset Formula $C\left(i\right)$
\end_inset

 be the optimal number of coins used to make change for 
\begin_inset Formula $i\cent$
\end_inset

 using any of the coins.
 The minimum number of coins needed to change 
\begin_inset Formula $i$
\end_inset

 is 1 plus 
\begin_inset Formula $C\left(i-c_{j}\right)$
\end_inset

 where 
\begin_inset Formula $c_{j}$
\end_inset

 is the coin denomination that minimizes 
\begin_inset Formula $C\left(i-c_{j}\right)$
\end_inset

 and 
\begin_inset Formula $c_{j}<i$
\end_inset

.
 Therefore the Bellman equation is 
\begin_inset Formula 
\[
C\left(i\right)=\min_{j}\left\{ C\left(i-c_{j}\right)\bigg|c_{j}<i\right\} +1
\]

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(nk\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Making change with fixed coins
\end_layout

\begin_layout Standard
Here is another solution.
 I don't understand why there should be another solution but here it is.
 Suppose the coins come sorted in decreasing order so 
\begin_inset Formula $c_{1}>c_{2}>\cdots>c_{k}=1$
\end_inset

.
 Let 
\begin_inset Formula $C\left(i,j\right)$
\end_inset

 be the optimal number of coins used to make change for 
\begin_inset Formula $i\cent$
\end_inset

 using only coins 
\begin_inset Formula $j,\dots,k$
\end_inset

.
 We either use coin 
\begin_inset Formula $c_{j}$
\end_inset

 or we don't.
 If we do not then we're solving the problem 
\begin_inset Formula $C\left(i,j+1\right)$
\end_inset

.
 For example we might not use coin 
\begin_inset Formula $c_{j}$
\end_inset

 if 
\begin_inset Formula $c_{j}>i$
\end_inset

.
 If we do use coin 
\begin_inset Formula $c_{j}$
\end_inset

 then the rest 
\begin_inset Formula $\left(i-c_{j}\right)\cent$
\end_inset

 needs to be changed, potentially using the coin 
\begin_inset Formula $j$
\end_inset

 again.
 
\begin_inset Formula 
\[
C\left(i,j\right)=\begin{cases}
C\left(i,j+1\right) & \text{if }c_{j}>i\\
\min_{j}\left\{ C\left(i,j+1\right),C\left(i-c_{j},j\right)+1\right\}  & \text{if }c_{j}\leq i
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Running time is also 
\begin_inset Formula $O\left(nk\right)$
\end_inset

.
\end_layout

\begin_layout Part
Graph Algorithms
\end_layout

\begin_layout Section
Representations of Graphs
\end_layout

\begin_layout Standard
There are two ways to represent a graph 
\begin_inset Formula $G=\left(E,V\right)$
\end_inset

: 
\series bold
adjacency matrix
\series default
 and 
\series bold
adjacency list
\series default
.
 
\end_layout

\begin_layout Subsection
Adjaceny matrix
\end_layout

\begin_layout Standard
The former is a table with 
\begin_inset Formula $n=\left|V\right|$
\end_inset

 rows and 
\begin_inset Formula $n$
\end_inset

 columns and with an entry in row 
\begin_inset Formula $i$
\end_inset

 column 
\begin_inset Formula $j$
\end_inset

 if there's an edge between vertex 
\begin_inset Formula $i$
\end_inset

 and vertex 
\begin_inset Formula $j$
\end_inset

.
 The value of the entry could be anything from simply 1 to indicate an undirecte
d edge, 
\begin_inset Formula $-1$
\end_inset

 to represent a directed edge, 
\begin_inset Formula $k$
\end_inset

 to represent an edge weight, 
\begin_inset Formula $0$
\end_inset

 to represent no edge.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Adjacency-Matrix
\family default

\begin_inset Formula $\left(n,E\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# n is the number of vertices, $E$ is the edge list (a list of tuples)
\end_layout

\begin_layout Plain Layout

# default is directed (so double edges indicate undirected)
\end_layout

\begin_layout Plain Layout

$mat = n
\backslash
cdot
\backslash
left[n
\backslash
cdot
\backslash
left[0
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $u,v,w$ in $E$:
\end_layout

\begin_layout Plain Layout

	$mat
\backslash
left[u
\backslash
right]
\backslash
left[v
\backslash
right] = w$
\end_layout

\begin_layout Plain Layout

return $mat$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Adjacency list
\end_layout

\begin_layout Standard
The latter is a list of lists where the 
\begin_inset Formula $i$
\end_inset

 entry in the list is a list containing all 
\begin_inset Formula $j$
\end_inset

 such that edge 
\begin_inset Formula $\left(i,j\right)\in E$
\end_inset

.
 Most algorithms in this section will use the adjacency list representation.
 Further more we assume that other attributes will be stored in a hash table
 keyed on the vertex 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

, which is a number.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Adjacency-list
\family default

\begin_inset Formula $\left(n,E\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# n is the number of vertices, $E$ is the edge list (a list of tuples)
\end_layout

\begin_layout Plain Layout

# default is directed (so double edges indicate undirected
\end_layout

\begin_layout Plain Layout

$adj = n
\backslash
cdot
\backslash
left[
\backslash
left[~
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $u,v,w$ in $E$:
\end_layout

\begin_layout Plain Layout

	$adj
\backslash
left[u
\backslash
right]
\backslash
text{.append}
\backslash
left(
\backslash
left(v,w
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $adj$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Transpose
\end_layout

\begin_layout Standard
The transpose graph 
\begin_inset Formula $G^{T}=\left(V,E^{T}\right)$
\end_inset

 where 
\begin_inset Formula $\left(u,v\right)\in E^{T}$
\end_inset

 iff 
\begin_inset Formula $\left(v,u\right)\in E^{T}$
\end_inset

, i.e.
 reverse all the arrows.
 Computing the transpose graph when a graph is represented by an adjacency
 matrix amounts to just transposing the matrix.
 When the original graph is represented by adjacency lists it's a little
 more complicated but pretty obvious regardless.
\end_layout

\begin_layout Section
Breadth-first Search
\end_layout

\begin_layout Standard
A bread-first search is exactly what it sounds like: all vertices at a certain
 breadth (distance) are visited, then the next breadth, then the next breadth,
 and so on.
 In order to repeatedly the same vertices we need to keep track of which
 vertices we've visited.
 The most elegant way is to "decorate" by constructing tuples 
\begin_inset Formula $\left(i,visited\right)$
\end_inset

 and unpacking.
 An easier way is to just have a hash table that stores that attribute.
 Running time is 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Breadth-first-search
\family default

\begin_inset Formula $\left(s\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $A$ is an adjacency list and $s$ is a source 
\end_layout

\begin_layout Plain Layout

# from which to start searching.
 'state' $=0$ means unvisited,
\end_layout

\begin_layout Plain Layout

# $=1$ means visited but not explored, $=2$ means explored
\end_layout

\begin_layout Plain Layout

$attrs = 
\backslash
{i:
\backslash
{
\backslash
text{'state':0},
\backslash
text{'d':}
\backslash
infty,
\backslash
text{'prnt':None}
\backslash
}
\end_layout

\begin_layout Plain Layout

			
\backslash
text{ for } i=1:n 
\backslash
}$ 
\end_layout

\begin_layout Plain Layout

$attrs
\backslash
left[s
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

$attrs
\backslash
left[s
\backslash
right]
\backslash
left[
\backslash
text{'d'}
\backslash
right] = 0$
\end_layout

\begin_layout Plain Layout

$Q = 
\backslash
left[s
\backslash
right]$
\end_layout

\begin_layout Plain Layout

while len$
\backslash
left(Q
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$u = Q
\backslash
text{.popleft}
\backslash
left(
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	for each $v 
\backslash
in A
\backslash
left[u
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		if $attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] == 0$:
\end_layout

\begin_layout Plain Layout

			$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

			$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'d'}
\backslash
right] = attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'d'}
\backslash
right] + 1$
\end_layout

\begin_layout Plain Layout

			$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = u$
\end_layout

\begin_layout Plain Layout

			$Q
\backslash
text{.append}
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] = 2$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Depth-first Search
\end_layout

\begin_layout Standard
A depth-first search is exactly what it sounds like: go as deep as possible
 then back up until you can go deep again, and so on.
 For depth search we also keep track of what are called opening and closing
 times; they're useful for other algorithms like topological sort.
 Running time is 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Depth-First-Search
\family default

\begin_inset Formula $\left(s\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$attrs = 
\backslash
{i:
\backslash
{
\backslash
text{'state':0},
\backslash
text{'opentime': None},
\backslash
text{'closetime': None},
\backslash
text{'prnt':None}
\backslash
} 
\end_layout

\begin_layout Plain Layout

			
\backslash
text{ for } i=1:n 
\backslash
}$ 
\end_layout

\begin_layout Plain Layout

$time = 0$
\end_layout

\begin_layout Plain Layout

# list of vertices visited
\end_layout

\begin_layout Plain Layout

$visited = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$S = 
\backslash
left[s
\backslash
right]$
\end_layout

\begin_layout Plain Layout

while len$
\backslash
left(S
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$time = time + 1$
\end_layout

\begin_layout Plain Layout

	$u = S
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# if we come back to this point in the stack after having 
\end_layout

\begin_layout Plain Layout

	# explored the vertex that means we've visited all of its children
\end_layout

\begin_layout Plain Layout

	# and it's done
\end_layout

\begin_layout Plain Layout

	if $attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] == 2$:
\end_layout

\begin_layout Plain Layout

		$attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'closetime'}
\backslash
right] == time$
\end_layout

\begin_layout Plain Layout

		$S
\backslash
text{.popright}
\backslash
left(
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$visited
\backslash
text{.append}
\backslash
left(u
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	# otherwise we need to leave it on the stack but explore it
\end_layout

\begin_layout Plain Layout

	# really this is superfluous because the only way to get on the stack
\end_layout

\begin_layout Plain Layout

	# is to concomitant with having 'state'$=1$
\end_layout

\begin_layout Plain Layout

	elif $attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] == 1$:
\end_layout

\begin_layout Plain Layout

		$attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'opentime'}
\backslash
right] == time$
\end_layout

\begin_layout Plain Layout

		for each $v 
\backslash
in A
\backslash
left[u
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			if $attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] == 0$:
\end_layout

\begin_layout Plain Layout

				$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

				$attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = u$
\end_layout

\begin_layout Plain Layout

				$S
\backslash
text{.append}
\backslash
left(v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$attrs
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] = 2$
\end_layout

\begin_layout Plain Layout

return $visited$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Topological Sort
\end_layout

\begin_layout Standard
A topological sort of a directed acyclic graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is an ordering on 
\begin_inset Formula $V$
\end_inset

 such that if 
\begin_inset Formula $\left(u,v\right)\in E$
\end_inset

 then 
\begin_inset Formula $u$
\end_inset

 appears before 
\begin_inset Formula $v$
\end_inset

 in the ordering.
 Producing a topological sort is easy using 
\family typewriter
Depth-First-Search
\family default
: the 
\family typewriter
visited
\family default
 array already returns the topological sort! The vertex at the front of
 the list is first in topologically sorted order, the second is the second,
 and so on.
 Why does this produce a topological sort? The intuition is that the last
 vertex to close is 
\begin_inset Quotes eld
\end_inset

behind
\begin_inset Quotes erd
\end_inset

 all of the others - all of the vertices are descendents of it.
 
\end_layout

\begin_layout Standard
If the graph is connected then some vertices might be unvisited after starting
 from a particular source.
 In that case you need to run DFS on every vertex (making sure to not to
 run twice on a vertex that's already been visited).
 Running time is 
\begin_inset Formula $O\left(V+E\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Topolgoical-Sort
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$attrs = 
\backslash
{i:
\backslash
{
\backslash
text{'state':0},
\backslash
text{'opentime': None},
\backslash
text{'closetime': None},
\backslash
text{'prnt':None}
\backslash
} 
\end_layout

\begin_layout Plain Layout

			
\backslash
text{ for } i=1:
\backslash
text{len}
\backslash
left(G
\backslash
right) 
\backslash
}$ 
\end_layout

\begin_layout Plain Layout

$time = 0$
\end_layout

\begin_layout Plain Layout

$S = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# let's pretend we have a tuple $G$ where $V$ is a hash table $
\backslash
left
\backslash
{'label':vertex
\backslash
right
\backslash
}$ where 
\end_layout

\begin_layout Plain Layout

# vertex is a pointer to the vertex and $E$ is a list of tuples $
\backslash
left(u,v
\backslash
right)$.
\end_layout

\begin_layout Plain Layout

$E,V = G$
\end_layout

\begin_layout Plain Layout

for $v 
\backslash
in V$:
\end_layout

\begin_layout Plain Layout

	if $attrs
\backslash
left[v
\backslash
right]
\backslash
left[
\backslash
text{'state'}
\backslash
right] == 0$:
\end_layout

\begin_layout Plain Layout

		# let's pretend that we changed DFS to take in addition $attrs,time$
\end_layout

\begin_layout Plain Layout

		# and return $attrs,time$ and the list mentioned above
\end_layout

\begin_layout Plain Layout

		$attrs, time,tsort = 
\backslash
text{Depth-First-Search}
\backslash
left(v,attrs,time
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# concatenate to the front because all closing times are later
\end_layout

\begin_layout Plain Layout

		$S = tsort + S$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Strongly Connected Components
\end_layout

\begin_layout Standard
A connected component of a graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a subset 
\begin_inset Formula $V'\subset V$
\end_inset

 such that for every 
\begin_inset Formula $u,v\in V'$
\end_inset

 there's a path 
\begin_inset Formula $u\rightsquigarrow v$
\end_inset

 and 
\begin_inset Formula $v\rightsquigarrow u$
\end_inset

.
 How do you compute all of the connected components of a graph? A topological
 sort and DFS on the transpose graph 
\begin_inset Formula $G^{T}$
\end_inset

.
 First topological-sort all of the vertices in the graph 
\begin_inset Formula $G$
\end_inset

.
 Then DFS the transpose graph 
\begin_inset Formula $G^{T}$
\end_inset

 in the topologically sorted order produced by the topological sort 
\begin_inset Formula $G$
\end_inset

.
 Why does this work? 
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $f\left(C\right)$
\end_inset

 be the latest finishing time of a strongly connected component and 
\begin_inset Formula $C,C'$
\end_inset

 two distinct connected components.
 Then 
\begin_inset Formula $f\left(C\right)>f\left(C'\right)$
\end_inset

 and in 
\begin_inset Formula $G^{T}$
\end_inset

(which has the same strongly connected components as 
\begin_inset Formula $G$
\end_inset

) 
\begin_inset Formula $f\left(C\right)<f\left(C'\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
That means, by the contrapositive, that in 
\begin_inset Formula $G^{T}$
\end_inset

 if there's an edge between two connected components then 
\begin_inset Formula $f\left(C\right)>f\left(C'\right)$
\end_inset

.
 That's why we visit strongly connected components in topologically sorted
 order: after we discover all vertices in some strongly connected component
 
\begin_inset Formula $C$
\end_inset

 and move on to the next strongly connected component 
\begin_inset Formula $C'$
\end_inset

 the only edges out will be to 
\begin_inset Formula $C$
\end_inset

, which has had all of its vertices already marked as visited (and so the
 second DFS doesn't visit any other connected component's vertices).
 Running time is 
\begin_inset Formula $\Theta\left(V+E\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Strongly-Connected-Components
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# let's pretend tsort just returns labels: $5,4,6,1,
\backslash
dots$
\end_layout

\begin_layout Plain Layout

$tsort = 
\backslash
text{Topological-Sort}
\backslash
left(G
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$G^T = 
\backslash
text{Transpose}
\backslash
left(G
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$V',E^T = G^T$
\end_layout

\begin_layout Plain Layout

$components = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i = 1:
\backslash
text{len}
\backslash
left(G
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	$components
\backslash
text{.append}
\backslash
left(
\backslash
text{Depth-First-Search}
\backslash
left(V'
\backslash
left[tsort
\backslash
left[i
\backslash
right]
\backslash
right]
\backslash
right)
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Minimum Spanning Tree
\end_layout

\begin_layout Standard
A spanning tree of an undirected graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a tree (no cycles) that covers all the vertices: 
\begin_inset Formula $n-1$
\end_inset

 edges and there's a path there's a path 
\begin_inset Formula $u\rightsquigarrow v$
\end_inset

 and 
\begin_inset Formula $v\rightsquigarrow u$
\end_inset

 for all 
\begin_inset Formula $u,v\in V$
\end_inset

; a minimum spanning tree is defined by edges 
\begin_inset Formula $A\subset E$
\end_inset

.
 A minimum weight spanning tree is a spanning tree over a weighted graph
 such that the sum of the weights along the edges is minimal.
 The two algorithms prestend are greedy algorithms that proceed by adding
 
\series bold
safe edges
\series default
: an edge such that the tree unioned with that edge is still a minimum spanning
 tree.
 The algorithms find these safe edges in different ways.
\end_layout

\begin_layout Standard
I'm going to define some things here that will be useful later on.
 A cut 
\begin_inset Formula $\left(S,V\backslash S\right)$
\end_inset

 is a partition of 
\begin_inset Formula $V$
\end_inset

 into two disjoin sets: 
\begin_inset Formula $S$
\end_inset

 and not 
\begin_inset Formula $S$
\end_inset

.
 An edge 
\series bold
crosses
\series default
 a cut if one vertex of the edge is in 
\begin_inset Formula $S$
\end_inset

 and the other in 
\begin_inset Formula $V\backslash S$
\end_inset

.
 A cut 
\series bold
respects 
\series default
a subset 
\begin_inset Formula $A\subset E$
\end_inset

 if and no edges in 
\begin_inset Formula $A$
\end_inset

 cross the cut.
 A 
\series bold
light edge
\series default
 crossing a cut is an edge that crosses the cut and is of minimum weight.
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $A$
\end_inset

 be a subset of 
\begin_inset Formula $E$
\end_inset

 that is included in some minimum spanning tree, let 
\begin_inset Formula $\left(S,V\backslash S\right)$
\end_inset

 be any cut that respects 
\begin_inset Formula $A$
\end_inset

.
 If 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 is a light edge crossing the cut then it's safe for 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Corollary
If 
\begin_inset Formula $C=\left(V_{C},E_{C}\right)$
\end_inset

 is a connected component in the forest 
\begin_inset Formula $G_{A}=\left(V,A\right)$
\end_inset

 and 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 is a light edge connecting 
\begin_inset Formula $C$
\end_inset

 to some other component of 
\begin_inset Formula $G_{A}$
\end_inset

 then 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 is safe for 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
In actuality the two algorithms add light edges.
\end_layout

\begin_layout Subsection
Kruskal's algorithm.
\end_layout

\begin_layout Standard
Kruskal's algorithm uses the Union-Find data structure to build the minimum
 spanning tree.
 It adds edges that haven't been added to 
\begin_inset Formula $A$
\end_inset

 in increasing order by weight.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Kruskal-Minimum-Spanning-Tree
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$A = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

for $v 
\backslash
in V$:
\end_layout

\begin_layout Plain Layout

	$vsets
\backslash
text{.append}
\backslash
left(
\backslash
text{Make-Set}
\backslash
left(v
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# $
\backslash
left(u,v,w
\backslash
right) 
\backslash
in E$ where $w$ is the weight of the edge
\end_layout

\begin_layout Plain Layout

$E = 
\backslash
text{sorted}
\backslash
left(E,
\backslash
text{key}=
\backslash
text{itemgetter}
\backslash
left(3
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $u,v 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

	if $
\backslash
text{Find-Set}
\backslash
left(vset
\backslash
left[u
\backslash
right]
\backslash
right) 
\backslash
neq 
\backslash
text{Find-Set}
\backslash
left(vset
\backslash
left[v
\backslash
right]
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

		$A
\backslash
text{.append}
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{Union}
\backslash
left(vset
\backslash
left[u
\backslash
right],vset
\backslash
left[v
\backslash
right] 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $A$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Firstly the sort costs 
\begin_inset Formula $O\left(E\lg E\right)$
\end_inset

.
 The rest of the running time is a function of the running times of the
 Union-Find data structure operation running times.
 The second 
\family typewriter
for
\family default
 performs 
\begin_inset Formula $O\left(E\right)$
\end_inset

 
\family typewriter
Find-Set
\family default
 and 
\family typewriter
Union
\family default
 operations.
 Along with the 
\begin_inset Formula $O\left(V\right)$
\end_inset

 
\family typewriter
Make-Set
\family default
 operations in the first 
\family typewriter
for
\family default
 the total is 
\begin_inset Formula $O\left(\left(V+E\right)\alpha\left(V\right)\right)$
\end_inset

, where 
\begin_inset Formula $\alpha$
\end_inset

 is the Ackermann function.
 Since we assume 
\begin_inset Formula $G$
\end_inset

 is connected (otherwise it could have no spanning tree) it's the case that
 
\begin_inset Formula $E\geq V-1$
\end_inset

 and so the Union-Find operations actually take 
\begin_inset Formula $O\left(E\alpha\left(V\right)\right)$
\end_inset

.
 Then since 
\begin_inset Formula $\alpha\left(V\right)=O\left(\lg V\right)=O\left(\lg E\right)$
\end_inset

 we get that the run time is 
\begin_inset Formula $O\left(E\lg E\right)$
\end_inset

.
 Finally since 
\begin_inset Formula $\left|E\right|<\left|V\right|^{2}$
\end_inset

 we have that 
\begin_inset Formula $\lg\left(E\right)=O\left(\lg V\right)$
\end_inset

 and therefore the running time is 
\begin_inset Formula $O\left(E\lg V\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Prim's algorithm
\end_layout

\begin_layout Standard
Prim's algorithm uses a min heap to keep the sorted list of 
\begin_inset Quotes eld
\end_inset

lightest
\begin_inset Quotes erd
\end_inset

 edges crossing the cut.
 It functions very similarly to Dijkstra's shortest path algorithm (which
 is covered in the next section).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Prim-Minimum-Spanning-Tree
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

# initialize some vertex to be the nucleation point of the 
\end_layout

\begin_layout Plain Layout

# minimum spanning tree
\end_layout

\begin_layout Plain Layout

$V
\backslash
left[1
\backslash
right]
\backslash
left[
\backslash
text{'key'}
\backslash
right] = 0$
\end_layout

\begin_layout Plain Layout

# let's pretend this minqueue is keyed on $V
\backslash
left[i
\backslash
right]
\backslash
left[
\backslash
text{'dist'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$ Q = 
\backslash
text{minQueue}
\backslash
left(V
\backslash
right)$
\end_layout

\begin_layout Plain Layout

while $
\backslash
text{len}
\backslash
left(Q
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$u = 
\backslash
text{Extract-Min}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	for $v 
\backslash
in V
\backslash
left[u
\backslash
right]
\backslash
left[
\backslash
text{'neighbors'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			# let's pretend $E$ is a dict like $
\backslash
left
\backslash
{
\backslash
left(u,v
\backslash
right):w
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

			# and that we can check membership in $Q$
\end_layout

\begin_layout Plain Layout

			# basically just have a bunch of dicts floating around
\end_layout

\begin_layout Plain Layout

			# while it looks like we're keeping a sorted list
\end_layout

\begin_layout Plain Layout

			# of vertices this is actually keeping track of lightest
\end_layout

\begin_layout Plain Layout

			# edges crossing the cut (think)
\end_layout

\begin_layout Plain Layout

			if $v 
\backslash
in Q$ and $E
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right] < v
\backslash
left[
\backslash
text{'key'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

				# crucially you need to be able to adjust 
\end_layout

\begin_layout Plain Layout

				# the priority key in the min queue
\end_layout

\begin_layout Plain Layout

				$v
\backslash
left[
\backslash
text{'key'}
\backslash
right] = E
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right]$
\end_layout

\begin_layout Plain Layout

				$v
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = u$
\end_layout

\begin_layout Plain Layout

# minimum spanning tree is parent edges back to nucleation point.
\end_layout

\begin_layout Plain Layout

return $
\backslash
left[ 
\backslash
left(v
\backslash
left[
\backslash
text{'prnt'}
\backslash
right],v
\backslash
right) 
\backslash
text{ for }v
\backslash
in V
\backslash
right]$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(E\lg E\right)$
\end_inset

 for a standard implementation of a min heap but can be sped up to 
\begin_inset Formula $O\left(E+V\lg V\right)$
\end_inset

 using a Fibonacci heap.
\end_layout

\begin_layout Section
Single source Shortest Path
\end_layout

\begin_layout Standard
Single source means shortest path from a particular vertex to all other
 vertices in the graph.
 The only other thing to mention here is that if a graph has negative weight
 cycles (a cycle where the sum of the weights around the cycle [not necessarily
 all weights] is negative) then shortest path is not defined (because just
 keep going around the cycle to arbitrarily decrease the weight of any path).
\end_layout

\begin_layout Standard
For each of these algorithms the actual shortest paths can be reconstructed
 by following the 
\family typewriter
prnt
\family default
 pointer chains back to the source to create a predecessor tree.
 This is omitted.
\end_layout

\begin_layout Subsection
Bellman-Ford
\end_layout

\begin_layout Standard
Bellman-Ford is kind of stupid simple: just 
\begin_inset Quotes eld
\end_inset

relax
\begin_inset Quotes erd
\end_inset

 all of the distance 
\begin_inset Formula $\left|V\right|-1$
\end_inset

 times.
 What does 
\begin_inset Quotes eld
\end_inset

relax
\begin_inset Quotes erd
\end_inset

 mean?
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Relax
\family default

\begin_inset Formula $\left(u,v,w\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $v
\backslash
left[
\backslash
text{'dist'}
\backslash
right] > u
\backslash
left[
\backslash
text{'dist'}
\backslash
right] + w$:
\end_layout

\begin_layout Plain Layout

	$v
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = w$
\end_layout

\begin_layout Plain Layout

	$v
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = u$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reason it works is a little convoluted but the intuition is that the
 shortest path to any vertex can have at most 
\begin_inset Formula $\left|V\right|-1$
\end_inset

 edges and relaxing them in order, but with any other edges relaxed in between,
 produces the shortest path/distance.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Bellman-Ford
\family default

\begin_inset Formula $\left(G,s\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

for $v 
\backslash
in V$:
\end_layout

\begin_layout Plain Layout

	$v
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = 
\backslash
infty$
\end_layout

\begin_layout Plain Layout

	$v
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = 
\backslash
text{None}$
\end_layout

\begin_layout Plain Layout

$s
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = 0$
\end_layout

\begin_layout Plain Layout

for $i = 1:
\backslash
left|V
\backslash
right|-1$:
\end_layout

\begin_layout Plain Layout

	for $
\backslash
left(u,v,w
\backslash
right) 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{Relax}
\backslash
left(u,v,w
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bellman Ford call also check at the end for negative weight cycles: if any
 distances can be further relaxed then that vertex is on a negative weight
 cycle (this follows from the fact that any shortest path can undergo at
 most 
\begin_inset Formula $\left|V\right|-1$
\end_inset

 relaxations).
 Running time is 
\begin_inset Formula $O\left(VE\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Bellman-Ford
\family default

\begin_inset Formula $\left(G,s\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

for $v 
\backslash
in V$:
\end_layout

\begin_layout Plain Layout

	$v
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = 
\backslash
infty$
\end_layout

\begin_layout Plain Layout

	$v
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = 
\backslash
text{None}$
\end_layout

\begin_layout Plain Layout

$s
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = 0$
\end_layout

\begin_layout Plain Layout

for $i = 1:
\backslash
left|V
\backslash
right|-1$:o
\end_layout

\begin_layout Plain Layout

	for $
\backslash
left(u,v,w
\backslash
right) 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{Relax}
\backslash
left(u,v,w
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $
\backslash
left(u,v,w
\backslash
right) 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

		if $v
\backslash
left[
\backslash
text{'dist'}
\backslash
right] > u
\backslash
left[
\backslash
text{'dist'}
\backslash
right] + w$:
\end_layout

\begin_layout Plain Layout

			return "Error: negative weight cycle"
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For completeness I'll mention that to actually find a negative weight cycle
 if one exists run Bellman-Ford twice: the first time finds and edge on
 a negative weight cycle.
 The second time run Bellman-Ford with the source vertex being the one that
 the distance could have been relaxed to and trace the path produced by
 Bellman-Ford to its parent.
\end_layout

\begin_layout Subsection
Shortest Path in a DAG
\end_layout

\begin_layout Standard
In a dag you can speed up Bellman-Ford because you can figure out exactly
 the order in which to relax the edges: just do a topological sort.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
DAG-Shortest
\family default

\begin_inset Formula $\left(G,s\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout
\noindent
\align left

$tsort = 
\backslash
text{Topolgoical-Sort}
\backslash
left(G
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

for $v 
\backslash
in V$:
\end_layout

\begin_layout Plain Layout

	$v
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = 
\backslash
infty$
\end_layout

\begin_layout Plain Layout

	$v
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = 
\backslash
text{None}$
\end_layout

\begin_layout Plain Layout

$s
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = 0$
\end_layout

\begin_layout Plain Layout

for $i = 1:
\backslash
left|V
\backslash
right|-1$:o
\end_layout

\begin_layout Plain Layout

	$u = tsort
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	for $
\backslash
left(u,v,w
\backslash
right) 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{Relax}
\backslash
left(u,v,w
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dijkstra's
\end_layout

\begin_layout Standard
Dijkstra's shortest path algorithm is very similar to Prim's minimum weight
 spanning tree algorithm.
 Just like Prim's it uses a min heap to keep track of objects in the graph,
 except it's nearest vertices rather than lightest edges crossing a cut.
 Running time is 
\begin_inset Formula $O\left(E+V\lg V\right)$
\end_inset

 using a Fibonacci heap implementation of min queue.
 Note that Dijkstra does not work for graph with negative weight edges.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Dijkstra
\family default

\begin_inset Formula $\left(G,s\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

# initialize some vertex to be the nucleation point of the 
\end_layout

\begin_layout Plain Layout

# minimum spanning tree
\end_layout

\begin_layout Plain Layout

$s
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = 0$
\end_layout

\begin_layout Plain Layout

# let's pretend this minqueue is keyed on $s
\backslash
left[
\backslash
text{'dist'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$ Q = 
\backslash
text{minQueue}
\backslash
left(V
\backslash
right)$
\end_layout

\begin_layout Plain Layout

while $
\backslash
text{len}
\backslash
left(Q
\backslash
right) > 0$:
\end_layout

\begin_layout Plain Layout

	$u = 
\backslash
text{Extract-Min}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	for $v 
\backslash
in u
\backslash
left[
\backslash
text{'neighbors'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			if $v 
\backslash
in Q$ and $E
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right] + u
\backslash
left[
\backslash
text{'dist'}
\backslash
right] < v
\backslash
left[
\backslash
text{'dist'}
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

				# note this is shorthand for updating the key in the minQueue
\end_layout

\begin_layout Plain Layout

				$v
\backslash
left[
\backslash
text{'dist'}
\backslash
right] = E
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right] + u
\backslash
left[
\backslash
text{'dist'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

				$v
\backslash
left[
\backslash
text{'prnt'}
\backslash
right] = u$
\end_layout

\begin_layout Plain Layout

# shortest path tree is parent edges back to source
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Heuristic search
\end_layout

\begin_layout Standard
Suppose you wanted to use Dijkstra's to find the shortest path to a particular
 vertex 
\begin_inset Formula $g$
\end_inset

, for goal.
 Well you could just run it and recover the path to 
\begin_inset Formula $g$
\end_inset

 but Dijkstra will waste a lot of time searching the rest of the graph.
 You can hack Dijkstra to be a little faster by using a different priority
 function (one that encodes a heuristic for most expedient direction).
 This prompts it to explore in a particular direction more often since the
 vertices prioritized by the heuristic function will be popped first from
 the min queue.
 The code is exactly the same except for 
\begin_inset Formula 
\[
v\left[\texttt{'dist'}\right]=E\left[\left(u,v\right)\right]+u\left[\texttt{'dist'}\right]
\]

\end_inset

which becomes 
\begin_inset Formula 
\[
v\left[\texttt{'dist'}\right]=\texttt{heuristic}\left(v,g\right)
\]

\end_inset

To be concrete suppose we're trying to find the shortest path to a vertex
 on a grid.
 Then 
\begin_inset Formula $\texttt{heuristic}\left(v,g\right)$
\end_inset

 would just be Manhattan distance (closer Manhattan distance means higher
 priority).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Manhattan-Distance
\family default

\begin_inset Formula $\left(a,b\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

return $
\backslash
left|a
\backslash
left[
\backslash
text{x}
\backslash
right]-b
\backslash
left[
\backslash
text{x}
\backslash
right]
\backslash
right|+
\backslash
left|a
\backslash
left[
\backslash
text{y}
\backslash
right]-b
\backslash
left[
\backslash
text{y}
\backslash
right]
\backslash
right|
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
A* search
\end_layout

\begin_layout Standard
A star search combines heuristic and Dijkstra's to take into account distance
 from source and some heuristic for distance to goal.
 The modification to Dijkstra is 
\begin_inset Formula 
\[
v\left[\texttt{'dist'}\right]=E\left[\left(u,v\right)\right]+u\left[\texttt{'dist'}\right]
\]

\end_inset

becomes 
\begin_inset Formula 
\[
v\left[\texttt{'dist'}\right]=E\left[\left(u,v\right)\right]+u\left[\texttt{'dist'}\right]+\texttt{heuristic}\left(v,g\right)
\]

\end_inset


\end_layout

\begin_layout Section
Difference constraints
\end_layout

\begin_layout Standard
A set of difference constraints is a set 
\begin_inset Formula $x_{j}-x_{i}\leq b_{k}$
\end_inset

 whose solution is 
\begin_inset Formula $\mathbf{x}$
\end_inset

 such that all of the constraints are satisfied.
 These can be solved by first constructing a constraint graph 
\begin_inset Formula $G=\left(\left\{ v_{0},v_{1},\dots,v_{n}\right\} ,E\right)$
\end_inset

 where 
\begin_inset Formula 
\[
E=\left\{ \left(v_{i},v_{j}\right)\bigg|x_{j}-x_{i}\leq b_{k}\text{ is a constraint}\right\} \cup\left\{ \left(v_{0},v_{i}\right)\right\} 
\]

\end_inset

where 
\begin_inset Formula $w\left(\left(v_{i},v_{j}\right)\right)=b_{k}$
\end_inset

 and 
\begin_inset Formula $w\left(\left(v_{0},v_{i}\right)\right)=0$
\end_inset

.
 Then using Bellman-Ford to find the shortest path 
\begin_inset Formula $\delta\left(v_{0},v_{i}\right)$
\end_inset

 from 
\begin_inset Formula $v_{0}$
\end_inset

 to every other vertex.
 If there's a negative weight cycle then no solution exists.
 The proof that Bellman-Ford produces a solution hinges on the triangle
 inequality 
\begin_inset Formula $\delta\left(a,b\right)\leq\delta\left(a,c\right)+\delta\left(b,c\right)$
\end_inset

: since the distance to each of the vertices is 0 
\begin_inset Formula 
\[
\delta\left(v_{0},v_{j}\right)\leq\delta\left(v_{i},v_{j}\right)+\delta\left(v_{i},0\right)
\]

\end_inset

implies
\begin_inset Formula 
\[
\delta\left(v_{0},v_{j}\right)-\delta\left(v_{i},v_{0}\right)\leq\delta\left(v_{i},v_{j}\right)=w\left(\left(v_{i},v_{j}\right)\right)
\]

\end_inset


\end_layout

\begin_layout Standard
A system of 
\begin_inset Formula $m$
\end_inset

 constraints in 
\begin_inset Formula $n$
\end_inset

 unknowns produces a graph with 
\begin_inset Formula $n+1$
\end_inset

 vertices and 
\begin_inset Formula $n+m$
\end_inset

 edges and hence running time is 
\begin_inset Formula $O\left(n^{2}+nm\right)$
\end_inset

.
\end_layout

\begin_layout Section
Transitive Closure
\end_layout

\begin_layout Standard
The transitive closure of a graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a graph 
\begin_inset Formula $G'=\left(V,E'\right)$
\end_inset

 where 
\begin_inset Formula $\left(u,v\right)\in E'$
\end_inset

 if there's a path there's a path 
\begin_inset Formula $u\rightsquigarrow v$
\end_inset

 in 
\begin_inset Formula $G$
\end_inset

.
 This problem has optimal substructure: consider all of the paths from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

 where intermediate vertices (vertices in the path not including 
\begin_inset Formula $i,j$
\end_inset

) come from vertices 
\begin_inset Formula $\left\{ 1,\dots,k\right\} \subset\left\{ 1,\dots,n\right\} $
\end_inset

 and a particular path 
\begin_inset Formula $p$
\end_inset

.
 Either 
\begin_inset Formula $k$
\end_inset

 is an intermediate vertex of 
\begin_inset Formula $p$
\end_inset

 or not.
 If 
\begin_inset Formula $k$
\end_inset

 is not an intermediate vertex then all 
\begin_inset Formula $p$
\end_inset

's intermediate vertices are drawn from 
\begin_inset Formula $\left\{ 1,\dots,k-1\right\} $
\end_inset

.
 If 
\begin_inset Formula $k$
\end_inset

 is an intermediate vertex of 
\begin_inset Formula $p$
\end_inset

 then we can further decompose 
\begin_inset Formula $p$
\end_inset

 into 
\begin_inset Formula $i\overset{p_{1}}{\rightsquigarrow k}\overset{p_{2}}{\rightsquigarrow}j$
\end_inset

 where 
\begin_inset Formula $k$
\end_inset

 is not an intermediate vertex of either 
\begin_inset Formula $p_{1}$
\end_inset

 or 
\begin_inset Formula $p_{2}$
\end_inset

.
 Let 
\begin_inset Formula $t_{ij}^{\left(k\right)}$
\end_inset

 be 0 or 1 depending on whether 
\begin_inset Formula $i$
\end_inset

 is connected to 
\begin_inset Formula $j$
\end_inset

 in the transitive closure of 
\begin_inset Formula $G$
\end_inset

 or not, then the Bellman equation is 
\begin_inset Formula 
\[
t_{ij}^{\left(k\right)}=t_{ij}^{\left(k-1\right)}\text{ or }\left(t_{ik}^{\left(k-1\right)}\text{ and }t_{kj}^{\left(k-1\right)}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
with base case
\begin_inset Formula 
\[
t_{ij}^{\left(0\right)}=\begin{cases}
0 & \text{if }i\neq j\text{ and }\left(i,j\right)\not\in E\\
1 & \text{if }i=j\text{ or }\left(i,j\right)\in E
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Transitive-Closure
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(V
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$T = n
\backslash
cdot
\backslash
left[n
\backslash
cdot
\backslash
left[0
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i = 1:n$:
\end_layout

\begin_layout Plain Layout

	for $j = 1:n$:
\end_layout

\begin_layout Plain Layout

		if $ i == j$ or $
\backslash
left(u,v
\backslash
right) 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

			$T
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right] = 1$
\end_layout

\begin_layout Plain Layout

for $k=1:n$:
\end_layout

\begin_layout Plain Layout

	$T' = n
\backslash
cdot
\backslash
left[n
\backslash
cdot
\backslash
left[0
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	for $i =1:n$:
\end_layout

\begin_layout Plain Layout

		for $j=1:n$:
\end_layout

\begin_layout Plain Layout

			$T'
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right]=T
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right]
\backslash
text{ or }
\backslash
left(T
\backslash
left[i
\backslash
right]
\backslash
left[k
\backslash
right]
\backslash
text{ and }T
\backslash
left[k
\backslash
right]
\backslash
left[j
\backslash
right]
\backslash
right) $
\end_layout

\begin_layout Plain Layout

	$T = T'$
\end_layout

\begin_layout Plain Layout

return $T$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
All pairs Shortest Paths
\end_layout

\begin_layout Subsection
Shortest paths by exponentiation
\end_layout

\begin_layout Standard
Shortest paths have optimal substructure: if vertices 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 are distinct, then we can decompose the path 
\begin_inset Formula $p$
\end_inset

 from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

 into 
\begin_inset Formula $i\overset{p'}{\rightsquigarrow}k\rightarrow j$
\end_inset

 where 
\begin_inset Formula $p'$
\end_inset

 must be the shortest path from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

.
 Let 
\begin_inset Formula $l_{ij}^{\left(m\right)}$
\end_inset

 be the minimum weight of any path from vertex 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

 that contains at most 
\begin_inset Formula $m$
\end_inset

 edges and 
\begin_inset Formula $w_{uv}$
\end_inset

 be the weight of the edge between vertices 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

, then the Bellman equation is
\begin_inset Formula 
\begin{eqnarray*}
l_{ij}^{\left(m\right)} & = & \min\left\{ l_{ij}^{\left(m-1\right)},\min_{1\leq k\leq n}\left\{ l_{ik}^{\left(m-1\right)}+w_{kj}\right\} \right\} \\
 & = & \min_{1\leq k\leq n}\left\{ l_{ik}^{\left(m-1\right)}+w_{kj}\right\} 
\end{eqnarray*}

\end_inset

since 
\begin_inset Formula $w_{jj}=0$
\end_inset

.
 Base case is 
\begin_inset Formula 
\[
l_{ij}^{\left(0\right)}=\begin{cases}
0 & \text{if }i=j\\
\infty & \text{if }i\neq j
\end{cases}
\]

\end_inset

The shortest path weight is then 
\begin_inset Formula $l_{ij}^{\left(n-1\right)}$
\end_inset

.
 Given a matrix 
\begin_inset Formula $L$
\end_inset

 that corresponds to the 
\begin_inset Formula $m$
\end_inset

th iteration we can compute 
\begin_inset Formula $L'$
\end_inset

 corresponding to the 
\begin_inset Formula $m+1$
\end_inset

th iteration using 
\begin_inset Formula $W=\left\{ w_{ij}\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Extend-Shortest-Path
\family default

\begin_inset Formula $\left(L,W\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(L
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$L' = n
\backslash
cdot
\backslash
left[n
\backslash
cdot
\backslash
left[
\backslash
infty
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	for $j=1:n$:
\end_layout

\begin_layout Plain Layout

		for $k=1:n$:
\end_layout

\begin_layout Plain Layout

			$L'
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right] = 
\backslash
min 
\backslash
left
\backslash
{L'
\backslash
left[i
\backslash
right]
\backslash
left[k
\backslash
right], L
\backslash
left[k
\backslash
right]
\backslash
left[j
\backslash
right] +W
\backslash
left[k
\backslash
right]
\backslash
left[j
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The thing to notice is that this is very much like matrix multiplication
 
\begin_inset Formula $L\cdot W$
\end_inset

, and hence schematically
\begin_inset Formula 
\begin{eqnarray*}
L^{\left(1\right)} & = & L^{\left(0\right)}\cdot W=W\\
L^{\left(2\right)} & = & L^{\left(1\right)}\cdot W=W^{2}\\
 &  & \vdots\\
L^{\left(n-1\right)} & = & L^{\left(n-2\right)}\cdot W=W^{n-1}
\end{eqnarray*}

\end_inset

Therefore we can use exponentiation by repeated squaring to compute 
\begin_inset Formula $L^{\left(n-1\right)}$
\end_inset

.
 In fact it's even simpler because we just need to square and not worry
 about anything else since 
\begin_inset Formula $L^{\left(n+k\right)}=L^{\left(n-1\right)}$
\end_inset

 for all 
\begin_inset Formula $k$
\end_inset

 (since shortest paths don't become shorter...).
 So
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Fast-Shortest-Path
\family default

\begin_inset Formula $\left(W\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(W
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$L = W$
\end_layout

\begin_layout Plain Layout

$m = 1$
\end_layout

\begin_layout Plain Layout

while $m < n-1$:
\end_layout

\begin_layout Plain Layout

	$L' = 
\backslash
text{Extend-Shortest-Path}
\backslash
left(L,L
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	$L = L'$
\end_layout

\begin_layout Plain Layout

	$m = 2m$
\end_layout

\begin_layout Plain Layout

return $L$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $\Theta\left(n^{3}\lg n\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Floyd-Warshall
\end_layout

\begin_layout Standard
Floyd-Warshall is very similar to Transitive closure.
 Consider a subset 
\begin_inset Formula $\left\{ 1,\dots,k\right\} $
\end_inset

 of vertices.
 For any two vertices 
\begin_inset Formula $i,j$
\end_inset

 consider all paths whose intermediate vertices (vertices in the path not
 including 
\begin_inset Formula $i,j$
\end_inset

) all come from 
\begin_inset Formula $\left\{ 1,\dots,k\right\} $
\end_inset

 and let 
\begin_inset Formula $p$
\end_inset

 be the minimal weight path from among them.
 If 
\begin_inset Formula $k$
\end_inset

 is not an intermediate vertex of 
\begin_inset Formula $p$
\end_inset

 then all intermediate vertices of 
\begin_inset Formula $p$
\end_inset

 come from 
\begin_inset Formula $\left\{ 1,\dots,k-1\right\} $
\end_inset

.
 If 
\begin_inset Formula $k$
\end_inset

 is an intermediate vertex of 
\begin_inset Formula $p$
\end_inset

 then we can decompose 
\begin_inset Formula $p$
\end_inset

 into 
\begin_inset Formula $i\overset{p_{1}}{\rightsquigarrow k}\overset{p_{2}}{\rightsquigarrow}j$
\end_inset

 where 
\begin_inset Formula $k$
\end_inset

 is not an intermediate vertex of neither 
\begin_inset Formula $p_{1}$
\end_inset

 nor 
\begin_inset Formula $p_{2}$
\end_inset

 where both 
\begin_inset Formula $p_{1},p_{2}$
\end_inset

 have intermediate vertices coming from 
\begin_inset Formula $\left\{ 1,\dots,k-1\right\} $
\end_inset

.
 Furthermore both 
\begin_inset Formula $p_{1},p_{2}$
\end_inset

 are shortest paths themselves.
 Therefore the Bellman equation is 
\begin_inset Formula 
\[
d_{ij}^{\left(k\right)}=\begin{cases}
w_{ij} & \text{if }k=0\\
\min\left\{ d_{ij}^{\left(k-1\right)},d_{ik}^{\left(k-1\right)}+d_{kj}^{\left(k-1\right)}\right\}  & \text{if }k>0
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Floyd-Warshall
\family default

\begin_inset Formula $\left(W\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(W
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$D = W$
\end_layout

\begin_layout Plain Layout

for $k=1:n$:
\end_layout

\begin_layout Plain Layout

	$D' = n
\backslash
cdot
\backslash
left[n
\backslash
cdot
\backslash
left[
\backslash
infty
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	for $i =1:n$:
\end_layout

\begin_layout Plain Layout

		for $j=1:n$:
\end_layout

\begin_layout Plain Layout

			$D'
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right] = 
\backslash
min
\backslash
left
\backslash
{ D
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right],D
\backslash
left[i
\backslash
right]
\backslash
left[k
\backslash
right]+D
\backslash
left[k
\backslash
right]
\backslash
left[j
\backslash
right]
\backslash
right
\backslash
} $
\end_layout

\begin_layout Plain Layout

	$D = D'$
\end_layout

\begin_layout Plain Layout

return $D$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running time is obviously 
\begin_inset Formula $O\left(n^{3}\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Johnson's Algorithm
\end_layout

\begin_layout Standard
John's algorithm is slightly faster than Floyd-Warshall on sparse graphs.
 It works by reweighting all of the vertices so that none are negative using
 Bellman-Ford and then runs Dijkstra from each vertex.
 It reweights in a way that doesn't change any of the shortest paths: for
 any 
\begin_inset Formula $h\left(u\right)$
\end_inset

 that maps vertices to real numbers
\begin_inset Formula 
\[
\hat{w}\left(\left(u,v\right)\right)=w\left(\left(u,v\right)\right)+h\left(u\right)-h\left(v\right)
\]

\end_inset

does not alter shortest paths.
 How to pick 
\begin_inset Formula $h\left(u\right)$
\end_inset

 so that 
\begin_inset Formula $\hat{w}\left(\left(u,v\right)\right)>0$
\end_inset

.
 Make it a distance function: similar to how a super source is used in differenc
e graphs define a new vertex 
\begin_inset Formula $s$
\end_inset

 with 0 weight edges to every other vertex and let 
\begin_inset Formula $h\left(u\right)=\delta\left(s,v\right)$
\end_inset

.
 Since 
\begin_inset Formula $\delta\left(s,v\right)$
\end_inset

 is a distance function by the triangle inequality 
\begin_inset Formula 
\[
h\left(v\right)\leq h\left(u\right)+w\left(u,v\right)
\]

\end_inset

and hence 
\begin_inset Formula 
\[
\hat{w}\left(\left(u,v\right)\right)=w\left(\left(u,v\right)\right)+h\left(u\right)-h\left(v\right)\geq0
\]

\end_inset

So just like in difference constraints use Bellman-Ford to compte 
\begin_inset Formula $\delta\left(s,v\right)$
\end_inset

 for all 
\begin_inset Formula $v\in V$
\end_inset

.
 Running time is 
\begin_inset Formula $O\left(V^{2}\lg V+VE\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Johnsons
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

$V' = V 
\backslash
cup 
\backslash
left
\backslash
{s
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

$E' = E 
\backslash
cup 
\backslash
left
\backslash
{
\backslash
left(s,v,0
\backslash
right)
\backslash
text{ for }v
\backslash
in V
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

# let's pretend Bellman-Ford returns a distance function
\end_layout

\begin_layout Plain Layout

$
\backslash
delta = 
\backslash
text{Bellman-Ford}
\backslash
left(
\backslash
left(V',E'
\backslash
right),s
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $
\backslash
left(u,v,w
\backslash
right) 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

	$w = E
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right] + 
\backslash
delta
\backslash
left(s,u
\backslash
right)-
\backslash
delta
\backslash
left(s,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$D = n
\backslash
cdot
\backslash
left[n
\backslash
cdot
\backslash
left[
\backslash
infty
\backslash
right]
\backslash
right]$	
\end_layout

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(V
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	for $j =1:n$:
\end_layout

\begin_layout Plain Layout

		# let's pretend Dijkstra returns a distance function
\end_layout

\begin_layout Plain Layout

		$
\backslash
hat{
\backslash
delta} = 
\backslash
text{Dijkstra}
\backslash
left(G,i
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# undo the reweighting to recover the actual distances
\end_layout

\begin_layout Plain Layout

		$D
\backslash
left[i
\backslash
right]
\backslash
left[j
\backslash
right] = 
\backslash
hat{
\backslash
delta}
\backslash
left(i,j
\backslash
right) - 
\backslash
delta
\backslash
left(s,u
\backslash
right)+
\backslash
delta
\backslash
left(s,v
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $D$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Min Cut - Max Flow
\end_layout

\begin_layout Standard
A flow network 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a directed graph in which each edge has a capacity 
\begin_inset Formula $c\left(\left(u,v\right)\right)\geq0$
\end_inset

 and if a forward edge exists then no reverse edge exists.
 Further there are two distinguished vertex, source 
\begin_inset Formula $s$
\end_inset

 and sink 
\begin_inset Formula $t$
\end_inset

, such that for every vertex 
\begin_inset Formula $v$
\end_inset

 it's the case that 
\begin_inset Formula $s\rightsquigarrow v\rightsquigarrow t$
\end_inset

.
 A 
\series bold
flow 
\series default
on a flow network is a real valued function 
\begin_inset Formula $f:V\times V\rightarrow\mathbb{R}$
\end_inset

 that satisfies two properties:
\end_layout

\begin_layout Enumerate
Capacity constraint: For all 
\begin_inset Formula $u,v$
\end_inset

, it's the case that 
\begin_inset Formula $0\leq f\left(u,v\right)\leq c\left(\left(u,v\right)\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Flow conservation: For all 
\begin_inset Formula $u\in V-\left\{ s,t\right\} $
\end_inset

, it's the case that that flow in equals flow out, i.e.
 
\begin_inset Formula 
\[
\sum_{v\in V}f\left(v,u\right)=\sum_{v\in V}f\left(u,v\right)
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
value 
\series default
of the flow 
\begin_inset Formula $\left|f\right|$
\end_inset

 is defined as the total flow out of the source minus the total flow into
 the source, i.e.
 
\begin_inset Formula 
\[
\left|f\right|\equiv\sum_{v\in V}f\left(s,v\right)-\sum_{v\in V}f\left(v,s\right)
\]

\end_inset


\end_layout

\begin_layout Standard
Typically, a flow network will not have any edges into the source and so
 
\begin_inset Formula $\left|f\right|=\sum f\left(s,v\right)$
\end_inset

.
 The 
\series bold
maximum-flow 
\series default
problem is maximizing 
\begin_inset Formula $\left|f\right|$
\end_inset

 on a particular flow network 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Subsection
Ford-Fulkerson/Edmond's-Karp
\end_layout

\begin_layout Standard
Given a flow network 
\begin_inset Formula $G$
\end_inset

 we construct a 
\series bold
residual network
\series default
 
\begin_inset Formula $G'$
\end_inset

 which models 
\begin_inset Quotes eld
\end_inset

room to augment
\begin_inset Quotes erd
\end_inset

 the flow.
 Then we augment until there's no more room.
 Define the 
\series bold
residual capacity
\series default
 
\begin_inset Formula $c_{f}\left(u,v\right)$
\end_inset

 to be
\begin_inset Formula 
\[
c_{f}\left(u,v\right)=\begin{cases}
c\left(\left(u,v\right)\right)-f\left(u,v\right) & \text{if }\left(u,v\right)\in E\\
f\left(v,u\right) & \text{if }\left(v,u\right)\in E\\
0 & \text{otherwise}
\end{cases}
\]

\end_inset

The first case is clearly 
\begin_inset Quotes eld
\end_inset

room to grow
\begin_inset Quotes erd
\end_inset

.
 The second case is the flow that's currently going across edge 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 but in the reverse direction (think of it 
\begin_inset Quotes eld
\end_inset

room to squelch
\begin_inset Quotes erd
\end_inset

 the flow).
 The residual network 
\begin_inset Formula $G'=\left(V,E_{f}\right)$
\end_inset

 where 
\begin_inset Formula 
\[
E_{f}=\left\{ \left(u,v\right)\in V\times V\bigg|c_{f}\left(u,v\right)>0\right\} 
\]

\end_inset

An 
\series bold
augmentation 
\series default
of a flow 
\begin_inset Formula $f$
\end_inset

 by 
\begin_inset Formula $f'$
\end_inset

 is a new flow 
\begin_inset Formula $\left(f\uparrow f'\right)$
\end_inset

 defined to be
\begin_inset Formula 
\[
\left(f\uparrow f'\right)\left(u,v\right)=\begin{cases}
f\left(u,v\right)+f'\left(u,v\right)-f'\left(v,u\right) & \text{if }\left(u,v\right)\in E\\
0 & \text{otherwise}
\end{cases}
\]

\end_inset

i.e.
 add 
\begin_inset Formula $f'\left(u,v\right)$
\end_inset

 units of flow along edge 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 but squelch by 
\begin_inset Formula $f'\left(v,u\right)$
\end_inset

 units (in the residual network there will be an edge 
\begin_inset Formula $\left(v,u\right)$
\end_inset

 with 
\begin_inset Formula $f'\left(v,u\right)$
\end_inset

 units of flow on it, think of it as back pressure).
 Turns out that if 
\begin_inset Formula $f'$
\end_inset

 is a flow in 
\begin_inset Formula $G'$
\end_inset

 then 
\begin_inset Formula $\left|f\uparrow f'\right|=\left|f\right|+\left|f'\right|$
\end_inset

.
 
\end_layout

\begin_layout Standard
An 
\series bold
augmenting path 
\series default

\begin_inset Formula $p$
\end_inset

 is a simple path from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $G'$
\end_inset

.
 The 
\series bold
residual capacity 
\series default

\begin_inset Formula $c_{f}\left(p\right)$
\end_inset

 of 
\begin_inset Formula $p$
\end_inset

 is defined
\begin_inset Formula 
\[
c_{f}\left(p\right)=\min\left\{ c_{f}\left(u,v\right)\big|\left(u,v\right)\in p\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
So define a flow 
\begin_inset Formula $f_{p}\left(u,v\right)$
\end_inset

 that flows this minimum capacity along the path, i.e.
\begin_inset Formula 
\[
f_{p}\left(u,v\right)=\begin{cases}
c_{f}\left(p\right) & \text{if }\left(u,v\right)\in p\\
0 & \text{otherwise}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
and then 
\begin_inset Formula $f_{p}$
\end_inset

 is a flow in 
\begin_inset Formula $G'$
\end_inset

 with 
\begin_inset Formula $\left|f_{p}\right|=c_{f}\left(p\right)>0$
\end_inset

.
 As a corollary 
\begin_inset Formula $\left|f\uparrow f_{p}\right|=\left|f\right|+\left|f_{p}\right|>\left|f\right|$
\end_inset

.
\end_layout

\begin_layout Standard
Recall cuts 
\begin_inset Formula $\left(S,V\backslash S\right)$
\end_inset

 of a graph.
 The 
\series bold
capacity of a cut
\series default
 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 where 
\begin_inset Formula $s\in S$
\end_inset

 and 
\begin_inset Formula $t\in T$
\end_inset

 is defined 
\begin_inset Formula 
\[
c\left(S,T\right)=\sum_{u\in S}\sum_{v\in T}c\left(u,v\right)
\]

\end_inset

i.e.
 the sum of the capacities of all of the edges crossing the cut.
 The 
\series bold
minimum cut
\series default
 of a network is a cut whose capacity is minimum over all cuts of the network
 (where the source is in one partition and the sink is in the other).
 Naturally the net flow across any cut is equal to 
\begin_inset Formula $\left|f\right|$
\end_inset

.
 Something stronger is true.
\end_layout

\begin_layout Theorem
Min cut - Max flow
\end_layout

\begin_layout Theorem
The following are equivalent
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $f$
\end_inset

 is a maximum flow in 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Enumerate
The residual network 
\begin_inset Formula $G'$
\end_inset

 contains no augmenting paths.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left|f\right|=c\left(S,T\right)$
\end_inset

 for some cut 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 of 
\begin_inset Formula $G$
\end_inset

.
 In fact the minimum capacity cut.
\end_layout

\end_deeper
\begin_layout Standard
After all that the Ford-Fulkerson/Edmond's-Karp algorithm for finding the
 max flow on a flow network 
\begin_inset Formula $G$
\end_inset

 is simple: construct the residual network 
\begin_inset Formula $G'$
\end_inset

 and keep looking for augmenting paths and use them to augment the flow
 on 
\begin_inset Formula $G$
\end_inset

.
 When there are no more we know that 
\begin_inset Formula $f$
\end_inset

 is a maximum flow and that 
\begin_inset Formula $\left|f\right|$
\end_inset

 is equal to the minimum cut.
 We use breadth-first search to find the augmenting path.
 First we need a function that constructs the residual network.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Residual-Network
\family default

\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

$E' = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=1:
\backslash
text{len}
\backslash
left(V
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	for $j=1:
\backslash
text{len}
\backslash
left(V
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

		$E'
\backslash
left[
\backslash
left(i,j
\backslash
right)
\backslash
right] = 
\backslash
left
\backslash
{
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

		if $
\backslash
left(i,j
\backslash
right) 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

			$E'
\backslash
left[
\backslash
left(i,j
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'capacity'}
\backslash
right] = 
\backslash
max
\backslash
left
\backslash
{0,E
\backslash
left[
\backslash
left(i,j
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'capacity'}
\backslash
right] - E
\backslash
left[
\backslash
left(i,j
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'flow'}
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

		elif $
\backslash
left(j,i
\backslash
right) 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

			$E'
\backslash
left[
\backslash
left(i,j
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'capacity'}
\backslash
right] =  E
\backslash
left[
\backslash
left(j,i
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'flow'}
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			$E'
\backslash
left[
\backslash
left(i,j
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'capacity'}
\backslash
right] = 0$
\end_layout

\begin_layout Plain Layout

return $
\backslash
left(V,E'
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally we implement the plan of search for augment paths and using them
 to augment the flow on 
\begin_inset Formula $G$
\end_inset

.
 Running time is 
\begin_inset Formula $O\left(VE^{2}\right)$
\end_inset

 because the number of augmentations is 
\begin_inset Formula $O\left(VE\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Ford-Fulkerson-Edmonds-Karp
\family default

\begin_inset Formula $\left(G,s,t\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$V,E = G$
\end_layout

\begin_layout Plain Layout

for $u,v 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

	$E
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'flow'}
\backslash
right] = 0$
\end_layout

\begin_layout Plain Layout

# let's pretend Breadth-first-search returns a path if one exists
\end_layout

\begin_layout Plain Layout

# or None if none exists
\end_layout

\begin_layout Plain Layout

$G' = 
\backslash
text{Residual-Network}
\backslash
left(G
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$V,E' = G'$
\end_layout

\begin_layout Plain Layout

$p = 
\backslash
text{Breadth-first-search}
\backslash
left(G',s,t
\backslash
right)$
\end_layout

\begin_layout Plain Layout

while $p 
\backslash
neq 
\backslash
text{None}$:
\end_layout

\begin_layout Plain Layout

	$c_f = 
\backslash
min
\backslash
left
\backslash
{
\backslash
left[ E'
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'capacity'}
\backslash
right] 
\backslash
text{ for }
\backslash
left(u,v
\backslash
right)
\backslash
in p 
\backslash
right]
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

	for $
\backslash
left(u,v
\backslash
right) 
\backslash
in p$:
\end_layout

\begin_layout Plain Layout

		if $
\backslash
left(u,v
\backslash
right) 
\backslash
in E$:
\end_layout

\begin_layout Plain Layout

			$E
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'flow'}
\backslash
right] = E
\backslash
left[
\backslash
left(u,v
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'flow'}
\backslash
right] + c_f$
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			$E
\backslash
left[
\backslash
left(v,u
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'flow'}
\backslash
right] = E
\backslash
left[
\backslash
left(v,u
\backslash
right)
\backslash
right]
\backslash
left[
\backslash
text{'flow'}
\backslash
right] - c_f$
\end_layout

\begin_layout Plain Layout

	$G' = 
\backslash
text{Residual-Network}
\backslash
left(G
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$V,E' = G'$
\end_layout

\begin_layout Plain Layout

	$p = 
\backslash
text{Breadth-first-search}
\backslash
left(G',s,t
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset

To find the min cut: do a depth-first search in the 
\emph on
residual 
\emph default
network
\emph on
 
\emph default
from the source 
\begin_inset Formula $s$
\end_inset

 marking all vertices which can be reached.
 The cut is all edges going from marked vertices to unmarked vertices.
 Those edges are saturated and correspond to the minimum cut.
 To prove this we need to basically almost prove the Min cut - Max Flow
 theorem
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 be a flow network with 
\begin_inset Formula $s,t$
\end_inset

 being source and sink.
 Consider the flow 
\begin_inset Formula $f$
\end_inset

 computed for 
\begin_inset Formula $G$
\end_inset

 by Ford-Fulkerson.
 In the residual network 
\begin_inset Formula $G'$
\end_inset

 define 
\begin_inset Formula $A$
\end_inset

 to be the set of vertices reachable from 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $A^{c}=V\backslash A$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Claim*
\begin_inset Formula $\left|f\right|=c\left(A,A^{c}\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Proof
Since 
\begin_inset Formula $\left|f\right|=\sum_{u\in A}\sum_{v\in A^{c}}f\left(u,v\right)-\sum_{v\in A^{c}}\sum_{u\in A}f\left(v,u\right)$
\end_inset

, i.e.
 flow out of 
\begin_inset Formula $A$
\end_inset

 minus flow into 
\begin_inset Formula $A$
\end_inset

, for 
\begin_inset Formula $\left|f\right|$
\end_inset

 to equal 
\begin_inset Formula $c\left(A,A^{c}\right)$
\end_inset

 we need 
\end_layout

\begin_deeper
\begin_layout Enumerate
All outgoing edges from 
\begin_inset Formula $A$
\end_inset

 to be saturated.
\end_layout

\begin_layout Enumerate
All incoming edges to have zero flow.
\end_layout

\begin_layout Standard
Why? Because 
\begin_inset Formula 
\[
c\left(A,A^{c}\right)=\sum_{u\in A}\sum_{v\in A^{c}}c\left(\left(u,v\right)\right)
\]

\end_inset

and so we should have 
\begin_inset Formula $c\left(\left(u,v\right)\right)=f\left(u,v\right)$
\end_inset

 for each out going edge and 
\begin_inset Formula $f\left(v,u\right)$
\end_inset

 for each incoming edge.
 We verify this by considering two cases:
\end_layout

\begin_layout Enumerate
In 
\begin_inset Formula $G$
\end_inset

 there exists an outgoing edge 
\begin_inset Formula $\left(x,y\right),x\in A,y\in A^{c}$
\end_inset

 that is not saturated.
 This implies there's an edge 
\begin_inset Formula $\left(x,y\right)\in E_{f}$
\end_inset

 and therefore a path from 
\begin_inset Formula $s\in A$
\end_inset

 to 
\begin_inset Formula $y\in A^{c}$
\end_inset

, which contradicts that 
\begin_inset Formula $A^{c}$
\end_inset

 is unreachable from 
\begin_inset Formula $s$
\end_inset

.
 Therefore 
\begin_inset Formula $\left(x,y\right)\in G$
\end_inset

 is saturated.
 
\end_layout

\begin_layout Enumerate
In 
\begin_inset Formula $G$
\end_inset

 there exists an incoming edge 
\begin_inset Formula $\left(y,x\right),x\in A,y\in A^{c}$
\end_inset

 that is not 0.
 This implies there's a squelch edge 
\begin_inset Formula $\left(x,y\right)\in E_{f}$
\end_inset

 and therefore a path from 
\begin_inset Formula $s\in A$
\end_inset

 to 
\begin_inset Formula $y\in A^{c}$
\end_inset

, which contradicts that 
\begin_inset Formula $A^{c}$
\end_inset

 is unreachable from 
\begin_inset Formula $s$
\end_inset

.
 Therefore 
\begin_inset Formula $\left(y,x\right)\in G$
\end_inset

 has zero flow.
 
\end_layout

\begin_layout Standard
Therefore 
\begin_inset Formula $\left|f\right|=c\left(A,A^{c}\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
Since 
\begin_inset Formula $f$
\end_inset

 was obtained my Ford-Fulkerson it is the maximum flow on the network.
 Then since any flow in the network is bounded above by every cut, and in
 particular the minimum cut, the above described cut
\begin_inset Formula 
\[
c\left(A,A^{c}\right)=\sum_{u\in A}\sum_{v\in A^{c}}c\left(\left(u,v\right)\right)
\]

\end_inset

 is the minimum cut.
\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Maximum bipartite matching
\end_layout

\begin_layout Standard
A bipartite graph is one for which the vertices can be divided into two
 sets, with edges only going between the two sets.
 A 
\series bold
maximum bipartite matching 
\series default
is one which 1-1 matches the largest number of vertices.
 The matching problem is finding such a matching.
 The solution is two use Min cut - Max flow: set up a source that connects
 to all of the vertices in one partition and a sink that connects to all
 of the vertices in the other.
 Then set the capacity of all edges to 1 and run Edmonds-Karp.
 The minimum cut corresponding to the maximum flow gives you the matching.
 How do we know that the flow will take on an integer value? I.e.
 that we won't flow 
\begin_inset Formula $3/4$
\end_inset

 and 
\begin_inset Formula $1/4$
\end_inset

 down some edges? 
\end_layout

\begin_layout Theorem
Integrality theorem
\end_layout

\begin_layout Theorem
If the capacity function 
\begin_inset Formula $c\left(\left(u,v\right)\right)$
\end_inset

 takes on only integral values, then the maximum flow 
\begin_inset Formula $f$
\end_inset

 produced by the Ford-Fulkerson method has the property that 
\begin_inset Formula $\left|f\right|$
\end_inset

 is an integer and furthermore 
\begin_inset Formula $f\left(u,v\right)$
\end_inset

 is an integer for all 
\begin_inset Formula $u,v$
\end_inset

.
\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(VE\right)$
\end_inset

.
\end_layout

\begin_layout Part
Selected Topics
\end_layout

\begin_layout Section
Number Theory
\end_layout

\begin_layout Subsection
Euclidean GCD Algorithm
\end_layout

\begin_layout Standard
\begin_inset Formula $\gcd\left(a,b\right)$
\end_inset

 is the greatest common divisor of 
\begin_inset Formula $a,b$
\end_inset

.
 If 
\begin_inset Formula $a>b$
\end_inset

 then it's the case that 
\begin_inset Formula $\gcd\left(a,b\right)=\gcd\left(b,a\mod b\right)$
\end_inset

.
 For example 
\begin_inset Formula 
\begin{eqnarray*}
\gcd\left(1071,462\right) & = & \gcd\left(462,1071\mod462\right)\\
 & = & \gcd\left(462,147\right)\\
 & = & \gcd\left(147,462\mod147\right)\\
 & = & \gcd\left(147,21\right)\\
 & = & \gcd\left(21,147\mod21\right)\\
 & = & \gcd\left(21,0\right)\\
 & = & 21
\end{eqnarray*}

\end_inset

This leads to a naive algorithm for gcd.
 Running time is 
\begin_inset Formula $O\left(\lg b\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Naive-GCD
\family default

\begin_inset Formula $\left(a,b\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# assume $a>b$
\end_layout

\begin_layout Plain Layout

if $b == 0$:
\end_layout

\begin_layout Plain Layout

	return $a$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	return $
\backslash
text{Naive-GCD}
\backslash
left(b,a
\backslash
mod b
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can even make the algorithm iterative easily.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Naive-GCD-Iter
\family default

\begin_inset Formula $\left(a,b\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# assume $a>b$
\end_layout

\begin_layout Plain Layout

while $b 
\backslash
neq 0$:
\end_layout

\begin_layout Plain Layout

	# note the flip so that we preserve $a>b$
\end_layout

\begin_layout Plain Layout

	$a,b = b, a
\backslash
mod b$
\end_layout

\begin_layout Plain Layout

return $a$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Furthermore for any common divisor of 
\begin_inset Formula $a,b$
\end_inset

 we have 
\begin_inset Formula $d=ax+by$
\end_inset

 for some 
\begin_inset Formula $x,y$
\end_inset

.
 How do we find 
\begin_inset Formula $x,y$
\end_inset

 for 
\begin_inset Formula $d=\gcd\left(a,b\right)$
\end_inset

? Take the same example as above: 
\begin_inset Formula 
\begin{eqnarray*}
\gcd\left(1071,462\right) & = & 1071x+462y\\
\gcd\left(462,147\right) & = & 462x'+147y'
\end{eqnarray*}

\end_inset

but 
\begin_inset Formula 
\[
147=1071\mod462=1071-\left\lfloor \frac{1071}{462}\right\rfloor \cdot462
\]

\end_inset

so 
\begin_inset Formula 
\begin{eqnarray*}
1071x+462y & = & 462x'+\left(1071-\left\lfloor \frac{1071}{462}\right\rfloor \cdot462\right)y'\\
 & = & 1071y'+462\left(x'-\left\lfloor \frac{1071}{462}\right\rfloor y'\right)
\end{eqnarray*}

\end_inset

Hence we can recover 
\begin_inset Formula $x,y$
\end_inset

 from 
\begin_inset Formula $x',y'$
\end_inset

 using 
\begin_inset Formula 
\begin{eqnarray*}
x & = & y'\\
y & = & x'-\left\lfloor \frac{1071}{462}\right\rfloor y'
\end{eqnarray*}

\end_inset

Let's start from bottom of the recursion
\begin_inset Formula 
\begin{eqnarray*}
\gcd\left(147,21\right) & = & 147x+21y\\
\gcd\left(21,0\right) & = & 21x'+0y'
\end{eqnarray*}

\end_inset

Since 
\begin_inset Formula $\gcd\left(21,0\right)=21$
\end_inset

 so 
\begin_inset Formula $x'=1$
\end_inset

 and 
\begin_inset Formula $y'=0$
\end_inset

 and we get that
\begin_inset Formula 
\begin{eqnarray*}
x & = & y'=0\\
y & = & x'-\left\lfloor \frac{147}{21}\right\rfloor y'=1-0=1
\end{eqnarray*}

\end_inset

Then another level up 
\begin_inset Formula 
\begin{eqnarray*}
\gcd\left(462,147\right) & = & 462x+147y\\
\gcd\left(147,21\right) & = & 147x+21y
\end{eqnarray*}

\end_inset

with 
\begin_inset Formula 
\begin{eqnarray*}
x & = & y'=1\\
y & = & x'-\left\lfloor \frac{462}{147}\right\rfloor y'=0-3\cdot1=-3
\end{eqnarray*}

\end_inset

Then another level up 
\begin_inset Formula 
\begin{eqnarray*}
\gcd\left(1071,462\right) & = & 1071x+462y\\
\gcd\left(462,147\right) & = & 462x'+147y'
\end{eqnarray*}

\end_inset

with 
\begin_inset Formula 
\begin{eqnarray*}
x & = & y'=-3\\
y & = & x'-\left\lfloor \frac{1071}{462}\right\rfloor y'=1-2\cdot\left(-3\right)=7
\end{eqnarray*}

\end_inset

and indeed 
\begin_inset Formula $-3\cdot1071+7\cdot462=21.$
\end_inset

 In general we need 
\begin_inset Formula $x',y'$
\end_inset

 from the next iteration and 
\begin_inset Formula $a,b$
\end_inset

 from the current iteration and we can use the recursion relation
\begin_inset Formula 
\begin{eqnarray*}
x & = & y'\\
y & = & x'-\left\lfloor \frac{a}{b}\right\rfloor y'
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Naive-Extended-GCD
\family default

\begin_inset Formula $\left(a,b\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# assume $a>b$
\end_layout

\begin_layout Plain Layout

if $b == 0$:
\end_layout

\begin_layout Plain Layout

	return $a,1,0$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$d,x,y = 
\backslash
text{Naive-Extended-GCD}
\backslash
left(b,a
\backslash
mod b
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$x,y = y, x- 
\backslash
left
\backslash
lfloor 
\backslash
frac{a}{b}
\backslash
right
\backslash
rfloor 
\backslash
cdot y$
\end_layout

\begin_layout Plain Layout

	return $d,x,y$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This version is tougher to make iterative (or at least to prove that the
 iterative version is correct).
 Running time is still 
\begin_inset Formula $O\left(\lg b\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Extended-GCD
\family default

\begin_inset Formula $\left(a,b\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# assume $a>b$
\end_layout

\begin_layout Plain Layout

$x_0,y_0,x_1,y_1 = 1,0,0,1$
\end_layout

\begin_layout Plain Layout

while $b 
\backslash
neq 0$:
\end_layout

\begin_layout Plain Layout

	$q 
\backslash
left
\backslash
lfloor 
\backslash
frac{a}{b}
\backslash
right
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout

	$a,b = b, a 
\backslash
mod b$
\end_layout

\begin_layout Plain Layout

	$x_0,x_1 = x_1,x_0 - q
\backslash
cdot x_1$
\end_layout

\begin_layout Plain Layout

	$y_0,y_1 = y_1,y_0 - q
\backslash
cdot y_1$
\end_layout

\begin_layout Plain Layout

return $a,x_0,y_0$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solving modular linear equations
\end_layout

\begin_layout Standard
A modular linear equation is 
\begin_inset Formula $ax\equiv b\mod n$
\end_inset

 (
\begin_inset Formula $ax=kn$
\end_inset

 for some 
\begin_inset Formula $k$
\end_inset

).
 The task is to solve for 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $\gcd\left(a,b,\right)=d=ax'+ny'$
\end_inset

 for integers 
\begin_inset Formula $x',y'$
\end_inset

.
 If 
\begin_inset Formula $d|b$
\end_inset

 then 
\begin_inset Formula $ax\equiv_{n}b$
\end_inset

 has at least one solution 
\begin_inset Formula 
\[
x_{0}=x'\left(\frac{b}{d}\right)\mod n
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Proof
We have
\begin_inset Formula 
\begin{eqnarray*}
ax_{0} & \equiv_{n} & ax'\left(\frac{b}{d}\right)\\
 & \equiv_{n} & d\left(\frac{b}{d}\right)\text{ since }ax'\equiv_{n}d\\
 & \equiv_{n} & b
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Theorem
Suppose 
\begin_inset Formula $x_{0}$
\end_inset

 is a solution to the above.
 Then there are 
\begin_inset Formula $d-1$
\end_inset

 more solutions
\begin_inset Formula 
\[
x_{i}=x_{0}+i\left(\frac{n}{d}\right)
\]

\end_inset

for 
\begin_inset Formula $i=1,\dots,d-1$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Proof
Since 
\begin_inset Formula $x_{0}$
\end_inset

 is a solution
\begin_inset Formula 
\begin{eqnarray*}
ax_{i} & \equiv_{n} & a\left(x_{0}+i\left(\frac{n}{d}\right)\right)\\
 & \equiv_{n} & ax_{0}+ai\left(\frac{n}{d}\right)\\
 & \equiv_{n} & ax_{0}\text{ since }d|a\Rightarrow\left(\frac{a}{d}in\right)=kin\\
 & \equiv_{n} & b
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
This suggests an algorithm for finding all the solutions to 
\begin_inset Formula $ax\equiv_{n}b$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Modular-Equations
\family default

\begin_inset Formula $\left(a,b,n\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$d,x',y' = 
\backslash
text{Extended-GCD}
\backslash
left(a,n
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$xs = 
\backslash
left[~
\backslash
right]$
\end_layout

\begin_layout Plain Layout

if $d|b$:
\end_layout

\begin_layout Plain Layout

	$x_0 = x' 
\backslash
left( 
\backslash
frac{b}{d} 
\backslash
right) 
\backslash
mod n$
\end_layout

\begin_layout Plain Layout

	for $i = 0:d-1$:
\end_layout

\begin_layout Plain Layout

		$xs
\backslash
text{.append}
\backslash
left(x_0 + i 
\backslash
left(n/d
\backslash
right) 
\backslash
mod n
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return $xs$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Floyd's cycle finding algorithm
\end_layout

\begin_layout Standard
Suppose you have a sequence of values 
\begin_inset Formula $a_{0},a_{1},a_{2},\dots$
\end_inset

 that loops.
 How would you detect it without storing all the values? Suppose 
\begin_inset Formula $\mu$
\end_inset

 is the first index of the loop and 
\begin_inset Formula $\lambda$
\end_inset

 is the length of the loop, then for any integers 
\begin_inset Formula $i,k$
\end_inset

 such that 
\begin_inset Formula $i\geq\mu$
\end_inset

 and 
\begin_inset Formula $k\geq0$
\end_inset

 it's the case that 
\begin_inset Formula 
\[
x_{i}=x_{i+k\lambda}
\]

\end_inset

In particular if 
\begin_inset Formula $i=k\lambda$
\end_inset

 we have that 
\begin_inset Formula $x_{i}=x_{2i}$
\end_inset

.
 Thus we only need to iterate through the values with two iterators, one
 that goes twice as fast as the other and wait for equality.
 Once that occurs the two iterators are a distance 
\begin_inset Formula $i=k\lambda$
\end_inset

 apart, i.e.
 a multiple of the period of the loop, and the first iterator is 
\begin_inset Formula $i=k\lambda$
\end_inset

 from the beginning.
 Resetting the second iterator to the beginning and advancing them each
 one at a time keeps them a fixed distance 
\begin_inset Formula $i=k\lambda$
\end_inset

 apart.
 Therefore once both of them are on the loop again (i.e.
 the second iterator returns to the loop) they must agree, i.e.
 they'll agree for the first time at the first element of the loop 
\begin_inset Formula $\mu$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Floyds-Cycle
\family default

\begin_inset Formula $\left(f,x_{1}\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $f$ generates the next element of the sequence
\end_layout

\begin_layout Plain Layout

$p_1 = f
\backslash
left(x_1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# $p_2$ advances twice as fast as $p_1$
\end_layout

\begin_layout Plain Layout

$p_2 = f
\backslash
left(f
\backslash
left(x_1
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

while $p_1 
\backslash
neq p_2$:
\end_layout

\begin_layout Plain Layout

	$p_1 = f
\backslash
left(p_1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$p_2 = f
\backslash
left(f
\backslash
left(p_2
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# start counting from the beginning 
\end_layout

\begin_layout Plain Layout

# while advancing both $p_1,p_2$ in lock step
\end_layout

\begin_layout Plain Layout

$
\backslash
mu = 1$
\end_layout

\begin_layout Plain Layout

$p_2 = x_1$
\end_layout

\begin_layout Plain Layout

while $p_1 
\backslash
neq p_2$:
\end_layout

\begin_layout Plain Layout

	$p_1 = f
\backslash
left(p_1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$p_2 = f
\backslash
left(p_2
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$
\backslash
mu = 
\backslash
mu +1$
\end_layout

\begin_layout Plain Layout

# advance only one two count the length of the loop
\end_layout

\begin_layout Plain Layout

$
\backslash
lambda = 1$
\end_layout

\begin_layout Plain Layout

$p_2 = f
\backslash
left(p_1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

while $p_1 
\backslash
neq p_2$:
\end_layout

\begin_layout Plain Layout

	$p_2 = f
\backslash
left(p_2
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$
\backslash
lambda = 
\backslash
lambda +1$
\end_layout

\begin_layout Plain Layout

return $
\backslash
lambda,
\backslash
mu$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exponentiation by squaring
\end_layout

\begin_layout Standard
How does exponentiation by repeated squaring work? Take for example 
\begin_inset Formula $3^{8}$
\end_inset

:
\begin_inset Formula 
\[
\left(\left(\left(3^{2}\right)^{2}\right)^{2}\right)^{2}=3^{8}
\]

\end_inset

How about 
\begin_inset Formula $3^{7}$
\end_inset

? The trick is to divide only even exponents: 
\begin_inset Formula $3^{7}$
\end_inset

 doesn't divide 
\begin_inset Quotes eld
\end_inset

evenly
\begin_inset Quotes erd
\end_inset

 but 
\begin_inset Formula $3^{6}$
\end_inset

 does.
 Then 
\begin_inset Formula $3^{3}$
\end_inset

 again doesn't divide evenly but 
\begin_inset Formula $3^{2}$
\end_inset

 does.
 So what should you do? Go in reverse order
\begin_inset Formula 
\[
3\cdot\left(\left(3\cdot3^{2}\right)^{2}\right)=3\cdot\left(\left(3^{3}\right)^{2}\right)=3\cdot\left(3^{6}\right)=3^{7}
\]

\end_inset

How about another example: 
\begin_inset Formula $3^{19}$
\end_inset


\begin_inset Formula 
\begin{eqnarray*}
3\cdot3^{18} & \rightarrow & 3^{18}\\
3^{18}=\left(3^{9}\right)\left(3^{9}\right) & \rightarrow & 3^{9}\\
3\cdot3^{8} & \rightarrow & 3^{8}\\
3^{8}=\left(3^{4}\right)\left(3^{4}\right) & \rightarrow & 3^{4}\\
3^{4}=\left(3^{2}\right)\left(3^{2}\right) & \rightarrow & 3^{2}\\
3^{2}=3\cdot3 & \rightarrow & 3^{1}\\
3^{1}=3\cdot1 & \rightarrow & 1
\end{eqnarray*}

\end_inset

Do you see the pattern? The binary representation of 19 is 10011, which
 matches the order in which we took the square root or factored out a 3
 and then took the square root.
 Why?
\begin_inset Formula 
\begin{eqnarray*}
3^{19} & = & 3^{\left(1\cdot2^{0}+1\cdot2^{1}+0\cdot2^{2}+0\cdot2^{3}+1\cdot2^{4}\right)}
\end{eqnarray*}

\end_inset

You can think of exponentiation by repeated squaring as building up the
 exponent using shift and add: every squaring is a shift and every multiplicatio
n by the base is adding 1.
 For example: first shift in one 3
\begin_inset Formula 
\[
\left(3\cdot1\right)=3^{0\text{b}1}
\]

\end_inset

Then shifting left twice
\begin_inset Formula 
\[
\left(\left(3^{0\text{b}1}\right)^{2}\right)^{2}=\left(3^{2\times0\text{b}1}\right)^{2}=\left(3^{0\text{b}10}\right)^{2}=3^{2\times0\text{b}10}=3^{0\text{b}100}
\]

\end_inset

Then shift left again and add 1
\begin_inset Formula 
\[
3\cdot\left(3^{0\text{b}100}\right)^{2}=\left(3^{0\text{b}1000+0\text{b}0001}\right)=3^{0\text{b}1001}
\]

\end_inset

and again
\begin_inset Formula 
\[
3\cdot\left(3^{0\text{b}1001}\right)^{2}=3^{0\text{b}10011}=3^{19}
\]

\end_inset


\end_layout

\begin_layout Standard
So the algorithm is to write out the binary representation of the exponent,
 and start building it using squaring and multiplication by the base.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Exponentiation-Squaring
\family default

\begin_inset Formula $\left(a,b\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $a^b$
\end_layout

\begin_layout Plain Layout

# $
\backslash
text{bin}
\backslash
left(x
\backslash
right)$ gives you a left-to-right 
\end_layout

\begin_layout Plain Layout

# highestbit-to-lowestbit binary represtnation of $x$
\end_layout

\begin_layout Plain Layout

$bbin = 
\backslash
text{bin}
\backslash
left(b
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ x = 1$
\end_layout

\begin_layout Plain Layout

for $i = 1:
\backslash
text{len}
\backslash
left(bbin
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

	# in either case you have to shift to make room
\end_layout

\begin_layout Plain Layout

	$x = x
\backslash
cdot x$
\end_layout

\begin_layout Plain Layout

	# then add the 1 if there's a 1 in the binary
\end_layout

\begin_layout Plain Layout

	if $
\backslash
text{bbin}
\backslash
left[i
\backslash
right] == 1$:
\end_layout

\begin_layout Plain Layout

		$x = a
\backslash
cdot x$		
\end_layout

\begin_layout Plain Layout

return $x$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To make this bottom we have to look at two more recursive algorithms: note
 that 
\begin_inset Formula 
\[
a^{b}=\begin{cases}
a\left(a^{\frac{b-1}{2}}\right)^{2} & \text{if }b\text{ is odd}\\
\left(a^{\frac{b}{2}}\right)^{2} & \text{if }b\text{ is even}
\end{cases}
\]

\end_inset

Hence
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Exponentiation-Squaring-Rec
\family default

\begin_inset Formula $\left(a,b\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $b == 0$:
\end_layout

\begin_layout Plain Layout

	return 1
\end_layout

\begin_layout Plain Layout

if $b 
\backslash
mod 2 == 0$:
\end_layout

\begin_layout Plain Layout

	$x = 
\backslash
text{Exponentiation-Squaring-Rec}
\backslash
left(a,
\backslash
frac{b}{2}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	return $x
\backslash
cdot x$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$x = 
\backslash
text{Exponentiation-Squaring-Rec}
\backslash
left(a,
\backslash
frac{b-1}{2}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	return $a 
\backslash
cdot x 
\backslash
cdot x$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another way to look at the recurence relation is 
\begin_inset Formula 
\[
a^{b}=\begin{cases}
a\left(a^{2}\right)^{\frac{b-1}{2}} & \text{if }b\text{ is odd}\\
\left(a^{2}\right)^{\frac{b}{2}} & \text{if }b\text{ is even}
\end{cases}
\]

\end_inset

which gives the equivalent algorithm 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Exponentiation-Squaring-Rec
\family default

\begin_inset Formula $\left(a,b\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $b == 0$:
\end_layout

\begin_layout Plain Layout

	return 1
\end_layout

\begin_layout Plain Layout

if $b 
\backslash
mod 2 == 0$:
\end_layout

\begin_layout Plain Layout

	return $
\backslash
text{Exponentiation-Squaring-Rec}
\backslash
left(a
\backslash
cdot a,
\backslash
frac{b}{2}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	return $a 
\backslash
cdot 
\backslash
text{Exponentiation-Squaring-Rec}
\backslash
left(a
\backslash
cdot a,
\backslash
frac{b-1}{2}
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is the one we'll make bottom up.
 To do so note that we're looking at the binary representation of the exponent
 least-significant bit to most-significant bit (the opposite of the other
 algorithm) and squaring when it's a 0 (current 
\begin_inset Formula $b$
\end_inset

 is even) and 
\begin_inset Quotes eld
\end_inset

sliding out
\begin_inset Quotes erd
\end_inset

 a copy of the current 
\begin_inset Formula $a$
\end_inset

 when it's a 1 (current 
\begin_inset Formula $b$
\end_inset

 is odd) and multiply it back in.
 So we use an auxiliary variable 
\begin_inset Formula $y$
\end_inset

 to keep all these slid out copies and then multiply them back in at the
 end.
 For example for 
\begin_inset Formula $x^{10}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
x^{20} & = & \left(x^{2}\right)^{20/2}=\left(x^{2}\right)^{10}\\
\left(x^{2}\right)^{10} & = & \left(x^{2}\times x^{2}\right)^{10/2}=\left(x^{2}\times x^{2}\right)^{5}\\
\left(x^{2}\times x^{2}\right)^{5} & = & x^{4}\left(\left(x^{2}\times x^{2}\right)\times\left(x^{2}\times x^{2}\right)\right)^{\frac{5-1}{2}}=x^{4}\left(\left(x^{2}\times x^{2}\right)\times\left(x^{2}\times x^{2}\right)\right)^{2}\\
\left(\left(x^{2}\times x^{2}\right)\times\left(x^{2}\times x^{2}\right)\right)^{2} & = & \left(\left[\left(x^{2}\times x^{2}\right)\times\left(x^{2}\times x^{2}\right)\right]\left[\left(x^{2}\times x^{2}\right)\times\left(x^{2}\times x^{2}\right)\right]\right)
\end{eqnarray*}

\end_inset

i.e 
\begin_inset Formula 
\begin{eqnarray*}
x^{20} & = & \left(x^{2}\right)^{10}\\
 & = & \left(x^{2}x^{2}\right)^{5}\\
 & = & \left(x^{2}x^{2}\right)^{1}\left(x^{2}x^{2}\right)^{4}\\
 & = & \left(x^{2}x^{2}\right)\left(\left(x^{2}x^{2}\right)\left(x^{2}x^{2}\right)\right)^{2}\\
 &  & \left(x^{2}x^{2}\right)\left(\left[\left(x^{2}x^{2}\right)\left(x^{2}x^{2}\right)\right]\left[\left(x^{2}x^{2}\right)\left(x^{2}x^{2}\right)\right]\right)
\end{eqnarray*}

\end_inset

Therefore
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Exponentiation-Squaring-Iter
\family default

\begin_inset Formula $\left(a,b\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

if $b == 0$:
\end_layout

\begin_layout Plain Layout

	return $1$
\end_layout

\begin_layout Plain Layout

eif $b == 1$:
\end_layout

\begin_layout Plain Layout

	return $a$
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	$ y = 1$
\end_layout

\begin_layout Plain Layout

	while $b > 1$:
\end_layout

\begin_layout Plain Layout

		if $b 
\backslash
mod 2 == 0$:
\end_layout

\begin_layout Plain Layout

			$a,b = a
\backslash
cdot a, b/2$
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			$y = y
\backslash
cdot a$
\end_layout

\begin_layout Plain Layout

			$a,b = a
\backslash
cdot a, 
\backslash
left(b-1
\backslash
right)/2$	
\end_layout

\begin_layout Plain Layout

	return $a 
\backslash
cdot y$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running time for all the algorithms is 
\begin_inset Formula $O\left(\lg b\right)$
\end_inset

.
 Note that all of these can be made to perform modular exponentiation but
 simply taking mod in the right places.
\end_layout

\begin_layout Section
String Matching
\end_layout

\begin_layout Standard
Suppose you have text 
\begin_inset Formula $T=\left[t_{1},\dots,t_{n}\right]$
\end_inset

 and pattern 
\begin_inset Formula $P=\left[p_{1},\dots,p_{m}\right]$
\end_inset

.
 The pattern 
\series bold
occurs with shift 
\begin_inset Formula $s$
\end_inset

 
\series default
if 
\begin_inset Formula $\left[t_{s+1},\dots,t_{s+m}\right]=P$
\end_inset

, i.e.
 
\begin_inset Formula $t_{s+j}=p_{j}$
\end_inset

 for 
\begin_inset Formula $1\leq j\leq m$
\end_inset

.
 The string matching problem is finding all valid shifts 
\begin_inset Formula $s$
\end_inset

 with which a given pattern 
\begin_inset Formula $P$
\end_inset

 occurs in a given text 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
Some notation.
 
\begin_inset Formula $\Sigma$
\end_inset

 is the text 
\series bold
alphabet
\series default
, i.e.
 
\begin_inset Formula $t_{i}\in\Sigma$
\end_inset

.
 For example 
\begin_inset Formula $\Sigma=\left\{ \texttt{a},\texttt{b},\dots,\texttt{z}\right\} $
\end_inset

, or 
\begin_inset Formula $\Sigma=\left\{ \texttt{0},\texttt{1}\right\} $
\end_inset

.
 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 is the set of all possible finite-length strings over the alphabet.
 The zero length 
\series bold
empty string
\series default
 is 
\begin_inset Formula $\varepsilon$
\end_inset

.
 The length of a string 
\begin_inset Formula $x$
\end_inset

 is denoted by 
\begin_inset Formula $\left|x\right|$
\end_inset

 and the 
\series bold
concatenation
\series default
 of two strings by 
\begin_inset Formula $xy$
\end_inset

.
 A string 
\begin_inset Formula $w$
\end_inset

 is a 
\series bold
prefix
\series default
 of a string 
\begin_inset Formula $x$
\end_inset

, denoted 
\begin_inset Formula $w\sqsubseteq x$
\end_inset

 if 
\begin_inset Formula $x=wy$
\end_inset

 for some string 
\begin_inset Formula $y$
\end_inset

.
 Note that it's possible 
\begin_inset Formula $y=\varepsilon$
\end_inset

 and so 
\begin_inset Formula $\left|w\right|\leq\left|x\right|$
\end_inset

.
 Similarly for a 
\series bold
suffix
\series default
, denoted 
\begin_inset Formula $w\sqsupseteq x$
\end_inset

.
 For example 
\begin_inset Formula $\texttt{ab}\sqsubseteq\texttt{abcca}$
\end_inset

 and 
\begin_inset Formula $\texttt{cca}\sqsupseteq\texttt{abcca}$
\end_inset

.
 For any character 
\begin_inset Formula $a$
\end_inset

 
\begin_inset Formula $x\sqsupseteq y$
\end_inset

 iff 
\begin_inset Formula $xa\sqsupseteq ya$
\end_inset

.
 Note that both 
\begin_inset Formula $\sqsupseteq$
\end_inset

 and 
\begin_inset Formula $\sqsubseteq$
\end_inset

 are transitive relations and the following obvious lemma holds:
\end_layout

\begin_layout Lemma
Overlapping suffix lemma
\end_layout

\begin_layout Lemma
Suppose 
\begin_inset Formula $x,y,z$
\end_inset

 are strings such that 
\begin_inset Formula $x\sqsupseteq z$
\end_inset

 and 
\begin_inset Formula $y\sqsupseteq z$
\end_inset

, i.e.
 
\begin_inset Formula $x,y$
\end_inset

 are both suffices of 
\begin_inset Formula $z$
\end_inset

.
 If 
\begin_inset Formula $\left|x\right|\leq\left|y\right|$
\end_inset

 then 
\begin_inset Formula $x$
\end_inset

 is a suffix of 
\begin_inset Formula $y$
\end_inset

, if 
\begin_inset Formula $\left|y\right|\leq\left|x\right|$
\end_inset

 then 
\begin_inset Formula $y$
\end_inset

 is a suffix of 
\begin_inset Formula $x$
\end_inset

, and if 
\begin_inset Formula $\left|x\right|=\left|y\right|$
\end_inset

 then 
\begin_inset Formula $x=y$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Naive string matching
\end_layout

\begin_layout Standard
The obvious algorithm runs in 
\begin_inset Formula $\Theta\left(\left(n-m+1\right)m\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Naive-String-Matching
\family default

\begin_inset Formula $\left(T,P\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ n = 
\backslash
text{len}
\backslash
left(T
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ m = 
\backslash
text{len}
\backslash
left(P
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $s = 0:n-m$:
\end_layout

\begin_layout Plain Layout

	if $T
\backslash
left[s+1:s+m
\backslash
right] == P$:
\end_layout

\begin_layout Plain Layout

		return $s$
\end_layout

\begin_layout Plain Layout

return None
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rabin-Karp
\end_layout

\begin_layout Standard
Rabin-Karp basically uses an incremental hash.
 Suppose 
\begin_inset Formula $\Sigma=\left\{ \texttt{0},\dots,\texttt{9}\right\} $
\end_inset

, so that each character is a decimal digit (in general we can use radix-
\begin_inset Formula $d$
\end_inset

 notation where 
\begin_inset Formula $d=\left|\Sigma\right|$
\end_inset

).
 Given a pattern 
\begin_inset Formula $P=\left[p_{1},\dots,p_{m}\right]$
\end_inset

 we can use horners rule to compute the number represented by the pattern
 in 
\begin_inset Formula $\Theta\left(m\right)$
\end_inset

 time:
\begin_inset Formula 
\[
p=p_{m}+10\left(p_{m-1}+10\left(p_{m-2}+\cdots+10\left(p_{2}+10p_{1}\right)\right)\right)
\]

\end_inset

Similarly we can compute 
\begin_inset Formula $t=T\left[1:m\right]$
\end_inset

 in 
\begin_inset Formula $\Theta\left(m\right)$
\end_inset

 time.
 Once we have 
\begin_inset Formula $p,t$
\end_inset

 we can compare them in a straighforward way, i.e.
 check if 
\begin_inset Formula $p-t=0$
\end_inset

.
 If so then we have a math.
 If not we need to advance to the next 
\begin_inset Formula $m$
\end_inset

 digits of 
\begin_inset Formula $T$
\end_inset

.
 We could recompute 
\begin_inset Formula $t'=T\left[2:m+1\right]$
\end_inset

 all over again but we actually do better: the updated 
\begin_inset Formula $t'$
\end_inset

 is related to the first 
\begin_inset Formula $t$
\end_inset

 by
\begin_inset Formula 
\[
t'=10\left(t-10^{m-1}t_{1}\right)+t_{m+1}
\]

\end_inset

What's happening? Add the highest order digit and strip off the lowest order
 digit.
 For example suppose 
\begin_inset Formula $T=\texttt{314152}$
\end_inset

 and 
\begin_inset Formula $t=31415$
\end_inset

 and 
\begin_inset Formula $=5$
\end_inset

.
 Then
\begin_inset Formula 
\begin{eqnarray*}
t' & = & 10\left(31415-10^{5-1}\cdot3\right)+2\\
 & = & 10\left(1415\right)+2\\
 & = & 14150+2\\
 & = & 14152
\end{eqnarray*}

\end_inset

In general if 
\begin_inset Formula $t^{\left(s\right)}$
\end_inset

 represents 
\begin_inset Formula $T\left[s+1:s+m\right]$
\end_inset

 then
\begin_inset Formula 
\[
t^{\left(s+1\right)}=10\left(t^{\left(s\right)}+10^{m-1}t_{s+1}\right)+t_{s+m+1}
\]

\end_inset


\end_layout

\begin_layout Standard
One thing we haven't considered is what happens when 
\begin_inset Formula $p$
\end_inset

 is too large to work with conveniently (larger then a processor word for
 example).
 Use mod (this is the sense in which Rabin-Karp is a rolling/incremental
 hash): pick 
\begin_inset Formula $q$
\end_inset

 to be prime and such that 
\begin_inset Formula $dq$
\end_inset

 fits in a word and then the recurrence update for 
\begin_inset Formula $t^{\left(s\right)}$
\end_inset

 becomes 
\begin_inset Formula 
\[
t^{\left(s+1\right)}=\left[d\left(t^{\left(s\right)}-\left(d^{m-1}\mod q\right)t_{s+1}\right)+t_{s+m+1}\right]\mod q
\]

\end_inset

One problem is that we might get false positives: two numbers might be equal
 
\begin_inset Formula $\mod q$
\end_inset

 but not be equal, so we need to verify.
 Preprocessing time is 
\begin_inset Formula $\Theta\left(m\right)$
\end_inset

 and running time is 
\begin_inset Formula $O\left(n+m\right)$
\end_inset

 (given some assumptions about how many valid shifts and spurious hits).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Rabin-Karp
\family default

\begin_inset Formula $\left(T,P,d,q\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ n = 
\backslash
text{len}
\backslash
left(T
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ m = 
\backslash
text{len}
\backslash
left(P
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ p,t = 0,0$
\end_layout

\begin_layout Plain Layout

for $i=1:m$:
\end_layout

\begin_layout Plain Layout

	# horner's rule
\end_layout

\begin_layout Plain Layout

	$ p = 
\backslash
left(d
\backslash
cdot p + P
\backslash
left[i
\backslash
right]
\backslash
right) 
\backslash
mod q$
\end_layout

\begin_layout Plain Layout

	$ t = 
\backslash
left(d
\backslash
cdot t + T
\backslash
left[i
\backslash
right]
\backslash
right) 
\backslash
mod q$
\end_layout

\begin_layout Plain Layout

for $s = 0:n-m$:
\end_layout

\begin_layout Plain Layout

	if $t == p$:
\end_layout

\begin_layout Plain Layout

		if $T
\backslash
left[s+1:s+m
\backslash
right] == P$:
\end_layout

\begin_layout Plain Layout

			return $s$
\end_layout

\begin_layout Plain Layout

	if $s < n-m$: # otherwise $T
\backslash
left[s+m+1
\backslash
right]$ is out of bounds
\end_layout

\begin_layout Plain Layout

		$t = 
\backslash
left[d
\backslash
cdot 
\backslash
left(t-
\backslash
left(10^{m-1}
\backslash
mod  q
\backslash
right)
\backslash
cdot T
\backslash
left[s+1
\backslash
right]
\backslash
right) + T
\backslash
left[s+m+1
\backslash
right]  
\backslash
right] 
\backslash
mod q$
\end_layout

\begin_layout Plain Layout

return None
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Finite automata
\end_layout

\begin_layout Standard
A 
\series bold
finite automaton 
\begin_inset Formula $M$
\end_inset

 
\series default
is a 5-tuple 
\begin_inset Formula $\left(Q,q_{0},A,\Sigma,\delta\right)$
\end_inset

 where 
\begin_inset Formula $Q$
\end_inset

 is a finite set of 
\series bold
states
\series default
, 
\begin_inset Formula $q_{0}\in Q$
\end_inset

 is the 
\series bold
start state
\series default
, 
\begin_inset Formula $A\subset Q$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

distinguished
\begin_inset Quotes erd
\end_inset

 set of states called 
\series bold
accepting states
\series default
, 
\begin_inset Formula $\Sigma$
\end_inset

 is a finite 
\series bold
input alphabet
\series default
, 
\begin_inset Formula $\delta$
\end_inset

 is a function from 
\begin_inset Formula $Q\times\Sigma\rightarrow Q$
\end_inset

 called the 
\series bold
transition function
\series default
.
\end_layout

\begin_layout Standard
The idea is to construct a finite automaton 
\begin_inset Formula $M\left(P\right)$
\end_inset

 that ends up in an accepting state if it scans 
\begin_inset Formula $T$
\end_inset

 and there's a match between 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

.
 In order to do this we focus on the state space 
\begin_inset Formula $Q$
\end_inset

 and the transition function 
\begin_inset Formula $\delta$
\end_inset

.
 First define the 
\series bold
suffix function
\series default
 
\begin_inset Formula 
\[
\sigma\left(x\right)=\max_{k}\left(P\left[1:k\right]\sqsupseteq x\right)
\]

\end_inset

i.e.
 the longest prefix of 
\begin_inset Formula $P$
\end_inset

 that is a suffix of 
\begin_inset Formula $x$
\end_inset

 (think about sliding 
\begin_inset Formula $x$
\end_inset

 from left to right underneath 
\begin_inset Formula $P$
\end_inset

).
 Note that 
\begin_inset Formula $x\sqsupseteq y$
\end_inset

 implies 
\begin_inset Formula $\sigma\left(x\right)\leq\sigma\left(y\right)$
\end_inset

, i.e.
 
\begin_inset Formula $x$
\end_inset

 is a suffix of 
\begin_inset Formula $y$
\end_inset

 implies that possibly a longer prefix of 
\begin_inset Formula $P$
\end_inset

 overlaps with a suffix of 
\begin_inset Formula $y$
\end_inset

, than a suffix of 
\begin_inset Formula $x$
\end_inset

.
 Given a pattern 
\begin_inset Formula $P$
\end_inset

 define the string matching automaton to be:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Q=\left\{ 0,1,\dots,m\right\} $
\end_inset

, i.e.
 how many letters of 
\begin_inset Formula $P$
\end_inset

 have been matched.
 
\begin_inset Formula $m$
\end_inset

 is the only accept state.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\delta\left(q,a\right)=\sigma\left(P\left[1:q\right]a\right)$
\end_inset

, where 
\begin_inset Formula $P\left[1:q\right]a$
\end_inset

 is 
\begin_inset Formula $P\left[1:q\right]$
\end_inset

 concatenated with 
\begin_inset Formula $a$
\end_inset

.
 
\end_layout

\begin_layout Standard
This definition for 
\begin_inset Formula $\delta$
\end_inset

 lets us 
\begin_inset Quotes eld
\end_inset

recycle
\begin_inset Quotes erd
\end_inset

 work already done.
 If we've matched 
\begin_inset Formula $P\left[1:q\right]$
\end_inset

 against 
\begin_inset Formula $T\left[s+1:s+q\right]$
\end_inset

 and 
\begin_inset Formula $T\left[s+q+1\right]=a$
\end_inset

 then 
\begin_inset Formula 
\[
T\left[s+1:s+q\right]a=P\left[1:q\right]a=P\left[1:q+1\right]
\]

\end_inset

i.e.
 
\begin_inset Formula $a$
\end_inset

 is a match, then we should advance to state 
\begin_inset Formula $q+1$
\end_inset

 (and indeed the longest prefix of 
\begin_inset Formula $P$
\end_inset

 that is a suffix of 
\begin_inset Formula $P\left[1:q\right]a$
\end_inset

 is 
\begin_inset Formula $P\left[1:q+1\right]$
\end_inset

 and therefore 
\begin_inset Formula $\sigma\left(P\left[1:q\right]a\right)=q+1$
\end_inset

).
 On the other hand if 
\begin_inset Formula $a$
\end_inset

 is not a match then 
\begin_inset Formula 
\[
T\left[s+1:s+q\right]a=P\left[1:q\right]a\neq P\left[1:q+1\right]
\]

\end_inset

i.e.
 we don't necessarily need to start all the way at the beginning, comparing
 
\begin_inset Formula $a$
\end_inset

 against 
\begin_inset Formula $P\left[1\right]$
\end_inset

, because maybe some trailing part of 
\begin_inset Formula $T\left[s+1:s+q\right]a$
\end_inset

 matches some prefix 
\begin_inset Formula $P$
\end_inset

.
 This is exactly what 
\begin_inset Formula $\sigma\left(T\left[s+1:s+q\right]a\right)=\sigma\left(P\left[1:q\right]a\right)$
\end_inset

 encodes.
\end_layout

\begin_layout Standard
Computing 
\begin_inset Formula $\delta$
\end_inset

 is straightforward: do exactly what 
\begin_inset Formula $\sigma\left(P\left[1:q\right]a\right)$
\end_inset

 says (look for the longest prefix of 
\begin_inset Formula $P$
\end_inset

 that matches 
\begin_inset Formula $P\left[1:q\right]a$
\end_inset

).
 Running time is 
\begin_inset Formula $O\left(m^{3}\left|\Sigma\right|\right)$
\end_inset

 but it can be improved to 
\begin_inset Formula $O\left(m\left|\Sigma\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Transition-Function
\family default

\begin_inset Formula $\left(P,\Sigma\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ m = 
\backslash
text{len}
\backslash
left(P
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $q = 0:m$:
\end_layout

\begin_layout Plain Layout

	for $a 
\backslash
in 
\backslash
Sigma$:
\end_layout

\begin_layout Plain Layout

		# initial optimistic guess, i.e.
 maybe
\end_layout

\begin_layout Plain Layout

		# $a$ is a match and advances us
\end_layout

\begin_layout Plain Layout

		$k = 
\backslash
min
\backslash
left(m,q+1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		# if we've matched $q$ characters in $P$
\end_layout

\begin_layout Plain Layout

		# and the next character is $a$
\end_layout

\begin_layout Plain Layout

		while $ P
\backslash
left[1:k
\backslash
right] 
\backslash
not
\backslash
sqsupseteq P
\backslash
left[1:q
\backslash
right]a$:
\end_layout

\begin_layout Plain Layout

			$k = k-1$
\end_layout

\begin_layout Plain Layout

		$
\backslash
delta
\backslash
left(q,a
\backslash
right) = k$
\end_layout

\begin_layout Plain Layout

return $
\backslash
delta$
\end_layout

\end_inset


\end_layout

\end_inset

Then the function that implements 
\begin_inset Formula $M$
\end_inset

 straightforward.
 Tototal running time then is 
\begin_inset Formula $O\left(m^{3}\left|\Sigma\right|\right)$
\end_inset

 or 
\begin_inset Formula $O\left(m\left|\Sigma\right|\right)$
\end_inset

 preprocessing time and 
\begin_inset Formula $O\left(n\right)$
\end_inset

 matching time.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Finite-Automaton-Matcher
\family default

\begin_inset Formula $\left(P,T,\Sigma\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ m = 
\backslash
text{len}
\backslash
left(P
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ n = 
\backslash
text{len}
\backslash
left(T
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ 
\backslash
delta = 
\backslash
text{Transition-Function}
\backslash
left(P,
\backslash
Sigma
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	$q = 
\backslash
delta
\backslash
left(q,T
\backslash
left[i
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	if $q == m$:
\end_layout

\begin_layout Plain Layout

		# $
\backslash
delta$ only reports $m$ at the end of matching
\end_layout

\begin_layout Plain Layout

		# all of $P$
\end_layout

\begin_layout Plain Layout

		return $i-m$
\end_layout

\begin_layout Plain Layout

return None
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Knuth-Morris-Pratt
\end_layout

\begin_layout Standard
Suppose the text 
\begin_inset Formula $T=\texttt{bacbababaabcbab}$
\end_inset

 and the pattern 
\begin_inset Formula $P=\texttt{ababaca}$
\end_inset

 and we've matched 5 characters but the 6th fails 
\begin_inset Formula 
\[
\begin{array}{ccccccccccccccc}
\texttt{b} & \texttt{a} & \texttt{c} & \texttt{b} & \texttt{a} & \texttt{b} & \texttt{a} & \texttt{b} & \texttt{a} & \textcolor{red}{\texttt{a}} & \texttt{b} & \texttt{c} & \texttt{b} & \texttt{a} & \texttt{b}\\
 &  &  &  & \texttt{a} & \texttt{b} & \texttt{a} & \texttt{b} & \texttt{a} & \textcolor{red}{\texttt{c}} & \texttt{a}
\end{array}
\]

\end_inset

We could slide 
\begin_inset Formula $P$
\end_inset

 one position forward and restart the entire process or we could notice
 that there's a partial overlap between a proper suffix of the 5 characters
 already matched and a prefix of the pattern
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 and only 
\begin_inset Quotes eld
\end_inset

backtrack
\begin_inset Quotes erd
\end_inset

 to put them into allignment, i.e.
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula 
\[
\begin{array}{ccccccccccccccc}
\texttt{b} & \texttt{a} & \texttt{c} & \texttt{b} & \texttt{a} & \texttt{b} & \textcolor{blue}{\texttt{a}} & \textcolor{blue}{\texttt{b}} & \textcolor{blue}{\texttt{a}} & \textcolor{red}{\texttt{a}} & \texttt{b} & \texttt{c} & \texttt{b} & \texttt{a} & \texttt{b}\\
 &  &  &  & \textcolor{blue}{\texttt{a}} & \textcolor{blue}{\texttt{b}} & \textcolor{blue}{\texttt{a}} & \texttt{b} & \texttt{a} & \textcolor{red}{\texttt{c}} & \texttt{a}
\end{array}
\]

\end_inset

to 
\begin_inset Formula 
\[
\begin{array}{ccccccccccccccc}
\texttt{b} & \texttt{a} & \texttt{c} & \texttt{b} & \texttt{a} & \texttt{b} & \textcolor{blue}{\texttt{a}} & \textcolor{blue}{\texttt{b}} & \textcolor{blue}{\texttt{a}} & \textcolor{green}{\texttt{a}} & \texttt{b} & \texttt{c} & \texttt{b} & \texttt{a} & \texttt{b}\\
 &  &  &  &  &  & \textcolor{blue}{\texttt{a}} & \textcolor{blue}{\texttt{b}} & \textcolor{blue}{\texttt{a}} & \textcolor{green}{\texttt{b}} & \texttt{a} & \texttt{c} & \texttt{a}
\end{array}
\]

\end_inset

and start checking there.
 Of course the match fails again but that's besides the point.
 
\end_layout

\begin_layout Standard
Let's formalize.
 A clearly useful piece of information to have when matching is: given 
\begin_inset Formula $P\left[1:q\right]$
\end_inset

 match against 
\begin_inset Formula $T\left[s+1:s+q\right]$
\end_inset

, what is the least shift 
\begin_inset Formula $s'>s$
\end_inset

 such that for 
\begin_inset Formula $k>q$
\end_inset

 
\begin_inset Formula 
\[
P\left[1:k\right]=T\left[s'+1:s'+k\right]
\]

\end_inset

where 
\begin_inset Formula $s'+k=s+q$
\end_inset

? Alternatively, given that 
\begin_inset Formula $P\left[1:q\right]$
\end_inset

 is a suffix of 
\begin_inset Formula $T\left[1:s+q\right]$
\end_inset

 for some 
\begin_inset Formula $s$
\end_inset

, what is the longest proper prefix 
\begin_inset Formula $P\left[1:k\right]$
\end_inset

 of 
\begin_inset Formula $P\left[1:q\right]$
\end_inset

 that is also a suffix of 
\begin_inset Formula $T\left[1:s+q\right]$
\end_inset

.
 Knuthi-Morris-Pratt answers this question using a 
\series bold
prefix function
\series default
 
\begin_inset Formula $\pi$
\end_inset

, which is pre-computed in 
\begin_inset Formula $\Theta\left(m\right)$
\end_inset

 time.
 It does this by comparing 
\begin_inset Formula $P$
\end_inset

 against itself: since 
\begin_inset Formula $T\left[s'+1:s'+k\right]$
\end_inset

 is a part of the known portion of the text, it is a suffix of 
\begin_inset Formula $P\left[1:q\right]$
\end_inset

.
 That is to say, we're looking for the greatest 
\begin_inset Formula $k<q$
\end_inset

 such that 
\begin_inset Formula $P\left[1:k\right]\sqsupset P\left[1:q\right]$
\end_inset

 (longest prefix of 
\begin_inset Formula $P$
\end_inset

 that is a 
\emph on
proper 
\emph default
suffix of 
\begin_inset Formula $P\left[1:q\right]$
\end_inset

) and then next potentially valid shift is 
\begin_inset Formula $s'=s+\left(q-k\right)$
\end_inset

.
 Formally 
\begin_inset Formula 
\[
\pi\left[q\right]=\max_{k<q}\left\{ P\left[1:k\right]\sqsupset P\left[1:q\right]\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Let's look at the matching algorithm before working out how to compute 
\begin_inset Formula $\pi$
\end_inset

.
 Running time is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Knuth-Morris-Pratt
\family default

\begin_inset Formula $\left(P,T\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ m = 
\backslash
text{len}
\backslash
left(P
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ n = 
\backslash
text{len}
\backslash
left(T
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$ 
\backslash
pi = 
\backslash
text{Prefix-Function}
\backslash
left(P
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$q = 0$
\end_layout

\begin_layout Plain Layout

# enter the loop with $P
\backslash
left[0
\backslash
right] = 
\backslash
varepsilon$
\end_layout

\begin_layout Plain Layout

# having been matched
\end_layout

\begin_layout Plain Layout

for $i=1:n$:
\end_layout

\begin_layout Plain Layout

	# at the top of the loop before this next line we have that $P
\backslash
left[1:q
\backslash
right]$ 
\end_layout

\begin_layout Plain Layout

	# characters of $P$ have been matched against some suffix
\end_layout

\begin_layout Plain Layout

	# $T
\backslash
left[s:i-1
\backslash
right]$ or $T
\backslash
left[1:i-1
\backslash
right]$.
 here we test whether the next character 
\end_layout

\begin_layout Plain Layout

	# of $P$ matches the next character of $T$
\end_layout

\begin_layout Plain Layout

	while $q > 0$ and $P
\backslash
left[q+1
\backslash
right]
\backslash
neq T
\backslash
left[i
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		# if the match fails then we look for where to "backtrack"
\end_layout

\begin_layout Plain Layout

		$q = 
\backslash
pi
\backslash
left[q
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# if we broke out of the loop because the next character after
\end_layout

\begin_layout Plain Layout

	# backtracking matches then we've matched one more character
\end_layout

\begin_layout Plain Layout

	# otherwise we've matched 0 characters (i.e.
 not even the first
\end_layout

\begin_layout Plain Layout

	# character of the pattern matches $T
\backslash
left[i
\backslash
right]$)
\end_layout

\begin_layout Plain Layout

	if $P
\backslash
left[q+1
\backslash
right] == T
\backslash
left[i
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$q = q+1$
\end_layout

\begin_layout Plain Layout

	if $ q == m$:
\end_layout

\begin_layout Plain Layout

		return $i-m$
\end_layout

\begin_layout Plain Layout

return None
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Knuth, Morris, and Pratt (who knows) came up with a clever way to compute
 
\begin_inset Formula $\pi$
\end_inset

 efficiently.
 I don't understand it exactly but it works in almost the exact same way
 as the matcher (therefore understanding the matcher, which is sensible,
 would allow you to reproduce the code for constructing the prefix function).
\end_layout

\begin_layout Standard
Running time is 
\begin_inset Formula $O\left(m\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Prefix-Function
\family default

\begin_inset Formula $\left(P\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$ m = 
\backslash
text{len}
\backslash
left(P
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$
\backslash
pi = m
\backslash
cdot
\backslash
left[0
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$ k = 0$
\end_layout

\begin_layout Plain Layout

for $q = 2:m$:
\end_layout

\begin_layout Plain Layout

	while $k > 0$ and $P
\backslash
left[k+1
\backslash
right] 
\backslash
neq P
\backslash
left[q
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$k = 
\backslash
pi
\backslash
left[k
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	if $P
\backslash
left[k+1
\backslash
right] == P
\backslash
left[q
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

		$k = k +1$
\end_layout

\begin_layout Plain Layout

	$
\backslash
pi 
\backslash
left[q
\backslash
right] = k$
\end_layout

\begin_layout Plain Layout

return $
\backslash
pi$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Computational Geometry
\end_layout

\begin_layout Standard
This section deals with vectors and points in 
\begin_inset Formula $\mathbb{R}^{2}$
\end_inset

.
 Points are represented 
\begin_inset Formula $p=\left(p_{x},p_{y}\right)$
\end_inset

 and operations are assumed to be component-wise.
 I'm going to assume that the cross product 
\begin_inset Formula $x\times y$
\end_inset

 of two vectors 
\begin_inset Formula $x,y$
\end_inset

 is a primitive.
 The orientation of vector 
\begin_inset Formula $x$
\end_inset

 with respect to vector 
\begin_inset Formula $y$
\end_inset

 is given by 
\begin_inset Formula $x\times y$
\end_inset

.
 If this quantity is positive then 
\begin_inset Formula $x$
\end_inset

 is counter-clockwise relative to 
\begin_inset Formula $y$
\end_inset

, otherwise clock-wise.
 If this quantity is zero then 
\begin_inset Formula $x,y$
\end_inset

 are parallel.
\end_layout

\begin_layout Subsection
Segment Intersection
\end_layout

\begin_layout Standard
To figure out whether two line-segments intersect figure out whether their
 endpoints 
\begin_inset Quotes eld
\end_inset

straddle
\begin_inset Quotes erd
\end_inset

 each other.
 What does that mean? Consider this picture
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename line_intersect.png
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the first case 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $p_{2}$
\end_inset

 straddle line-segment 
\begin_inset Formula $\overrightarrow{p_{3}p_{4}}$
\end_inset

 and vice-versa.
 In the second neither straddle.
 You have to check both because you might the case where two line-segments
 don't intersect but the lines they correspond to do (then one pair of points
 will straddle but the other won't - imagine a T disonnected at the joint).
 We can figure out if points straddle a line based on the orientations of
 the vectors from the base of that line to those points: let 
\begin_inset Formula $x=p_{1}-p_{3},y=p_{2}-p_{3},z=p_{4}-p_{3}$
\end_inset

 and then 
\begin_inset Formula $p_{1},p_{2}$
\end_inset

 straddle 
\begin_inset Formula $\overrightarrow{p_{3}p_{4}}$
\end_inset

 if 
\begin_inset Formula $x\times z$
\end_inset

 and 
\begin_inset Formula $y\times z$
\end_inset

 have opposite signs.
 Similarly for 
\begin_inset Formula $p_{3},p_{4}$
\end_inset

 straddling 
\begin_inset Formula $\overrightarrow{p_{1}p_{2}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
There's an edge case: if the linge segment intersect at endpoints then some
 of the cross products will be zero, so we have to check for that.
 Runtime is constant.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
On-Segment
\family default

\begin_inset Formula $\left(p_{i},p_{j},p_{k},\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# this is not a general intersection test
\end_layout

\begin_layout Plain Layout

# only in the case when $
\backslash
left(p_j -p_i
\backslash
right)
\backslash
times 
\backslash
left(p_j-p_i
\backslash
right)= 0$
\end_layout

\begin_layout Plain Layout

$
\backslash
left(x_i,y_i
\backslash
right) = p_i$
\end_layout

\begin_layout Plain Layout

$
\backslash
left(x_j,y_j
\backslash
right) = p_j$
\end_layout

\begin_layout Plain Layout

$
\backslash
left(x_k,y_k
\backslash
right) = p_k$
\end_layout

\begin_layout Plain Layout

	return $
\backslash
min
\backslash
left(x_i, x_j
\backslash
right) 
\backslash
leq x_k 
\backslash
leq 
\backslash
max
\backslash
left(x_i ,x_j
\backslash
right)$ and $
\backslash
min
\backslash
left(y_i, y_j
\backslash
right) 
\backslash
leq y_k 
\backslash
leq 
\backslash
max
\backslash
left(y_i ,y_j
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Segments-Intersect
\family default

\begin_inset Formula $\left(\ell_{1},\ell_{2}\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

$p_1,p_2$ = 
\backslash
ell_1$
\end_layout

\begin_layout Plain Layout

$p_3,p_4$ = 
\backslash
ell_2$
\end_layout

\begin_layout Plain Layout

$d_1 = 
\backslash
left(p_1 - p_3
\backslash
right) 
\backslash
times 
\backslash
left(p_4 - p_3
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$d_2 = 
\backslash
left(p_2 - p_3
\backslash
right) 
\backslash
times 
\backslash
left(p_4 - p_3
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$d_3 = 
\backslash
left(p_4 - p_1
\backslash
right) 
\backslash
times 
\backslash
left(p_2 - p_1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$d_4 = 
\backslash
left(p_3 - p_1
\backslash
right) 
\backslash
times 
\backslash
left(p_2 - p_1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

if $d_1 
\backslash
cdot d_2 < 0$ or $d_3 
\backslash
times d_4<0$:
\end_layout

\begin_layout Plain Layout

	return True
\end_layout

\begin_layout Plain Layout

elif $d_1 == 0$:
\end_layout

\begin_layout Plain Layout

	return $
\backslash
text{On-Segment}
\backslash
left(p_3,p_4,p_1
\backslash
right)$
\end_layout

\begin_layout Plain Layout

elif $d_2 == 0$:
\end_layout

\begin_layout Plain Layout

	return $
\backslash
text{On-Segment}
\backslash
left(p_3,p_4,p_2
\backslash
right)$
\end_layout

\begin_layout Plain Layout

elif $d_3 == 0$:
\end_layout

\begin_layout Plain Layout

	return $
\backslash
text{On-Segment}
\backslash
left(p_1,p_2,p_3
\backslash
right)$
\end_layout

\begin_layout Plain Layout

elif $d_4 == 0$:
\end_layout

\begin_layout Plain Layout

	return $
\backslash
text{On-Segment}
\backslash
left(p_1,p_2,p_4
\backslash
right)$	
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	return False
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Segment Pair intersection/Bentley-Ottmann
\end_layout

\begin_layout Standard
Given a set of line segments 
\begin_inset Formula $S$
\end_inset

 figure out whether any pair intersect.
 The naive algorithm is obviously 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
 The faster algorithm takes 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

 and uses a 
\begin_inset Quotes eld
\end_inset

sweep line
\begin_inset Quotes erd
\end_inset

: a data structure the keeps track lines intersected as an imaginary line
 is 
\begin_inset Quotes eld
\end_inset

swept
\begin_inset Quotes erd
\end_inset

 across the set of lines.
 
\end_layout

\begin_layout Standard
To line segments 
\begin_inset Formula $s_{1},s_{2}$
\end_inset

 are 
\series bold
comparable
\series default
 at coordinate 
\begin_inset Formula $x$
\end_inset

 if the vertical sweep line with 
\begin_inset Formula $x$
\end_inset

-coordinate 
\begin_inset Formula $x$
\end_inset

 intersects both of them.
 
\begin_inset Formula $s_{1}$
\end_inset

 is 
\series bold
above
\series default
 
\begin_inset Formula $s_{2}$
\end_inset

 if 
\begin_inset Formula $s_{1},s_{2}$
\end_inset

 are comparable and the intersection of 
\begin_inset Formula $s_{1}$
\end_inset

 with the sweep line is above the intersection of 
\begin_inset Formula $s_{2}$
\end_inset

 with the sweep line.
 Being above is a total preorder: the relation is transitive and if 
\begin_inset Formula $s_{1},s_{2}$
\end_inset

 are comparble at 
\begin_inset Formula $x$
\end_inset

 then either 
\begin_inset Formula $s_{1}$
\end_inset

 is above 
\begin_inset Formula $s_{2}$
\end_inset

, or 
\begin_inset Formula $s_{2}$
\end_inset

 is above 
\begin_inset Formula $s_{1}$
\end_inset

, or both (if 
\begin_inset Formula $s_{1},s_{2}$
\end_inset

 intersect at the sweep line with 
\begin_inset Formula $x$
\end_inset

-coordinate 
\begin_inset Formula $x$
\end_inset

).
\end_layout

\begin_layout Standard
The sweep lines algorithm manages two sets of data: 
\series bold
sweep-line status
\series default
, which gives the relationships between objects the sweep line intersects,
 and 
\series bold
event-point
\series default
 
\series bold
schedule
\series default
, which are the 
\begin_inset Formula $x$
\end_inset

-coordinates of the discrete steps of sweep line.
 We assume that the sweep-line status is a data structure that supports
 inserting a line segment 
\begin_inset Formula $s$
\end_inset

, deleting a line segment 
\begin_inset Formula $s$
\end_inset

, inspecting any line segments above 
\begin_inset Formula $s$
\end_inset

, and any line segments below 
\begin_inset Formula $s$
\end_inset

.
 We implement all of this with cost 
\begin_inset Formula $O\left(\lg n\right)$
\end_inset

 using a balanced binary search tree keyed on a sort of the line segments
 using comparison by cross product.
 
\end_layout

\begin_layout Standard
Assume that no three segments intersect at the same point.
 The key insight of the algorithm is that two line segments that intersect
 must be 
\emph on
consecutive
\emph default
 in the sweep-line status at some point in the event-point schedule.
 Consider the following picture 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename third_segment.png
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Line segments 
\begin_inset Formula $e,f$
\end_inset

 intersect but they are not consecutive in the sweep-line status until after
 the end of line segment 
\begin_inset Formula $g$
\end_inset

.
 Supposing 
\begin_inset Formula $g$
\end_inset

 were absent they would become consecutive at the beginning of 
\begin_inset Formula $f$
\end_inset

.
 So we only need to check at left endpoints whether a line segment intersects
 with line segments either below and above, or we need to check when removing
 line segments whether those above and below intersect.
 Here is the code.
 Running time is 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Set-Segments-Intersect
\family default

\begin_inset Formula $\left(S\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $T$ is a binary balanced search tree with comparison being done
\end_layout

\begin_layout Plain Layout

# by relative orientation using cross product
\end_layout

\begin_layout Plain Layout

# so that we can fetch line segments by either left
\end_layout

\begin_layout Plain Layout

# endpoint or right endpoint
\end_layout

\begin_layout Plain Layout

$ left = 
\backslash
left
\backslash
{ s
\backslash
left[1
\backslash
right]:s 
\backslash
text{ for } s
\backslash
in S
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

$ right = 
\backslash
left
\backslash
{ s
\backslash
left[2
\backslash
right]:s 
\backslash
text{ for } s
\backslash
in S
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

$T = 
\backslash
text{tree}
\backslash
left(
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# lexicographically sort all of the endpoints in $S$
\end_layout

\begin_layout Plain Layout

# except left endpoints should precede right endpoints
\end_layout

\begin_layout Plain Layout

$sched = 
\backslash
text{sorted}
\backslash
left(
\backslash
left[ p
\backslash
text{ for }line 
\backslash
in S
\backslash
text{ for }p 
\backslash
in line 
\backslash
right] )
\backslash
right)$
\end_layout

\begin_layout Plain Layout

for $p 
\backslash
in sched$:
\end_layout

\begin_layout Plain Layout

	if $p 
\backslash
in left$:
\end_layout

\begin_layout Plain Layout

		if $p 
\backslash
in right$:
\end_layout

\begin_layout Plain Layout

			return True
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			$ s = left
\backslash
left[p
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			$
\backslash
text{Insert}
\backslash
left(T,s
\backslash
right)$
\end_layout

\begin_layout Plain Layout

			if $
\backslash
text{Segment-Intersect}
\backslash
left(
\backslash
text{Above}
\backslash
left(T,s
\backslash
right),s
\backslash
right)$ or $
\backslash
text{Segment-Intersect}
\backslash
left(
\backslash
text{Below}
\backslash
left(T,s
\backslash
right),s
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

				return True
\end_layout

\begin_layout Plain Layout

	else: # $p$ is a right endpoint.
\end_layout

\begin_layout Plain Layout

		$ s = right
\backslash
left[p
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		# this is the case alluded to above: if a third line segment
\end_layout

\begin_layout Plain Layout

		# intervenes between two other line
\end_layout

\begin_layout Plain Layout

		if $
\backslash
text{Segment-Intersect}
\backslash
left(
\backslash
text{Above}
\backslash
left(T,s
\backslash
right),
\backslash
text{Below}
\backslash
left(T,s
\backslash
right)
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

			return True
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{Delete}
\backslash
left(T,s
\backslash
right)$
\end_layout

\begin_layout Plain Layout

return False
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the algorithm does not find all intersections (only an intersection).
 The algorithm that prints 
\emph on
all
\emph default
 of the intersection is called Bentley-Ottman and operates similarly.
 Instead of simply a sorted list of event points it uses a priority queue
 of event points.
 It then does one of 3 things depending on the type of event point
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $p$
\end_inset

 is a left endpoint of a line segment 
\begin_inset Formula $s$
\end_inset

, then insert 
\begin_inset Formula $s$
\end_inset

 into the 
\begin_inset Formula $T$
\end_inset

, and if 
\begin_inset Formula $s$
\end_inset

 intersects a neighbor then insert their intersection point to the priority
 queue (computing the intersection point can be done in constant time by
 solving the system of equations defining the two lines that correspond
 to the line segments).
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $p$
\end_inset

 is right endpoint, then check the intersection of its neighbors, and delete
 
\begin_inset Formula $p$
\end_inset

 from 
\begin_inset Formula $T$
\end_inset

.
 If the neighbors intersect then add their intersection point to the priority
 queue.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $p$
\end_inset

 is an intersection point of two lines segments 
\begin_inset Formula $s_{1},s_{2}$
\end_inset

, then print, and exchange their order in 
\begin_inset Formula $T$
\end_inset

.
 If the new neigbhors of 
\begin_inset Formula $s_{1},s_{2}$
\end_inset

 intersect with either 
\begin_inset Formula $s_{1}$
\end_inset

 or 
\begin_inset Formula $s_{2}$
\end_inset

 then insert those intersection points.
\end_layout

\begin_layout Standard
Running time for 
\begin_inset Formula $k$
\end_inset

 intersections is 
\begin_inset Formula $O\left(\left(n+k\right)\lg n\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Convex hull - Graham's Scan
\end_layout

\begin_layout Standard
Think of the convex hull of a set of points as a rubber band stretched to
 enclose all of them - it doesn't sag and connects points on the 
\begin_inset Quotes eld
\end_inset

edges
\begin_inset Quotes erd
\end_inset

 by straight lines.
 The formal definition is the smallest convex polygon that contains all
 the points (a convex polygon is one such that any point 
\begin_inset Formula $x$
\end_inset

 in the polygon can be written as a convex combination
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Formula $x=y_{1}\alpha+\left(1-\alpha\right)y_{2}$
\end_inset

 for 
\begin_inset Formula $0\leq\alpha\leq1$
\end_inset

.
\end_layout

\end_inset

 of two other points.
\end_layout

\begin_layout Standard
Graham's scan solves the problem of finding the convex hull by maintaining
 a stack of canddiate points while traversing a list of all of the points
 sorted by polar angle in counter-clockwise order.
 For each new point it figures out whether the new point constitutes a left
 turn or right turn relative to the existing candidate points.
 If the point makes a right turn then the point it pivots around isn't in
 the convex hull, so that point should be removed, and so on until the new
 point being considered makes a left turn.
 This picture should illustrate the process
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename grahams.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The running time is 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Graham-Scan
\family default

\begin_inset Formula $\left(Q\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $Q$ is a set of points
\end_layout

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# sort all the points lexicographically in order to find
\end_layout

\begin_layout Plain Layout

# the one that's most south-eastern
\end_layout

\begin_layout Plain Layout

$Q = 
\backslash
text{sorted}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$p_0 = Q
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# sort the remaining points by polar angle w.r.t $p_0$
\end_layout

\begin_layout Plain Layout

$Q = 
\backslash
text{sorted}
\backslash
left(
\backslash
left[ 
\backslash
left(p,p - p_0
\backslash
right) 
\backslash
text{ for } p
\backslash
in Q
\backslash
left[2:
\backslash
right]
\backslash
right],
\backslash
text{cmp}= 
\backslash
text{lambda }x,y:  x 
\backslash
times y, 
\backslash
text{key}=
\backslash
text{itemgetter}
\backslash
left(2
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$Q = 
\backslash
left[ p
\backslash
left[1
\backslash
right] 
\backslash
text{ for }p 
\backslash
in Q
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$stk = 
\backslash
left[p_0,p_1,p_2
\backslash
right]$
\end_layout

\begin_layout Plain Layout

for $i=3:n$:
\end_layout

\begin_layout Plain Layout

	# a nonleft turn is when $
\backslash
overrightarrow{Q
\backslash
left[-2
\backslash
right] p_{i}}$ is counterclockwise of $
\backslash
overrightarrow{ Q
\backslash
left[-2
\backslash
right] Q
\backslash
left[-1
\backslash
right]}$
\end_layout

\begin_layout Plain Layout

	while $ 
\backslash
left(p_i - Q
\backslash
left[-2
\backslash
right]
\backslash
right) 
\backslash
times 
\backslash
left(Q
\backslash
left[-1
\backslash
right]-Q
\backslash
left[-2
\backslash
right]
\backslash
right) 
\backslash
geq 0$:
\end_layout

\begin_layout Plain Layout

		$stk
\backslash
text{.pop}
\backslash
left( 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	$stk
\backslash
text{.append}
\backslash
left(p_i
\backslash
right)$		
\end_layout

\begin_layout Plain Layout

return $stk$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Jarvis March
\end_layout

\begin_layout Standard
Jarvis march is another convex hull finding algorithm that 
\begin_inset Quotes eld
\end_inset

gift wraps
\begin_inset Quotes erd
\end_inset

 the set of points: starting with the most south-eastern point it searchs
 out the point with the shallowest counter-clockwise angle i.e.
 
\begin_inset Quotes eld
\end_inset

rightest
\begin_inset Quotes erd
\end_inset

 turn (which is the next point in the convex hull).
 Running time is 
\begin_inset Formula $O\left(nh\right)$
\end_inset

 where 
\begin_inset Formula $h$
\end_inset

 is the number of points in the convex hull.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left

\family typewriter
Jarvis-March
\family default

\begin_inset Formula $\left(Q\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Python,mathescape=true,numbers=left,showstringspaces=false,tabsize=3"
inline false
status open

\begin_layout Plain Layout

# $Q$ is a set of points
\end_layout

\begin_layout Plain Layout

$n = 
\backslash
text{len}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

# sort all the points lexicographically in order to find
\end_layout

\begin_layout Plain Layout

# the one that's most south-eastern
\end_layout

\begin_layout Plain Layout

$Q = 
\backslash
text{sorted}
\backslash
left(Q
\backslash
right)$
\end_layout

\begin_layout Plain Layout

$p_0 = Q
\backslash
left[1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

$hull = 
\backslash
left[p_0
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# initialize candidate convex hull vertex
\end_layout

\begin_layout Plain Layout

$end = Q
\backslash
left[2
\backslash
right]$
\end_layout

\begin_layout Plain Layout

# while we haven't come back to the beginning of the hull
\end_layout

\begin_layout Plain Layout

while $end 
\backslash
neq hull
\backslash
left[1
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

	# initialize candidate convex hull vertex
\end_layout

\begin_layout Plain Layout

	$end = Q
\backslash
left[2
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	# look for a point with a "righter" angle than the vector 
\end_layout

\begin_layout Plain Layout

	# than angle from end to last added point
\end_layout

\begin_layout Plain Layout

	for $i=3:
\backslash
text{len}
\backslash
left(Q
\backslash
right)$:
\end_layout

\begin_layout Plain Layout

		# if we land on the last point added
\end_layout

\begin_layout Plain Layout

		# then we want to skip
\end_layout

\begin_layout Plain Layout

		if $end 
\backslash
in hull
\backslash
left[-1
\backslash
right]$:
\end_layout

\begin_layout Plain Layout

			$end = Q
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			$x,y = 
\backslash
left(Q
\backslash
left[i
\backslash
right]-hull
\backslash
left[-1
\backslash
right]
\backslash
right), 
\backslash
left(end-hull
\backslash
left[-1
\backslash
right]
\backslash
right)$
\end_layout

\begin_layout Plain Layout

			$ c = u 
\backslash
times v  $
\end_layout

\begin_layout Plain Layout

			# if $Q
\backslash
left[i
\backslash
right]-hull
\backslash
left[-1
\backslash
right]$ is on the right side of $end-hull
\backslash
left[-1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			# then it's "righter"
\end_layout

\begin_layout Plain Layout

			if $c > 0$
\end_layout

\begin_layout Plain Layout

				$end = Q
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

			# if $Q
\backslash
left[i
\backslash
right]$ is on the line from the last hull point to the last candidate
\end_layout

\begin_layout Plain Layout

			# then it's only on the convex hull if it's farther than the last candidate
\end_layout

\begin_layout Plain Layout

			elif $c == 0$
\end_layout

\begin_layout Plain Layout

				if $
\backslash
left(
\backslash
sqrt{u-v}
\backslash
right)^2>0$:
\end_layout

\begin_layout Plain Layout

					$end = Q
\backslash
left[i
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	$hull
\backslash
text{.append}
\backslash
left(end
\backslash
right)$
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Voronoi diagram/Nearest neighbors
\end_layout

\end_body
\end_document
