#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass amsart
\begin_preamble
% Added by lyx2lyx
\usepackage{cancel}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CLRS Summary
\end_layout

\begin_layout Section
Role of algos
\end_layout

\begin_layout Itemize
skip
\end_layout

\begin_layout Section
Getting started
\end_layout

\begin_layout Itemize
read the whole chapter.
 it sets notation for the rest of the book.
 
\end_layout

\begin_layout Itemize
don't worry too much about correctness and loop invariants but try to understand.
 read the complexity analysis for insertion sort.
 read section 2.3.1 carefully.
 
\end_layout

\begin_layout Itemize
the complexity analysis for merge sort is the template for how almost every
 other complexity analysis for a recursive function is analyzed.
 
\end_layout

\begin_layout Itemize
must do problems: 2.1-2, 2.1-4, 2.2-2 (and write the algorithm), 2.3-2, 2.3-4
 (and write the algorithm), 2.3-5, 2.3-7 (hint: use binary search).
 do as many of the others that you think you couldn't solve on the spot
 if someone gave them to you.
\end_layout

\begin_layout Section
Growth of functions
\end_layout

\begin_layout Itemize
understand the differences between all of the complexity notations, 
\begin_inset Formula $\Omega,\Theta,O,\omega,o$
\end_inset


\end_layout

\begin_layout Itemize
skim the stuff on functions.
 you really should know it given that you're an adult but it won't kill
 you (other than that you won't understand some of the complexity analyses
 later).
\end_layout

\begin_layout Section
Divide and conquer
\end_layout

\begin_layout Itemize
read about divide and conquer.
 skim the recurrence methods.
\end_layout

\begin_layout Itemize
read the maximum subarray problem closely.
\end_layout

\begin_layout Itemize
skim matrix multiplication.
 look up exponentiation by squaring on wikipedia and read this page https://www.n
ayuki.io/page/fast-fibonacci-algorithms.
 this is exactly the kind of thing you'd get asked on an interview.
\end_layout

\begin_layout Itemize
skip 4.3, 4.4, 4.5, 4.6
\end_layout

\begin_layout Itemize
must do problems: 4.1-1 (if you code it up you'll see), 4.1-2, 4.1-5 (hint:
 this is called kadane's algorithm.
 don't look it up until you think about it at least for a day), 4-4 (hint
 for part a: write out the right hand side multiplying the zs in), 4-5,
 4-6
\end_layout

\begin_layout Section
Probabilistic analysis
\end_layout

\begin_layout Itemize
read 5-1
\end_layout

\begin_layout Itemize
skip 5-2
\end_layout

\begin_layout Itemize
read 5-3 skim the proofs
\end_layout

\begin_layout Itemize
read 5.4.4
\end_layout

\begin_layout Itemize
must do problems: 5.1-1, 5.1-2, 5.1-3, 5.3-7 (this is called reservoir sampling
 [essentially].
 look it up and study the priority queue variant), look at 5-1 and 5-2.
 try to do them.
\end_layout

\begin_layout Section
heapsort
\end_layout

\begin_layout Itemize
read everything.
 understand the complexity analyses here - they're basically like merge
 sort but will come up again for tree algorithms (because a heap is basically
 a binary tree).
\end_layout

\begin_layout Itemize
must do problems: 6.1-1 - 6.1-7, 6.2-2, 6.3-3, 6.5-3, 6.5-6,6.5-7,6.5-8,6.5-9 (hint:
 the smallest elements of each of the sorted lists should always be in 
\begin_inset Quotes eld
\end_inset

direct competition
\begin_inset Quotes erd
\end_inset

), 6-2a,6-2b, 6-3 (hint for part f: at which corner of the matrix can you
 be sure of things?)
\end_layout

\begin_layout Section
Quicksort
\end_layout

\begin_layout Itemize
very important.
 most often used sort in practice.
\end_layout

\begin_layout Itemize
look up the implementation of partition on wiki instead though.
 it's not different, just clearer.
\end_layout

\begin_layout Itemize
read the complexity analysis in 7.2.
 it's important to know why/how quicksort can fail.
\end_layout

\begin_layout Itemize
read 7.3
\end_layout

\begin_layout Itemize
skim 7.4
\end_layout

\begin_layout Itemize
must do problems: 7.1-4, 7.4-3 (because you're an adult), 7-4, 7-5 (important),
 7-6
\end_layout

\begin_layout Section
Sorting in linear time
\end_layout

\begin_layout Itemize
skim 8-1.
 it's important theory and you should know about the result but no one will
 ask you to reproduce it
\end_layout

\begin_layout Itemize
read 8.2, especially the last paragraph (stability is the reason the last
 loop goes in reverse - think about why) and 8.3
\end_layout

\begin_layout Itemize
figure out how to implement counting sort so that the last loop goes in
 the forward direction but the sort is still stable
\end_layout

\begin_layout Itemize
figure out how to extend counting sort so that it sorts all integers (not
 just positive numbers).
\end_layout

\begin_layout Itemize
implement radix sort
\end_layout

\begin_layout Itemize
must do problems: 8.2-3, 8.2-4,8.4-4,8.4-5,8-2e (hint: you should have already
 figured out how to do this if you implemented radix sort),8-3,8-4ac,8-5a-e
\end_layout

\begin_layout Section
Medians and Order Statistics
\end_layout

\begin_layout Itemize
implement simultaneous max and min
\end_layout

\begin_layout Itemize
implement randomized select
\end_layout

\begin_layout Itemize
must do problems: 9.1-1 (and code it up), 9.2-3,9.3-5,9.3-6 (and code it up
 if you really want some exercise),9.3-7,9.3-8 (this one is also a tough implement
ation problem),9.3-9,9-2
\end_layout

\begin_layout Section
Elementary data structures
\end_layout

\begin_layout Itemize
implement a linked list in python with insert, search, delete, and a constructor
 that takes an array as initializer (harder than it seems: http://nedbatchelder.c
om/text/names1.html).
 
\end_layout

\begin_layout Itemize
implement a binary tree (not as simple as it seems because of above)
\end_layout

\begin_layout Itemize
skip 10-3 what a dumb section
\end_layout

\begin_layout Itemize
must do problems: 10.1-2, 10.1-5 (hint: do 10.1-2 first), 10.1-6 (don't worry
 about time analysis - you need ammortized complexity for this), 10.1-7 (same
 as 10.1-6), 10.2-6, 10.2-8, 10.4-2, 10.4-3
\end_layout

\begin_layout Section
Hash Tables
\end_layout

\begin_layout Itemize
implement hashing with chaining using the multiplication hash function with
 knuth's constant.
 if you're interested in the theoretical properties of knuth's constant
 
\begin_inset Newline newline
\end_inset

http://cstheory.stackexchange.com/questions/9639/how-did-knuth-derive-a
\end_layout

\begin_layout Itemize
implement open address hashing if you're feeling masochistic.
\end_layout

\begin_layout Itemize
study the proof of the average number of collisions.
 it's important to understand why hash tables are efficient but not magical.
 note that the number of collisions is a function of the load factor 
\begin_inset Formula $\alpha$
\end_inset

, so to keep the expected number of collisions low you need to keep 
\begin_inset Formula $\alpha$
\end_inset

 bounded.
 this is done by expanding/contracting the table.
 this is discussed in ch 17 section 4.
 i suggest you read 11.1,11.2,11.4 and then all of ch 17 (which you have to
 in order to understand 17.4) and then come back and think about the analyses
 in this chapter.
\end_layout

\begin_layout Itemize
skip 11.3 
\end_layout

\begin_layout Itemize
read 11.4 closely but don't obsess.
 
\end_layout

\begin_layout Itemize
must do problems: 11.1-2, 11.1-3, 11.1-4 (hint: check to make sure key1->index->(ke
y2,value) key1==key2), 11.2-5 (hint: pigeonhole principle), 11.2-6 (hint:
 keyword being random.
 the answer is the obvious thing, the trick is proving it's correct), 11.3-1,
 
\end_layout

\begin_layout Section
BSTs
\end_layout

\begin_layout Itemize
implement binary search tree.
 implement all of the methods in 12.2 and 12.3
\end_layout

\begin_layout Itemize
read the explanations before trying to implement the code and absolutely
 don't just blindly implement the code.
 understand the cases
\end_layout

\begin_layout Itemize
must do problems: 12.1-2, 12.1-3,12.1-4 (hint: use a prev pointer), 12.2-2,
 12.2-3, 12.3-3 (this is the point of balanced binary trees), 12.3-4 (show
 a counter-example), 12.3-6 (just think about this one), 12-2 and implement
 it (hint: look at the picture closely and figure out how to traverse that
 tree to get an ordered representation of the lightly shaded nodes) .
\end_layout

\begin_layout Section
Red-Black Trees
\end_layout

\begin_layout Itemize
read everything.
 balanced binary search trees are important and red-black trees are the
 most basic kind.
 read the included pdf that i wrote.
\end_layout

\begin_layout Itemize
implement rotate-left and rotate-right in 13.2
\end_layout

\begin_layout Itemize
implement everything.
 read the explanation before trying to implement the code and absolutely
 don't just blindly implement the code.
 understand the cases
\end_layout

\begin_layout Itemize
must do problems: 13.1-5, 13.1-6, 13.2-5
\end_layout

\begin_layout Section
Augmented Data structures
\end_layout

\begin_layout Itemize
implement order-statistic trees (good practice and you have to understand
 them to do some of the problems).
\end_layout

\begin_layout Itemize
skip 14.2
\end_layout

\begin_layout Itemize
read 14.3 closely.
 interval trees are important.
 implement.
 you need to implement insert and delete in a way that you maintain the
 added property and both require modifying left-rotate and right-rotate.
\end_layout

\begin_layout Itemize
must do problems: 14.1-3, 14.1-4, 14.1-5 (hint: what is the rank of this ith
 element?), 14.1-6, 14.1-7 (hint: use two arrays), 14.1-8 (hint: use 14.1-7),
 14.3-3, 14.3-4 (hint: you should go down the right branch but only in certain
 instances), 14.3-6 (hint: use successor and predecessor), 14.3-7, 14-1a (hint:
 by contradiction) 14-1b, 14-2a (hint: do the obvious thing and your complexity
 will come out to be 
\begin_inset Formula $O(mn)$
\end_inset

 but since 
\begin_inset Formula $m$
\end_inset

 is a constant it's 
\begin_inset Formula $O\left(n\right)$
\end_inset

, 14-2b (hint: use an order statistic tree).
\end_layout

\begin_layout Section
Dynamic Programming
\end_layout

\begin_layout Itemize
this is simultaneously the most important and worst written chapter of the
 book.
 read https://www.cs.berkeley.edu/~vazirani/algorithms/chap6.pdf instead but
 read it twice and do all the problems.
 this is like one of the most tested things in interviews.
\end_layout

\begin_layout Section
Greedy Algorithms
\end_layout

\begin_layout Itemize
This is a pretty good chapter.
 greedy algorithms are obvious but there are a good number of dynamic programmin
g problems in the exercise in situations when the greedy solution isn't
 optimal
\end_layout

\begin_layout Itemize
read 16.1, 16.2, 16.3, skip 16.4, 16.5
\end_layout

\begin_layout Itemize
implement huffman trees/coding
\end_layout

\begin_layout Itemize
must do problems: 16.1-1, 16.1-4, 16.1-5, 16.2-2, 16.2-3,16.2-4,16.2-5, 16.2-6,16.2-7,
 16.3-6 (hint: which traversals uniquely define a tree?), 16.3-7, 16-1, 16-2
\end_layout

\begin_layout Section
Amortized Analysis
\end_layout

\begin_layout Itemize
important but not too important.
 read all the sections but don't stress.
 17.4 is important though because it's how hash tables really have O(1) operation
s.
\end_layout

\begin_layout Itemize
must do problems: 17.2-3, 17.3-6, 17.4-1,17.4-2,17.4-3, 17-2, 
\end_layout

\begin_layout Section
B-Trees
\end_layout

\begin_layout Itemize
skip unless you have lots of time
\end_layout

\begin_layout Section
Fibonacci Heaps
\end_layout

\begin_layout Itemize
skip unless you have lots of time
\end_layout

\begin_layout Section
van Emde Boas Trees
\end_layout

\begin_layout Itemize
skip unless you have lots of time
\end_layout

\begin_layout Section
Data structures for disjoint sets
\end_layout

\begin_layout Itemize
pretty good chapter.
 probably a useful data structure in practice too.
 read 21.1, 21.2, 21.3, skim 21.4 but the important parts are the results lemmas
 21.11, 21.13, thm 21.14.
\end_layout

\begin_layout Itemize
must do problems: 21.1-3, 21.2-5, 21.3-2, 21.3-4, 21-1b,c,21-2a,b,c,d,21-3abc
 (these say prove but basically you should figure out how the algorithm
 works).
 there are notes in the ch21 folder that should help.
 extra credit: what's the naive way to do this?
\end_layout

\begin_layout Section
Elementary Graph Algorithms
\end_layout

\begin_layout Itemize
read everything and do all the problems
\end_layout

\begin_layout Itemize
hints: 
\end_layout

\begin_deeper
\begin_layout Itemize
22.1-6: can a universal sink have two 1s in its row
\end_layout

\begin_layout Itemize
22.2-7 use bfs somehow (since this question appears in the section on bfs
 duh)
\end_layout

\begin_layout Itemize
22.2-8 bfs gives you distances...
\end_layout

\begin_layout Itemize
22.2-9 if you didn't do tarjan's algorithm in chapter 21 do it now
\end_layout

\begin_layout Itemize
22.3-13 the obvious answer works you just have to prove it has the right
 time bounds
\end_layout

\begin_layout Itemize
22.4-2 dp
\end_layout

\begin_layout Itemize
22.4-3 again the obvious answer works , you just have to argue that the time
 bounds are right
\end_layout

\begin_layout Itemize
22-4 go in order of increasing L(u)
\end_layout

\end_deeper
\begin_layout Section
Minimum Spanning Trees
\end_layout

\begin_layout Itemize
read everything and do all the problems (ie attempt the theory problems
 - they're not too hard and it'll give you facility with the definitions).
 
\end_layout

\begin_layout Itemize
for dijkstra's algorithm you're going to need a min heap with decrease key.
 if you didn't implement it in chapter whatever with enough generaliy then
 use pythong HeapDict package .
\end_layout

\begin_layout Itemize
hints:
\end_layout

\begin_deeper
\begin_layout Itemize
23.1-11 what happens when you add the edge to the current mst?
\end_layout

\begin_layout Itemize
23.2-2 keep a list of min edge to every vertex and just take mins
\end_layout

\begin_layout Itemize
23.2-3,4 consider edges 
\begin_inset Quotes eld
\end_inset

in order
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
23.2-7 nm how fast.
 how would you do it? think about 23.1-11
\end_layout

\begin_layout Itemize
23-1a unique weights
\end_layout

\begin_layout Itemize
23-1b almost by definition
\end_layout

\begin_layout Itemize
23-1c a minimum spanning tree is a tree.
 that means what?
\end_layout

\begin_layout Itemize
23-1d sort the edges by weight.
 also be careful (you need to minimize the amount of weight added to the
 tree).
\end_layout

\end_deeper
\begin_layout Section
Sinlge-source shortest paths
\end_layout

\begin_layout Itemize
read the last section first.
 think moderately hard about the proofs.
 it'll help make the algos really make sense.
 
\end_layout

\begin_layout Itemize
really important so you should do a lot of the exercises, even the theoretical
 ones
\end_layout

\begin_layout Itemize
hints:
\end_layout

\begin_deeper
\begin_layout Itemize
24.1-3 what's a clear indicator you're done?
\end_layout

\begin_layout Itemize
24.1-5 create a universal source and run bellman-ford from that source (but
 be careful about their being only positive weight edges)
\end_layout

\begin_layout Itemize
24.1-6 there are two different ways to do this (one of them more clever than
 the other but more expensive)
\end_layout

\begin_layout Itemize
24.2-4 dp is really easy here
\end_layout

\begin_layout Itemize
24.3-4 there are a couple of properties to check but the most important one
 is whether any vertices can be relaxed
\end_layout

\begin_layout Itemize
24.3-6 use log
\end_layout

\begin_layout Itemize
24.3-7 creates more vertices
\end_layout

\begin_layout Itemize
24.3-8 use buckets
\end_layout

\begin_layout Itemize
24.3-9 what's the range of other edge weights given the last edge relax has
 weight x?
\end_layout

\begin_layout Itemize
24-1b topological sort gives you what?
\end_layout

\begin_layout Itemize
24-2 this one laid all nice for you so just 
\begin_inset Quotes eld
\end_inset

follow your nose
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
24-3 take log.
 also the key question is how to find longest or shortest cycle? if 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 is an edge in a negative weight cycle you can use bellman-ford to find
 the shortest cycle containing 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 by using 
\begin_inset Formula $v$
\end_inset

 as the source.
\end_layout

\begin_layout Itemize
24-6 i'm proud of this one.
 think about path-relaxation property from section 24.5.
 then think about what you would do if the shortest paths were only monotonic
\end_layout

\end_deeper
\begin_layout Section
All-pairs shortest paths
\end_layout

\begin_layout Itemize
read everything.
 in section 2 look at the transitive closure implementation of floyd-warshall
 before the general one.
\end_layout

\begin_layout Itemize
the key to understand Johnson's algorithm is that for any 
\begin_inset Formula $h$
\end_inset

 that obeys the triangle inequality 
\begin_inset Formula $h\left(v\right)\leq h\left(u\right)+w\left(u,v\right)$
\end_inset

 we'll get new weights that are non-negative.
\end_layout

\begin_layout Itemize
hints:
\end_layout

\begin_deeper
\begin_layout Itemize
25.1-6 guess and check essentially
\end_layout

\begin_layout Itemize
25.2-8 how long does it take to visit all of the vertices connected to a
 vertex?
\end_layout

\begin_layout Itemize
25-1a for new edge (u,v) any vertex already connected to u now becomes connected
 to # every vertex that v connects to
\end_layout

\end_deeper
\begin_layout Section
Flow networks
\end_layout

\begin_layout Itemize
read sections 1-3.
 push-relabel is supposedly important but i'm too lazy.
 
\end_layout

\begin_layout Itemize
figure out how to compute a mincut (http://stackoverflow.com/questions/4482986/ho
w-can-i-find-the-minimum-cut-on-a-graph-using-a-maximum-flow-algorithm)
\end_layout

\begin_layout Itemize
this is probably the most mathematically sophisticated chapter in the whole
 book (outside of the later chapters).
 hidden in the proofs is LP duality.
 skip the proofs - think about the intuition instead.
 edmonds-karp is simple to understand so don't despair.
 the pseudo-code in the book is kind of strange but you should be able to
 just reason your way through implementing it.
 
\end_layout

\begin_layout Itemize
hints:
\end_layout

\begin_deeper
\begin_layout Itemize
26.1-7 use two vertices and an edge connecting them.
 be careful
\end_layout

\begin_layout Itemize
26.1-11 a max flow corresponds to a mincut right? a mincut disconnects a
 vertex from a graph.
 count the edges using capacity.
 you can without loss of generality work with a single source vertex (why?)
\end_layout

\begin_layout Itemize
26.1-13 penalize cuts with more edges but be careful because you might penalize
 them too much and make non-mincut cuts cheaper than the mincut
\end_layout

\begin_layout Itemize
26-4a do the obvious thing
\end_layout

\begin_layout Itemize
26-4b define a new flow 
\begin_inset Formula $f'\left(x,y\right)=f\left(x,y\right)$
\end_inset

 except on the edge with reduced capacity - on this edge 
\begin_inset Formula $f'\left(u,v\right)=f\left(u,v\right)-1$
\end_inset

.
 is this a legal flow? fix it.
\end_layout

\begin_layout Itemize
26-6a the first part is obvious because of the conditions on the path.
 the second part is true because 
\begin_inset Formula 
\[
M\oplus\left(P_{1}\cup P_{2}\right)=\left(M\oplus P_{1}\right)\oplus P_{2}
\]

\end_inset

in this case since 
\begin_inset Formula $P_{1}\cap P_{2}=\emptyset$
\end_inset


\end_layout

\begin_layout Itemize
26-6g first do a bfs to find distances, then do a dfs to find disjoint paths.
\end_layout

\end_deeper
\end_body
\end_document
